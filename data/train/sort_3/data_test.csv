s##::##label##::##id
static int calculate_refcounts ( BlockDriverState * bs , BdrvCheckResult * res , BdrvCheckMode fix , uint16_t * * refcount_table , int64_t * nb_clusters ) { BDRVQcowState * s = bs -> opaque ; int64_t i ; QCowSnapshot * sn ; int ret ; if ( ! * refcount_table ) { * refcount_table = g_try_new0 ( uint16_t , * nb_clusters ) ; if ( * nb_clusters && * refcount_table == NULL ) { res -> check_errors ++ ; return - ENOMEM ; } } ret = inc_refcounts ( bs , res , refcount_table , nb_clusters , 0 , s -> cluster_size ) ; if ( ret < 0 ) { return ret ; } ret = check_refcounts_l1 ( bs , res , refcount_table , nb_clusters , s -> l1_table_offset , s -> l1_size , CHECK_FRAG_INFO ) ; if ( ret < 0 ) { return ret ; } for ( i = 0 ; i < s -> nb_snapshots ; i ++ ) { sn = s -> snapshots + i ; ret = check_refcounts_l1 ( bs , res , refcount_table , nb_clusters , sn -> l1_table_offset , sn -> l1_size , 0 ) ; if ( ret < 0 ) { return ret ; } } ret = inc_refcounts ( bs , res , refcount_table , nb_clusters , s -> snapshots_offset , s -> snapshots_size ) ; if ( ret < 0 ) { return ret ; } ret = inc_refcounts ( bs , res , refcount_table , nb_clusters , s -> refcount_table_offset , s -> refcount_table_size * sizeof ( uint64_t ) ) ; if ( ret < 0 ) { return ret ; } return check_refblocks ( bs , res , fix , refcount_table , nb_clusters ) ; }##::##1##::##8227
static void draw_char ( AVCodecContext * avctx , int c , int a ) { XbinContext * s = avctx -> priv_data ; if ( s -> y > avctx -> height - s -> font_height ) { return ; } ff_draw_pc_font ( s -> frame . data [ 0 ] + s -> y * s -> frame . linesize [ 0 ] + s -> x , s -> frame . linesize [ 0 ] , s -> font , s -> font_height , c , a & 0x0F , a >> 4 ) ; s -> x += FONT_WIDTH ; if ( s -> x >= avctx -> width ) { s -> x = 0 ; s -> y += s -> font_height ; } }##::##1##::##11217
static inline void RENAME ( hyscale ) ( SwsContext * c , uint16_t * dst , long dstWidth , const uint8_t * src , int srcW , int xInc , const int16_t * hLumFilter , const int16_t * hLumFilterPos , int hLumFilterSize , uint8_t * formatConvBuffer , uint32_t * pal , int isAlpha ) { void ( * toYV12 ) ( uint8_t * , const uint8_t * , long , uint32_t * ) = isAlpha ? c -> alpToYV12 : c -> lumToYV12 ; void ( * convertRange ) ( int16_t * , int ) = isAlpha ? NULL : c -> lumConvertRange ; src += isAlpha ? c -> alpSrcOffset : c -> lumSrcOffset ; if ( toYV12 ) { toYV12 ( formatConvBuffer , src , srcW , pal ) ; src = formatConvBuffer ; } if ( c -> hScale16 ) { c -> hScale16 ( dst , dstWidth , ( uint16_t * ) src , srcW , xInc , hLumFilter , hLumFilterPos , hLumFilterSize , av_pix_fmt_descriptors [ c -> srcFormat ] . comp [ 0 ] . depth_minus1 ) ; } else if ( ! c -> hyscale_fast ) { c -> hScale ( dst , dstWidth , src , srcW , xInc , hLumFilter , hLumFilterPos , hLumFilterSize ) ; } else { c -> hyscale_fast ( c , dst , dstWidth , src , srcW , xInc ) ; } if ( convertRange ) { convertRange ( dst , dstWidth ) ; } }##::##0##::##3027
void avcodec_default_release_buffer ( AVCodecContext * s , AVFrame * pic ) { int i ; InternalBuffer * buf , * last ; AVCodecInternal * avci = s -> internal ; assert ( s -> codec_type == AVMEDIA_TYPE_VIDEO ) ; assert ( pic -> type == FF_BUFFER_TYPE_INTERNAL ) ; assert ( avci -> buffer_count ) ; if ( avci -> buffer ) { buf = NULL ; for ( i = 0 ; i < avci -> buffer_count ; i ++ ) { buf = & avci -> buffer [ i ] ; if ( buf -> data [ 0 ] == pic -> data [ 0 ] ) { break ; } } assert ( i < avci -> buffer_count ) ; avci -> buffer_count -- ; last = & avci -> buffer [ avci -> buffer_count ] ; FFSWAP ( InternalBuffer , * buf , * last ) ; } for ( i = 0 ; i < AV_NUM_DATA_POINTERS ; i ++ ) { pic -> data [ i ] = NULL ; } if ( s -> debug & FF_DEBUG_BUFFERS ) av_log ( s , AV_LOG_DEBUG , "default_release_buffer called on pic %p, %d " "buffers used\n" , pic , avci -> buffer_count ) ; }##::##0##::##1023
static void xbr4x ( AVFrame * input , AVFrame * output , const uint32_t * r2y ) { const int nl = output -> linesize [ 0 ] >> 2 ; const int nl1 = nl + nl ; const int nl2 = nl1 + nl ; uint32_t pprev ; uint32_t pprev2 ; int x , y ; for ( y = 0 ; y < input -> height ; y ++ ) { uint32_t * E = ( uint32_t * ) ( output -> data [ 0 ] + y * output -> linesize [ 0 ] * 4 ) ; uint32_t * sa2 = ( uint32_t * ) ( input -> data [ 0 ] + y * input -> linesize [ 0 ] - 8 ) ; uint32_t * sa1 = sa2 - ( input -> linesize [ 0 ] >> 2 ) ; uint32_t * sa0 = sa1 - ( input -> linesize [ 0 ] >> 2 ) ; uint32_t * sa3 = sa2 + ( input -> linesize [ 0 ] >> 2 ) ; uint32_t * sa4 = sa3 + ( input -> linesize [ 0 ] >> 2 ) ; if ( y <= 1 ) { sa0 = sa1 ; if ( y == 0 ) { sa0 = sa1 = sa2 ; } } if ( y >= input -> height - 2 ) { sa4 = sa3 ; if ( y == input -> height - 1 ) { sa4 = sa3 = sa2 ; } } pprev = pprev2 = 2 ; for ( x = 0 ; x < input -> width ; x ++ ) { uint32_t B1 = sa0 [ 2 ] ; uint32_t PB = sa1 [ 2 ] ; uint32_t PE = sa2 [ 2 ] ; uint32_t PH = sa3 [ 2 ] ; uint32_t H5 = sa4 [ 2 ] ; uint32_t A1 = sa0 [ pprev ] ; uint32_t PA = sa1 [ pprev ] ; uint32_t PD = sa2 [ pprev ] ; uint32_t PG = sa3 [ pprev ] ; uint32_t G5 = sa4 [ pprev ] ; uint32_t A0 = sa1 [ pprev2 ] ; uint32_t D0 = sa2 [ pprev2 ] ; uint32_t G0 = sa3 [ pprev2 ] ; uint32_t C1 = 0 ; uint32_t PC = 0 ; uint32_t PF = 0 ; uint32_t PI = 0 ; uint32_t I5 = 0 ; uint32_t C4 = 0 ; uint32_t F4 = 0 ; uint32_t I4 = 0 ; if ( x >= input -> width - 2 ) { if ( x == input -> width - 1 ) { C1 = sa0 [ 2 ] ; PC = sa1 [ 2 ] ; PF = sa2 [ 2 ] ; PI = sa3 [ 2 ] ; I5 = sa4 [ 2 ] ; C4 = sa1 [ 2 ] ; F4 = sa2 [ 2 ] ; I4 = sa3 [ 2 ] ; } else { C1 = sa0 [ 3 ] ; PC = sa1 [ 3 ] ; PF = sa2 [ 3 ] ; PI = sa3 [ 3 ] ; I5 = sa4 [ 3 ] ; C4 = sa1 [ 3 ] ; F4 = sa2 [ 3 ] ; I4 = sa3 [ 3 ] ; } } else { C1 = sa0 [ 3 ] ; PC = sa1 [ 3 ] ; PF = sa2 [ 3 ] ; PI = sa3 [ 3 ] ; I5 = sa4 [ 3 ] ; C4 = sa1 [ 4 ] ; F4 = sa2 [ 4 ] ; I4 = sa3 [ 4 ] ; } E [ 0 ] = E [ 1 ] = E [ 2 ] = E [ 3 ] = PE ; E [ nl ] = E [ nl + 1 ] = E [ nl + 2 ] = E [ nl + 3 ] = PE ; E [ nl1 ] = E [ nl1 + 1 ] = E [ nl1 + 2 ] = E [ nl1 + 3 ] = PE ; E [ nl2 ] = E [ nl2 + 1 ] = E [ nl2 + 2 ] = E [ nl2 + 3 ] = PE ; FILT4 ( PE , PI , PH , PF , PG , PC , PD , PB , PA , G5 , C4 , G0 , D0 , C1 , B1 , F4 , I4 , H5 , I5 , A0 , A1 , nl2 + 3 , nl2 + 2 , nl1 + 3 , 3 , nl + 3 , nl1 + 2 , nl2 + 1 , nl2 , nl1 + 1 , nl + 2 , 2 , 1 , nl + 1 , nl1 , nl , 0 ) ; FILT4 ( PE , PC , PF , PB , PI , PA , PH , PD , PG , I4 , A1 , I5 , H5 , A0 , D0 , B1 , C1 , F4 , C4 , G5 , G0 , 3 , nl + 3 , 2 , 0 , 1 , nl + 2 , nl1 + 3 , nl2 + 3 , nl1 + 2 , nl + 1 , nl , nl1 , nl1 + 1 , nl2 + 2 , nl2 + 1 , nl2 ) ; FILT4 ( PE , PA , PB , PD , PC , PG , PF , PH , PI , C1 , G0 , C4 , F4 , G5 , H5 , D0 , A0 , B1 , A1 , I4 , I5 , 0 , 1 , nl , nl2 , nl1 , nl + 1 , 2 , 3 , nl + 2 , nl1 + 1 , nl2 + 1 , nl2 + 2 , nl1 + 2 , nl + 3 , nl1 + 3 , nl2 + 3 ) ; FILT4 ( PE , PG , PD , PH , PA , PI , PB , PF , PC , A0 , I5 , A1 , B1 , I4 , F4 , H5 , G5 , D0 , G0 , C1 , C4 , nl2 , nl1 , nl2 + 1 , nl2 + 3 , nl2 + 2 , nl1 + 1 , nl , 0 , nl + 1 , nl1 + 2 , nl1 + 3 , nl + 3 , nl + 2 , 1 , 2 , 3 ) ; sa0 += 1 ; sa1 += 1 ; sa2 += 1 ; sa3 += 1 ; sa4 += 1 ; E += 4 ; if ( pprev2 ) { pprev2 -- ; pprev = 1 ; } } } }##::##1##::##1506
START_TEST ( keyword_literal ) { QObject * obj ; QBool * qbool ; QString * str ; obj = qobject_from_json ( "true" ) ; fail_unless ( obj != NULL ) ; fail_unless ( qobject_type ( obj ) == QTYPE_QBOOL ) ; qbool = qobject_to_qbool ( obj ) ; fail_unless ( qbool_get_int ( qbool ) != 0 ) ; str = qobject_to_json ( obj ) ; fail_unless ( strcmp ( qstring_get_str ( str ) , "true" ) == 0 ) ; QDECREF ( str ) ; QDECREF ( qbool ) ; obj = qobject_from_json ( "false" ) ; fail_unless ( obj != NULL ) ; fail_unless ( qobject_type ( obj ) == QTYPE_QBOOL ) ; qbool = qobject_to_qbool ( obj ) ; fail_unless ( qbool_get_int ( qbool ) == 0 ) ; str = qobject_to_json ( obj ) ; fail_unless ( strcmp ( qstring_get_str ( str ) , "false" ) == 0 ) ; QDECREF ( str ) ; QDECREF ( qbool ) ; obj = qobject_from_jsonf ( "%i" , false ) ; fail_unless ( obj != NULL ) ; fail_unless ( qobject_type ( obj ) == QTYPE_QBOOL ) ; qbool = qobject_to_qbool ( obj ) ; fail_unless ( qbool_get_int ( qbool ) == 0 ) ; QDECREF ( qbool ) ; obj = qobject_from_jsonf ( "%i" , true ) ; fail_unless ( obj != NULL ) ; fail_unless ( qobject_type ( obj ) == QTYPE_QBOOL ) ; qbool = qobject_to_qbool ( obj ) ; fail_unless ( qbool_get_int ( qbool ) != 0 ) ; QDECREF ( qbool ) ; }##::##0##::##13577
iscsi_abort_task_cb ( struct iscsi_context * iscsi , int status , void * command_data , void * private_data ) { IscsiAIOCB * acb = ( IscsiAIOCB * ) private_data ; scsi_free_scsi_task ( acb -> task ) ; acb -> task = NULL ; }##::##1##::##12329
static void handle_sys ( DisasContext * s , uint32_t insn , unsigned int l , unsigned int op1 , unsigned int op2 , unsigned int crn , unsigned int crm , unsigned int rt ) { unsupported_encoding ( s , insn ) ; }##::##0##::##7707
static void virtio_pci_config_write ( void * opaque , hwaddr addr , uint64_t val , unsigned size ) { VirtIOPCIProxy * proxy = opaque ; uint32_t config = VIRTIO_PCI_CONFIG ( & proxy -> pci_dev ) ; if ( addr < config ) { virtio_ioport_write ( proxy , addr , val ) ; return ; } addr -= config ; switch ( size ) { case 1 : virtio_config_writeb ( proxy -> vdev , addr , val ) ; break ; case 2 : if ( virtio_is_big_endian ( ) ) { val = bswap16 ( val ) ; } virtio_config_writew ( proxy -> vdev , addr , val ) ; break ; case 4 : if ( virtio_is_big_endian ( ) ) { val = bswap32 ( val ) ; } virtio_config_writel ( proxy -> vdev , addr , val ) ; break ; } }##::##0##::##13321
static void scsi_cancel_io ( SCSIDevice * d , uint32_t tag ) { DPRINTF ( "scsi_cancel_io 0x%x\n" , tag ) ; SCSIGenericState * s = DO_UPCAST ( SCSIGenericState , qdev , d ) ; SCSIGenericReq * r ; DPRINTF ( "Cancel tag=0x%x\n" , tag ) ; r = scsi_find_request ( s , tag ) ; if ( r ) { if ( r -> req . aiocb ) { bdrv_aio_cancel ( r -> req . aiocb ) ; } r -> req . aiocb = NULL ; scsi_req_dequeue ( & r -> req ) ; } }##::##1##::##2875
static void t_gen_lsl ( TCGv d , TCGv a , TCGv b ) { TCGv t0 , t_31 ; t0 = tcg_temp_new ( TCG_TYPE_TL ) ; t_31 = tcg_const_tl ( 31 ) ; tcg_gen_shl_tl ( d , a , b ) ; tcg_gen_sub_tl ( t0 , t_31 , b ) ; tcg_gen_sar_tl ( t0 , t0 , t_31 ) ; tcg_gen_and_tl ( t0 , t0 , d ) ; tcg_gen_xor_tl ( d , d , t0 ) ; tcg_temp_free ( t0 ) ; tcg_temp_free ( t_31 ) ; }##::##0##::##14344
static int mov_read_stts ( MOVContext * c , AVIOContext * pb , MOVAtom atom ) { AVStream * st ; MOVStreamContext * sc ; unsigned int i , entries ; int64_t duration = 0 ; int64_t total_sample_count = 0 ; if ( c -> fc -> nb_streams < 1 ) { return 0 ; } st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ] ; sc = st -> priv_data ; avio_r8 ( pb ) ; avio_rb24 ( pb ) ; entries = avio_rb32 ( pb ) ; av_dlog ( c -> fc , "track[%i].stts.entries = %i\n" , c -> fc -> nb_streams - 1 , entries ) ; if ( entries >= UINT_MAX / sizeof ( * sc -> stts_data ) ) { return - 1 ; } sc -> stts_data = av_malloc ( entries * sizeof ( * sc -> stts_data ) ) ; if ( ! sc -> stts_data ) { return AVERROR ( ENOMEM ) ; } sc -> stts_count = entries ; for ( i = 0 ; i < entries ; i ++ ) { int sample_duration ; int sample_count ; sample_count = avio_rb32 ( pb ) ; sample_duration = avio_rb32 ( pb ) ; sc -> stts_data [ i ] . count = sample_count ; sc -> stts_data [ i ] . duration = sample_duration ; av_dlog ( c -> fc , "sample_count=%d, sample_duration=%d\n" , sample_count , sample_duration ) ; duration += ( int64_t ) sample_duration * sample_count ; total_sample_count += sample_count ; } st -> nb_frames = total_sample_count ; if ( duration ) { st -> duration = duration ; } return 0 ; }##::##1##::##8822
void av_thread_message_queue_free ( AVThreadMessageQueue * * mq ) { # if HAVE_THREADS if ( * mq ) { av_thread_message_flush ( * mq ) ; av_fifo_freep ( & ( * mq ) -> fifo ) ; pthread_cond_destroy ( & ( * mq ) -> cond ) ; pthread_mutex_destroy ( & ( * mq ) -> lock ) ; av_freep ( mq ) ; } # endif }##::##1##::##3506
int net_init_vde ( QemuOpts * opts , Monitor * mon , const char * name , VLANState * vlan ) { const char * sock ; const char * group ; int port , mode ; sock = qemu_opt_get ( opts , "sock" ) ; group = qemu_opt_get ( opts , "group" ) ; port = qemu_opt_get_number ( opts , "port" , 0 ) ; mode = qemu_opt_get_number ( opts , "mode" , 0700 ) ; if ( net_vde_init ( vlan , "vde" , name , sock , port , group , mode ) == - 1 ) { return - 1 ; } if ( vlan ) { vlan -> nb_host_devs ++ ; } return 0 ; }##::##0##::##8156
static int qcow_create ( const char * filename , QemuOpts * opts , Error * * errp ) { int header_size , backing_filename_len , l1_size , shift , i ; QCowHeader header ; uint8_t * tmp ; int64_t total_size = 0 ; char * backing_file = NULL ; Error * local_err = NULL ; int ret ; BlockBackend * qcow_blk ; const char * encryptfmt = NULL ; QDict * options ; QDict * encryptopts = NULL ; QCryptoBlockCreateOptions * crypto_opts = NULL ; QCryptoBlock * crypto = NULL ; total_size = ROUND_UP ( qemu_opt_get_size_del ( opts , BLOCK_OPT_SIZE , 0 ) , BDRV_SECTOR_SIZE ) ; if ( total_size == 0 ) { error_setg ( errp , "Image size is too small, cannot be zero length" ) ; ret = - EINVAL ; goto cleanup ; } backing_file = qemu_opt_get_del ( opts , BLOCK_OPT_BACKING_FILE ) ; encryptfmt = qemu_opt_get_del ( opts , BLOCK_OPT_ENCRYPT_FORMAT ) ; if ( encryptfmt ) { if ( qemu_opt_get ( opts , BLOCK_OPT_ENCRYPT ) ) { error_setg ( errp , "Options " BLOCK_OPT_ENCRYPT " and " BLOCK_OPT_ENCRYPT_FORMAT " are mutually exclusive" ) ; ret = - EINVAL ; goto cleanup ; } } else if ( qemu_opt_get_bool_del ( opts , BLOCK_OPT_ENCRYPT , false ) ) { encryptfmt = "aes" ; } ret = bdrv_create_file ( filename , opts , & local_err ) ; if ( ret < 0 ) { error_propagate ( errp , local_err ) ; goto cleanup ; } qcow_blk = blk_new_open ( filename , NULL , NULL , BDRV_O_RDWR | BDRV_O_RESIZE | BDRV_O_PROTOCOL , & local_err ) ; if ( qcow_blk == NULL ) { error_propagate ( errp , local_err ) ; ret = - EIO ; goto cleanup ; } blk_set_allow_write_beyond_eof ( qcow_blk , true ) ; ret = blk_truncate ( qcow_blk , 0 , PREALLOC_MODE_OFF , errp ) ; if ( ret < 0 ) { goto exit ; } memset ( & header , 0 , sizeof ( header ) ) ; header . magic = cpu_to_be32 ( QCOW_MAGIC ) ; header . version = cpu_to_be32 ( QCOW_VERSION ) ; header . size = cpu_to_be64 ( total_size ) ; header_size = sizeof ( header ) ; backing_filename_len = 0 ; if ( backing_file ) { if ( strcmp ( backing_file , "fat:" ) ) { header . backing_file_offset = cpu_to_be64 ( header_size ) ; backing_filename_len = strlen ( backing_file ) ; header . backing_file_size = cpu_to_be32 ( backing_filename_len ) ; header_size += backing_filename_len ; } else { g_free ( backing_file ) ; backing_file = NULL ; } header . cluster_bits = 9 ; header . l2_bits = 12 ; } else { header . cluster_bits = 12 ; header . l2_bits = 9 ; } header_size = ( header_size + 7 ) & ~ 7 ; shift = header . cluster_bits + header . l2_bits ; l1_size = ( total_size + ( 1LL << shift ) - 1 ) >> shift ; header . l1_table_offset = cpu_to_be64 ( header_size ) ; options = qemu_opts_to_qdict ( opts , NULL ) ; qdict_extract_subqdict ( options , & encryptopts , "encrypt." ) ; QDECREF ( options ) ; if ( encryptfmt ) { if ( ! g_str_equal ( encryptfmt , "aes" ) ) { error_setg ( errp , "Unknown encryption format '%s', expected 'aes'" , encryptfmt ) ; ret = - EINVAL ; goto exit ; } header . crypt_method = cpu_to_be32 ( QCOW_CRYPT_AES ) ; crypto_opts = block_crypto_create_opts_init ( Q_CRYPTO_BLOCK_FORMAT_QCOW , encryptopts , errp ) ; if ( ! crypto_opts ) { ret = - EINVAL ; goto exit ; } crypto = qcrypto_block_create ( crypto_opts , "encrypt." , NULL , NULL , NULL , errp ) ; if ( ! crypto ) { ret = - EINVAL ; goto exit ; } } else { header . crypt_method = cpu_to_be32 ( QCOW_CRYPT_NONE ) ; } ret = blk_pwrite ( qcow_blk , 0 , & header , sizeof ( header ) , 0 ) ; if ( ret != sizeof ( header ) ) { goto exit ; } if ( backing_file ) { ret = blk_pwrite ( qcow_blk , sizeof ( header ) , backing_file , backing_filename_len , 0 ) ; if ( ret != backing_filename_len ) { goto exit ; } } tmp = g_malloc0 ( BDRV_SECTOR_SIZE ) ; for ( i = 0 ; i < DIV_ROUND_UP ( sizeof ( uint64_t ) * l1_size , BDRV_SECTOR_SIZE ) ; i ++ ) { ret = blk_pwrite ( qcow_blk , header_size + BDRV_SECTOR_SIZE * i , tmp , BDRV_SECTOR_SIZE , 0 ) ; if ( ret != BDRV_SECTOR_SIZE ) { g_free ( tmp ) ; goto exit ; } } g_free ( tmp ) ; ret = 0 ; exit : blk_unref ( qcow_blk ) ; cleanup : QDECREF ( encryptopts ) ; qcrypto_block_free ( crypto ) ; qapi_free_QCryptoBlockCreateOptions ( crypto_opts ) ; g_free ( backing_file ) ; return ret ; }##::##1##::##1520
static int hap_encode ( AVCodecContext * avctx , AVPacket * pkt , const AVFrame * frame , int * got_packet ) { HapContext * ctx = avctx -> priv_data ; int header_length = hap_header_length ( ctx ) ; int final_data_size , ret ; int pktsize = FFMAX ( ctx -> tex_size , ctx -> max_snappy * ctx -> chunk_count ) + header_length ; ret = ff_alloc_packet2 ( avctx , pkt , pktsize , header_length ) ; if ( ret < 0 ) { return ret ; } ret = compress_texture ( avctx , ctx -> tex_buf , ctx -> tex_size , frame ) ; if ( ret < 0 ) { return ret ; } final_data_size = hap_compress_frame ( avctx , pkt -> data + header_length ) ; if ( final_data_size < 0 ) { return final_data_size ; } hap_write_frame_header ( ctx , pkt -> data , final_data_size + header_length ) ; av_shrink_packet ( pkt , final_data_size + header_length ) ; pkt -> flags |= AV_PKT_FLAG_KEY ; * got_packet = 1 ; return 0 ; }##::##0##::##9354
static void read_info_chunk ( AVFormatContext * s , int64_t size ) { AVIOContext * pb = s -> pb ; unsigned int i ; unsigned int nb_entries = avio_rb32 ( pb ) ; for ( i = 0 ; i < nb_entries ; i ++ ) { char key [ 32 ] ; char value [ 1024 ] ; avio_get_str ( pb , INT_MAX , key , sizeof ( key ) ) ; avio_get_str ( pb , INT_MAX , value , sizeof ( value ) ) ; av_dict_set ( & s -> metadata , key , value , 0 ) ; } }##::##0##::##10563
static av_cold int vaapi_encode_h264_init ( AVCodecContext * avctx ) { return ff_vaapi_encode_init ( avctx , & vaapi_encode_type_h264 ) ; }##::##0##::##9759
int fread_targphys ( target_phys_addr_t dst_addr , size_t nbytes , FILE * f ) { uint8_t buf [ 4096 ] ; target_phys_addr_t dst_begin = dst_addr ; size_t want , did ; while ( nbytes ) { want = nbytes > sizeof ( buf ) ? sizeof ( buf ) : nbytes ; did = fread ( buf , 1 , want , f ) ; cpu_physical_memory_write_rom ( dst_addr , buf , did ) ; dst_addr += did ; nbytes -= did ; if ( did != want ) { break ; } } return dst_addr - dst_begin ; }##::##0##::##11196
int ff_find_unused_picture ( MpegEncContext * s , int shared ) { int i ; if ( shared ) { for ( i = 0 ; i < MAX_PICTURE_COUNT ; i ++ ) { if ( s -> picture [ i ] . data [ 0 ] == NULL && s -> picture [ i ] . type == 0 ) { return i ; } } } else { for ( i = 0 ; i < MAX_PICTURE_COUNT ; i ++ ) { if ( s -> picture [ i ] . data [ 0 ] == NULL && s -> picture [ i ] . type != 0 ) { return i ; } } for ( i = 0 ; i < MAX_PICTURE_COUNT ; i ++ ) { if ( s -> picture [ i ] . data [ 0 ] == NULL ) { return i ; } } } assert ( 0 ) ; return - 1 ; }##::##1##::##10330
static int ape_decode_frame ( AVCodecContext * avctx , void * data , int * data_size , AVPacket * avpkt ) { const uint8_t * buf = avpkt -> data ; int buf_size = avpkt -> size ; APEContext * s = avctx -> priv_data ; int16_t * samples = data ; int nblocks ; int i , n ; int blockstodecode ; int bytes_used ; if ( BLOCKS_PER_LOOP * 2 * avctx -> channels > * data_size ) { av_log ( avctx , AV_LOG_ERROR , "Output buffer is too small.\n" ) ; return AVERROR ( EINVAL ) ; } if ( ! s -> samples ) { void * tmp_data = av_realloc ( s -> data , ( buf_size + 3 ) & ~ 3 ) ; if ( ! tmp_data ) { return AVERROR ( ENOMEM ) ; } s -> data = tmp_data ; s -> dsp . bswap_buf ( ( uint32_t * ) s -> data , ( const uint32_t * ) buf , buf_size >> 2 ) ; s -> ptr = s -> last_ptr = s -> data ; s -> data_end = s -> data + buf_size ; nblocks = s -> samples = bytestream_get_be32 ( & s -> ptr ) ; n = bytestream_get_be32 ( & s -> ptr ) ; if ( n < 0 || n > 3 ) { av_log ( avctx , AV_LOG_ERROR , "Incorrect offset passed\n" ) ; s -> data = NULL ; return AVERROR_INVALIDDATA ; } s -> ptr += n ; s -> currentframeblocks = nblocks ; buf += 4 ; if ( s -> samples <= 0 ) { * data_size = 0 ; return buf_size ; } memset ( s -> decoded0 , 0 , sizeof ( s -> decoded0 ) ) ; memset ( s -> decoded1 , 0 , sizeof ( s -> decoded1 ) ) ; init_frame_decoder ( s ) ; } if ( ! s -> data ) { * data_size = 0 ; return buf_size ; } nblocks = s -> samples ; blockstodecode = FFMIN ( BLOCKS_PER_LOOP , nblocks ) ; s -> error = 0 ; if ( ( s -> channels == 1 ) || ( s -> frameflags & APE_FRAMECODE_PSEUDO_STEREO ) ) { ape_unpack_mono ( s , blockstodecode ) ; } else { ape_unpack_stereo ( s , blockstodecode ) ; } emms_c ( ) ; if ( s -> error || s -> ptr > s -> data_end ) { s -> samples = 0 ; av_log ( avctx , AV_LOG_ERROR , "Error decoding frame\n" ) ; return AVERROR_INVALIDDATA ; } for ( i = 0 ; i < blockstodecode ; i ++ ) { * samples ++ = s -> decoded0 [ i ] ; if ( s -> channels == 2 ) { * samples ++ = s -> decoded1 [ i ] ; } } s -> samples -= blockstodecode ; * data_size = blockstodecode * 2 * s -> channels ; bytes_used = s -> samples ? s -> ptr - s -> last_ptr : buf_size ; s -> last_ptr = s -> ptr ; return bytes_used ; }##::##1##::##1120
static void unix_accept_incoming_migration ( void * opaque ) { struct sockaddr_un addr ; socklen_t addrlen = sizeof ( addr ) ; int s = ( unsigned long ) opaque ; QEMUFile * f ; int c , ret ; do { c = accept ( s , ( struct sockaddr * ) & addr , & addrlen ) ; } while ( c == - 1 && socket_error ( ) == EINTR ) ; dprintf ( "accepted migration\n" ) ; if ( c == - 1 ) { fprintf ( stderr , "could not accept migration connection\n" ) ; return ; } f = qemu_fopen_socket ( c ) ; if ( f == NULL ) { fprintf ( stderr , "could not qemu_fopen socket\n" ) ; goto out ; } ret = qemu_loadvm_state ( f ) ; if ( ret < 0 ) { fprintf ( stderr , "load of migration failed\n" ) ; goto out_fopen ; } qemu_announce_self ( ) ; dprintf ( "successfully loaded vm state\n" ) ; qemu_set_fd_handler2 ( s , NULL , NULL , NULL , NULL ) ; close ( s ) ; out_fopen : qemu_fclose ( f ) ; out : close ( c ) ; }##::##1##::##1337
static inline void downmix_3f_1r_to_dolby ( float * samples ) { int i ; for ( i = 0 ; i < 256 ; i ++ ) { samples [ i ] += ( samples [ i + 256 ] - samples [ i + 768 ] ) ; samples [ i + 256 ] += ( samples [ i + 512 ] + samples [ i + 768 ] ) ; samples [ i + 512 ] = samples [ i + 768 ] = 0 ; } }##::##0##::##11965
static uint32_t get_features ( VirtIODevice * vdev , uint32_t features ) { VirtIOSerial * vser ; vser = VIRTIO_SERIAL ( vdev ) ; if ( vser -> bus . max_nr_ports > 1 ) { features |= ( 1 << VIRTIO_CONSOLE_F_MULTIPORT ) ; } return features ; }##::##0##::##6045
static void vt82c686b_init_ports ( PCIIDEState * d ) { int i ; struct { int iobase ; int iobase2 ; int isairq ; } port_info [ ] = { { 0x1f0 , 0x3f6 , 14 } , { 0x170 , 0x376 , 15 } , } ; for ( i = 0 ; i < 2 ; i ++ ) { ide_bus_new ( & d -> bus [ i ] , & d -> dev . qdev , i ) ; ide_init_ioport ( & d -> bus [ i ] , port_info [ i ] . iobase , port_info [ i ] . iobase2 ) ; ide_init2 ( & d -> bus [ i ] , isa_reserve_irq ( port_info [ i ] . isairq ) ) ; bmdma_init ( & d -> bus [ i ] , & d -> bmdma [ i ] ) ; d -> bmdma [ i ] . bus = & d -> bus [ i ] ; qemu_add_vm_change_state_handler ( d -> bus [ i ] . dma -> ops -> restart_cb , & d -> bmdma [ i ] . dma ) ; } }##::##0##::##9528
av_cold int sws_init_context ( SwsContext * c , SwsFilter * srcFilter , SwsFilter * dstFilter ) { int i ; int usesVFilter , usesHFilter ; int unscaled ; SwsFilter dummyFilter = { NULL , NULL , NULL , NULL } ; int srcW = c -> srcW ; int srcH = c -> srcH ; int dstW = c -> dstW ; int dstH = c -> dstH ; int dst_stride = FFALIGN ( dstW * sizeof ( int16_t ) + 16 , 16 ) ; int dst_stride_px = dst_stride >> 1 ; int flags , cpu_flags ; enum AVPixelFormat srcFormat = c -> srcFormat ; enum AVPixelFormat dstFormat = c -> dstFormat ; const AVPixFmtDescriptor * desc_src = av_pix_fmt_desc_get ( srcFormat ) ; const AVPixFmtDescriptor * desc_dst = av_pix_fmt_desc_get ( dstFormat ) ; cpu_flags = av_get_cpu_flags ( ) ; flags = c -> flags ; emms_c ( ) ; if ( ! rgb15to16 ) { ff_rgb2rgb_init ( ) ; } unscaled = ( srcW == dstW && srcH == dstH ) ; if ( ! ( unscaled && sws_isSupportedEndiannessConversion ( srcFormat ) && av_pix_fmt_swap_endianness ( srcFormat ) == dstFormat ) ) { if ( ! sws_isSupportedInput ( srcFormat ) ) { av_log ( c , AV_LOG_ERROR , "%s is not supported as input pixel format\n" , sws_format_name ( srcFormat ) ) ; return AVERROR ( EINVAL ) ; } if ( ! sws_isSupportedOutput ( dstFormat ) ) { av_log ( c , AV_LOG_ERROR , "%s is not supported as output pixel format\n" , sws_format_name ( dstFormat ) ) ; return AVERROR ( EINVAL ) ; } } i = flags & ( SWS_POINT | SWS_AREA | SWS_BILINEAR | SWS_FAST_BILINEAR | SWS_BICUBIC | SWS_X | SWS_GAUSS | SWS_LANCZOS | SWS_SINC | SWS_SPLINE | SWS_BICUBLIN ) ; if ( ! i ) { if ( dstW < srcW && dstH < srcH ) { flags |= SWS_GAUSS ; } else if ( dstW > srcW && dstH > srcH ) { flags |= SWS_SINC ; } else { flags |= SWS_LANCZOS ; } c -> flags = flags ; } else if ( i & ( i - 1 ) ) { av_log ( c , AV_LOG_ERROR , "Exactly one scaler algorithm must be chosen\n" ) ; return AVERROR ( EINVAL ) ; } if ( srcW < 4 || srcH < 1 || dstW < 8 || dstH < 1 ) { av_log ( c , AV_LOG_ERROR , "%dx%d -> %dx%d is invalid scaling dimension\n" , srcW , srcH , dstW , dstH ) ; return AVERROR ( EINVAL ) ; } if ( ! dstFilter ) { dstFilter = & dummyFilter ; } if ( ! srcFilter ) { srcFilter = & dummyFilter ; } c -> lumXInc = ( ( ( int64_t ) srcW << 16 ) + ( dstW >> 1 ) ) / dstW ; c -> lumYInc = ( ( ( int64_t ) srcH << 16 ) + ( dstH >> 1 ) ) / dstH ; c -> dstFormatBpp = av_get_bits_per_pixel ( desc_dst ) ; c -> srcFormatBpp = av_get_bits_per_pixel ( desc_src ) ; c -> vRounder = 4 * 0x0001000100010001ULL ; usesVFilter = ( srcFilter -> lumV && srcFilter -> lumV -> length > 1 ) || ( srcFilter -> chrV && srcFilter -> chrV -> length > 1 ) || ( dstFilter -> lumV && dstFilter -> lumV -> length > 1 ) || ( dstFilter -> chrV && dstFilter -> chrV -> length > 1 ) ; usesHFilter = ( srcFilter -> lumH && srcFilter -> lumH -> length > 1 ) || ( srcFilter -> chrH && srcFilter -> chrH -> length > 1 ) || ( dstFilter -> lumH && dstFilter -> lumH -> length > 1 ) || ( dstFilter -> chrH && dstFilter -> chrH -> length > 1 ) ; getSubSampleFactors ( & c -> chrSrcHSubSample , & c -> chrSrcVSubSample , srcFormat ) ; getSubSampleFactors ( & c -> chrDstHSubSample , & c -> chrDstVSubSample , dstFormat ) ; if ( isPlanarRGB ( dstFormat ) ) { if ( ! ( flags & SWS_FULL_CHR_H_INT ) ) { av_log ( c , AV_LOG_DEBUG , "%s output is not supported with half chroma resolution, switching to full\n" , av_get_pix_fmt_name ( dstFormat ) ) ; flags |= SWS_FULL_CHR_H_INT ; c -> flags = flags ; } } if ( flags & SWS_FULL_CHR_H_INT && isAnyRGB ( dstFormat ) && ! isPlanarRGB ( dstFormat ) && dstFormat != AV_PIX_FMT_RGBA && dstFormat != AV_PIX_FMT_ARGB && dstFormat != AV_PIX_FMT_BGRA && dstFormat != AV_PIX_FMT_ABGR && dstFormat != AV_PIX_FMT_RGB24 && dstFormat != AV_PIX_FMT_BGR24 ) { av_log ( c , AV_LOG_ERROR , "full chroma interpolation for destination format '%s' not yet implemented\n" , sws_format_name ( dstFormat ) ) ; flags &= ~ SWS_FULL_CHR_H_INT ; c -> flags = flags ; } if ( isAnyRGB ( dstFormat ) && ! ( flags & SWS_FULL_CHR_H_INT ) ) { c -> chrDstHSubSample = 1 ; } c -> vChrDrop = ( flags & SWS_SRC_V_CHR_DROP_MASK ) >> SWS_SRC_V_CHR_DROP_SHIFT ; c -> chrSrcVSubSample += c -> vChrDrop ; if ( isAnyRGB ( srcFormat ) && ! ( flags & SWS_FULL_CHR_H_INP ) && srcFormat != AV_PIX_FMT_RGB8 && srcFormat != AV_PIX_FMT_BGR8 && srcFormat != AV_PIX_FMT_RGB4 && srcFormat != AV_PIX_FMT_BGR4 && srcFormat != AV_PIX_FMT_RGB4_BYTE && srcFormat != AV_PIX_FMT_BGR4_BYTE && srcFormat != AV_PIX_FMT_GBRP9BE && srcFormat != AV_PIX_FMT_GBRP9LE && srcFormat != AV_PIX_FMT_GBRP10BE && srcFormat != AV_PIX_FMT_GBRP10LE && srcFormat != AV_PIX_FMT_GBRAP10BE && srcFormat != AV_PIX_FMT_GBRAP10LE && srcFormat != AV_PIX_FMT_GBRP12BE && srcFormat != AV_PIX_FMT_GBRP12LE && srcFormat != AV_PIX_FMT_GBRP16BE && srcFormat != AV_PIX_FMT_GBRP16LE && ( ( dstW >> c -> chrDstHSubSample ) <= ( srcW >> 1 ) || ( flags & SWS_FAST_BILINEAR ) ) ) { c -> chrSrcHSubSample = 1 ; } c -> chrSrcW = AV_CEIL_RSHIFT ( srcW , c -> chrSrcHSubSample ) ; c -> chrSrcH = AV_CEIL_RSHIFT ( srcH , c -> chrSrcVSubSample ) ; c -> chrDstW = AV_CEIL_RSHIFT ( dstW , c -> chrDstHSubSample ) ; c -> chrDstH = AV_CEIL_RSHIFT ( dstH , c -> chrDstVSubSample ) ; if ( unscaled && ! usesHFilter && ! usesVFilter && ( c -> srcRange == c -> dstRange || isAnyRGB ( dstFormat ) ) ) { ff_get_unscaled_swscale ( c ) ; if ( c -> swscale ) { if ( flags & SWS_PRINT_INFO ) av_log ( c , AV_LOG_INFO , "using unscaled %s -> %s special converter\n" , sws_format_name ( srcFormat ) , sws_format_name ( dstFormat ) ) ; return 0 ; } } c -> srcBpc = desc_src -> comp [ 0 ] . depth ; if ( c -> srcBpc < 8 ) { c -> srcBpc = 8 ; } c -> dstBpc = desc_dst -> comp [ 0 ] . depth ; if ( c -> dstBpc < 8 ) { c -> dstBpc = 8 ; } if ( c -> dstBpc == 16 ) { dst_stride <<= 1 ; } FF_ALLOC_OR_GOTO ( c , c -> formatConvBuffer , ( FFALIGN ( srcW , 16 ) * 2 * FFALIGN ( c -> srcBpc , 8 ) >> 3 ) + 16 , fail ) ; if ( INLINE_MMXEXT ( cpu_flags ) && c -> srcBpc == 8 && c -> dstBpc <= 12 ) { c -> canMMXEXTBeUsed = ( dstW >= srcW && ( dstW & 31 ) == 0 && ( srcW & 15 ) == 0 ) ? 1 : 0 ; if ( ! c -> canMMXEXTBeUsed && dstW >= srcW && ( srcW & 15 ) == 0 && ( flags & SWS_FAST_BILINEAR ) ) { if ( flags & SWS_PRINT_INFO ) av_log ( c , AV_LOG_INFO , "output width is not a multiple of 32 -> no MMXEXT scaler\n" ) ; } if ( usesHFilter ) { c -> canMMXEXTBeUsed = 0 ; } } else { c -> canMMXEXTBeUsed = 0 ; } c -> chrXInc = ( ( ( int64_t ) c -> chrSrcW << 16 ) + ( c -> chrDstW >> 1 ) ) / c -> chrDstW ; c -> chrYInc = ( ( ( int64_t ) c -> chrSrcH << 16 ) + ( c -> chrDstH >> 1 ) ) / c -> chrDstH ; if ( flags & SWS_FAST_BILINEAR ) { if ( c -> canMMXEXTBeUsed ) { c -> lumXInc += 20 ; c -> chrXInc += 20 ; } else if ( INLINE_MMX ( cpu_flags ) ) { c -> lumXInc = ( ( int64_t ) ( srcW - 2 ) << 16 ) / ( dstW - 2 ) - 20 ; c -> chrXInc = ( ( int64_t ) ( c -> chrSrcW - 2 ) << 16 ) / ( c -> chrDstW - 2 ) - 20 ; } } # define USE_MMAP ( HAVE_MMAP && HAVE_MPROTECT && defined MAP_ANONYMOUS ) { # if HAVE_MMXEXT_INLINE if ( c -> canMMXEXTBeUsed && ( flags & SWS_FAST_BILINEAR ) ) { c -> lumMmxextFilterCodeSize = init_hscaler_mmxext ( dstW , c -> lumXInc , NULL , NULL , NULL , 8 ) ; c -> chrMmxextFilterCodeSize = init_hscaler_mmxext ( c -> chrDstW , c -> chrXInc , NULL , NULL , NULL , 4 ) ; # if USE_MMAP c -> lumMmxextFilterCode = mmap ( NULL , c -> lumMmxextFilterCodeSize , PROT_READ | PROT_WRITE , MAP_PRIVATE | MAP_ANONYMOUS , - 1 , 0 ) ; c -> chrMmxextFilterCode = mmap ( NULL , c -> chrMmxextFilterCodeSize , PROT_READ | PROT_WRITE , MAP_PRIVATE | MAP_ANONYMOUS , - 1 , 0 ) ; # elif HAVE_VIRTUALALLOC c -> lumMmxextFilterCode = VirtualAlloc ( NULL , c -> lumMmxextFilterCodeSize , MEM_COMMIT , PAGE_EXECUTE_READWRITE ) ; c -> chrMmxextFilterCode = VirtualAlloc ( NULL , c -> chrMmxextFilterCodeSize , MEM_COMMIT , PAGE_EXECUTE_READWRITE ) ; # else c -> lumMmxextFilterCode = av_malloc ( c -> lumMmxextFilterCodeSize ) ; c -> chrMmxextFilterCode = av_malloc ( c -> chrMmxextFilterCodeSize ) ; # endif if ( ! c -> lumMmxextFilterCode || ! c -> chrMmxextFilterCode ) { return AVERROR ( ENOMEM ) ; } FF_ALLOCZ_OR_GOTO ( c , c -> hLumFilter , ( dstW / 8 + 8 ) * sizeof ( int16_t ) , fail ) ; FF_ALLOCZ_OR_GOTO ( c , c -> hChrFilter , ( c -> chrDstW / 4 + 8 ) * sizeof ( int16_t ) , fail ) ; FF_ALLOCZ_OR_GOTO ( c , c -> hLumFilterPos , ( dstW / 2 / 8 + 8 ) * sizeof ( int32_t ) , fail ) ; FF_ALLOCZ_OR_GOTO ( c , c -> hChrFilterPos , ( c -> chrDstW / 2 / 4 + 8 ) * sizeof ( int32_t ) , fail ) ; init_hscaler_mmxext ( dstW , c -> lumXInc , c -> lumMmxextFilterCode , c -> hLumFilter , c -> hLumFilterPos , 8 ) ; init_hscaler_mmxext ( c -> chrDstW , c -> chrXInc , c -> chrMmxextFilterCode , c -> hChrFilter , c -> hChrFilterPos , 4 ) ; # if USE_MMAP mprotect ( c -> lumMmxextFilterCode , c -> lumMmxextFilterCodeSize , PROT_EXEC | PROT_READ ) ; mprotect ( c -> chrMmxextFilterCode , c -> chrMmxextFilterCodeSize , PROT_EXEC | PROT_READ ) ; # endif } else # endif { const int filterAlign = X86_MMX ( cpu_flags ) ? 4 : PPC_ALTIVEC ( cpu_flags ) ? 8 : 1 ; if ( initFilter ( & c -> hLumFilter , & c -> hLumFilterPos , & c -> hLumFilterSize , c -> lumXInc , srcW , dstW , filterAlign , 1 << 14 , ( flags & SWS_BICUBLIN ) ? ( flags | SWS_BICUBIC ) : flags , cpu_flags , srcFilter -> lumH , dstFilter -> lumH , c -> param , 1 ) < 0 ) { goto fail ; } if ( initFilter ( & c -> hChrFilter , & c -> hChrFilterPos , & c -> hChrFilterSize , c -> chrXInc , c -> chrSrcW , c -> chrDstW , filterAlign , 1 << 14 , ( flags & SWS_BICUBLIN ) ? ( flags | SWS_BILINEAR ) : flags , cpu_flags , srcFilter -> chrH , dstFilter -> chrH , c -> param , 1 ) < 0 ) { goto fail ; } } } { const int filterAlign = X86_MMX ( cpu_flags ) ? 2 : PPC_ALTIVEC ( cpu_flags ) ? 8 : 1 ; if ( initFilter ( & c -> vLumFilter , & c -> vLumFilterPos , & c -> vLumFilterSize , c -> lumYInc , srcH , dstH , filterAlign , ( 1 << 12 ) , ( flags & SWS_BICUBLIN ) ? ( flags | SWS_BICUBIC ) : flags , cpu_flags , srcFilter -> lumV , dstFilter -> lumV , c -> param , 0 ) < 0 ) { goto fail ; } if ( initFilter ( & c -> vChrFilter , & c -> vChrFilterPos , & c -> vChrFilterSize , c -> chrYInc , c -> chrSrcH , c -> chrDstH , filterAlign , ( 1 << 12 ) , ( flags & SWS_BICUBLIN ) ? ( flags | SWS_BILINEAR ) : flags , cpu_flags , srcFilter -> chrV , dstFilter -> chrV , c -> param , 0 ) < 0 ) { goto fail ; } # if HAVE_ALTIVEC FF_ALLOC_OR_GOTO ( c , c -> vYCoeffsBank , sizeof ( vector signed short ) * c -> vLumFilterSize * c -> dstH , fail ) ; FF_ALLOC_OR_GOTO ( c , c -> vCCoeffsBank , sizeof ( vector signed short ) * c -> vChrFilterSize * c -> chrDstH , fail ) ; for ( i = 0 ; i < c -> vLumFilterSize * c -> dstH ; i ++ ) { int j ; short * p = ( short * ) & c -> vYCoeffsBank [ i ] ; for ( j = 0 ; j < 8 ; j ++ ) { p [ j ] = c -> vLumFilter [ i ] ; } } for ( i = 0 ; i < c -> vChrFilterSize * c -> chrDstH ; i ++ ) { int j ; short * p = ( short * ) & c -> vCCoeffsBank [ i ] ; for ( j = 0 ; j < 8 ; j ++ ) { p [ j ] = c -> vChrFilter [ i ] ; } } # endif } c -> vLumBufSize = c -> vLumFilterSize ; c -> vChrBufSize = c -> vChrFilterSize ; for ( i = 0 ; i < dstH ; i ++ ) { int chrI = ( int64_t ) i * c -> chrDstH / dstH ; int nextSlice = FFMAX ( c -> vLumFilterPos [ i ] + c -> vLumFilterSize - 1 , ( ( c -> vChrFilterPos [ chrI ] + c -> vChrFilterSize - 1 ) << c -> chrSrcVSubSample ) ) ; nextSlice >>= c -> chrSrcVSubSample ; nextSlice <<= c -> chrSrcVSubSample ; if ( c -> vLumFilterPos [ i ] + c -> vLumBufSize < nextSlice ) { c -> vLumBufSize = nextSlice - c -> vLumFilterPos [ i ] ; } if ( c -> vChrFilterPos [ chrI ] + c -> vChrBufSize < ( nextSlice >> c -> chrSrcVSubSample ) ) c -> vChrBufSize = ( nextSlice >> c -> chrSrcVSubSample ) - c -> vChrFilterPos [ chrI ] ; } FF_ALLOC_OR_GOTO ( c , c -> lumPixBuf , c -> vLumBufSize * 3 * sizeof ( int16_t * ) , fail ) ; FF_ALLOC_OR_GOTO ( c , c -> chrUPixBuf , c -> vChrBufSize * 3 * sizeof ( int16_t * ) , fail ) ; FF_ALLOC_OR_GOTO ( c , c -> chrVPixBuf , c -> vChrBufSize * 3 * sizeof ( int16_t * ) , fail ) ; if ( CONFIG_SWSCALE_ALPHA && isALPHA ( c -> srcFormat ) && isALPHA ( c -> dstFormat ) ) { FF_ALLOCZ_OR_GOTO ( c , c -> alpPixBuf , c -> vLumBufSize * 3 * sizeof ( int16_t * ) , fail ) ; } for ( i = 0 ; i < c -> vLumBufSize ; i ++ ) { FF_ALLOCZ_OR_GOTO ( c , c -> lumPixBuf [ i + c -> vLumBufSize ] , dst_stride + 16 , fail ) ; c -> lumPixBuf [ i ] = c -> lumPixBuf [ i + c -> vLumBufSize ] ; } c -> uv_off_px = dst_stride_px + 64 / ( c -> dstBpc & ~ 7 ) ; c -> uv_off_byte = dst_stride + 16 ; for ( i = 0 ; i < c -> vChrBufSize ; i ++ ) { FF_ALLOC_OR_GOTO ( c , c -> chrUPixBuf [ i + c -> vChrBufSize ] , dst_stride * 2 + 32 , fail ) ; c -> chrUPixBuf [ i ] = c -> chrUPixBuf [ i + c -> vChrBufSize ] ; c -> chrVPixBuf [ i ] = c -> chrVPixBuf [ i + c -> vChrBufSize ] = c -> chrUPixBuf [ i ] + ( dst_stride >> 1 ) + 8 ; } if ( CONFIG_SWSCALE_ALPHA && c -> alpPixBuf ) for ( i = 0 ; i < c -> vLumBufSize ; i ++ ) { FF_ALLOCZ_OR_GOTO ( c , c -> alpPixBuf [ i + c -> vLumBufSize ] , dst_stride + 16 , fail ) ; c -> alpPixBuf [ i ] = c -> alpPixBuf [ i + c -> vLumBufSize ] ; } for ( i = 0 ; i < c -> vChrBufSize ; i ++ ) { memset ( c -> chrUPixBuf [ i ] , 64 , dst_stride * 2 + 1 ) ; } assert ( c -> chrDstH <= dstH ) ; if ( flags & SWS_PRINT_INFO ) { if ( flags & SWS_FAST_BILINEAR ) { av_log ( c , AV_LOG_INFO , "FAST_BILINEAR scaler, " ) ; } else if ( flags & SWS_BILINEAR ) { av_log ( c , AV_LOG_INFO , "BILINEAR scaler, " ) ; } else if ( flags & SWS_BICUBIC ) { av_log ( c , AV_LOG_INFO , "BICUBIC scaler, " ) ; } else if ( flags & SWS_X ) { av_log ( c , AV_LOG_INFO , "Experimental scaler, " ) ; } else if ( flags & SWS_POINT ) { av_log ( c , AV_LOG_INFO , "Nearest Neighbor / POINT scaler, " ) ; } else if ( flags & SWS_AREA ) { av_log ( c , AV_LOG_INFO , "Area Averaging scaler, " ) ; } else if ( flags & SWS_BICUBLIN ) { av_log ( c , AV_LOG_INFO , "luma BICUBIC / chroma BILINEAR scaler, " ) ; } else if ( flags & SWS_GAUSS ) { av_log ( c , AV_LOG_INFO , "Gaussian scaler, " ) ; } else if ( flags & SWS_SINC ) { av_log ( c , AV_LOG_INFO , "Sinc scaler, " ) ; } else if ( flags & SWS_LANCZOS ) { av_log ( c , AV_LOG_INFO , "Lanczos scaler, " ) ; } else if ( flags & SWS_SPLINE ) { av_log ( c , AV_LOG_INFO , "Bicubic spline scaler, " ) ; } else { av_log ( c , AV_LOG_INFO , "ehh flags invalid?! " ) ; } av_log ( c , AV_LOG_INFO , "from %s to %s%s " , sws_format_name ( srcFormat ) , # ifdef DITHER1XBPP dstFormat == AV_PIX_FMT_BGR555 || dstFormat == AV_PIX_FMT_BGR565 || dstFormat == AV_PIX_FMT_RGB444BE || dstFormat == AV_PIX_FMT_RGB444LE || dstFormat == AV_PIX_FMT_BGR444BE || dstFormat == AV_PIX_FMT_BGR444LE ? "dithered " : "" , # else "" , # endif sws_format_name ( dstFormat ) ) ; if ( INLINE_MMXEXT ( cpu_flags ) ) { av_log ( c , AV_LOG_INFO , "using MMXEXT\n" ) ; } else if ( INLINE_AMD3DNOW ( cpu_flags ) ) { av_log ( c , AV_LOG_INFO , "using 3DNOW\n" ) ; } else if ( INLINE_MMX ( cpu_flags ) ) { av_log ( c , AV_LOG_INFO , "using MMX\n" ) ; } else if ( PPC_ALTIVEC ( cpu_flags ) ) { av_log ( c , AV_LOG_INFO , "using AltiVec\n" ) ; } else { av_log ( c , AV_LOG_INFO , "using C\n" ) ; } av_log ( c , AV_LOG_VERBOSE , "%dx%d -> %dx%d\n" , srcW , srcH , dstW , dstH ) ; av_log ( c , AV_LOG_DEBUG , "lum srcW=%d srcH=%d dstW=%d dstH=%d xInc=%d yInc=%d\n" , c -> srcW , c -> srcH , c -> dstW , c -> dstH , c -> lumXInc , c -> lumYInc ) ; av_log ( c , AV_LOG_DEBUG , "chr srcW=%d srcH=%d dstW=%d dstH=%d xInc=%d yInc=%d\n" , c -> chrSrcW , c -> chrSrcH , c -> chrDstW , c -> chrDstH , c -> chrXInc , c -> chrYInc ) ; } c -> swscale = ff_getSwsFunc ( c ) ; return 0 ; fail : return - 1 ; }##::##1##::##5523
static void gen_mulo ( DisasContext * ctx ) { int l1 = gen_new_label ( ) ; TCGv_i64 t0 = tcg_temp_new_i64 ( ) ; TCGv_i64 t1 = tcg_temp_new_i64 ( ) ; TCGv t2 = tcg_temp_new ( ) ; tcg_gen_movi_tl ( cpu_ov , 0 ) ; tcg_gen_extu_tl_i64 ( t0 , cpu_gpr [ rA ( ctx -> opcode ) ] ) ; tcg_gen_extu_tl_i64 ( t1 , cpu_gpr [ rB ( ctx -> opcode ) ] ) ; tcg_gen_mul_i64 ( t0 , t0 , t1 ) ; tcg_gen_trunc_i64_tl ( t2 , t0 ) ; gen_store_spr ( SPR_MQ , t2 ) ; tcg_gen_shri_i64 ( t1 , t0 , 32 ) ; tcg_gen_trunc_i64_tl ( cpu_gpr [ rD ( ctx -> opcode ) ] , t1 ) ; tcg_gen_ext32s_i64 ( t1 , t0 ) ; tcg_gen_brcond_i64 ( TCG_COND_EQ , t0 , t1 , l1 ) ; tcg_gen_movi_tl ( cpu_ov , 1 ) ; tcg_gen_movi_tl ( cpu_so , 1 ) ; gen_set_label ( l1 ) ; tcg_temp_free_i64 ( t0 ) ; tcg_temp_free_i64 ( t1 ) ; tcg_temp_free ( t2 ) ; if ( unlikely ( Rc ( ctx -> opcode ) != 0 ) ) { gen_set_Rc0 ( ctx , cpu_gpr [ rD ( ctx -> opcode ) ] ) ; } }##::##0##::##12258
static void qmp_monitor_complete ( void * opaque , QObject * ret_data ) { monitor_protocol_emitter ( opaque , ret_data ) ; }##::##1##::##10125
static int s337m_probe ( AVProbeData * p ) { uint64_t state = 0 ; int markers [ 3 ] = { 0 } ; int i , sum , max , data_type , data_size , offset ; uint8_t * buf ; for ( buf = p -> buf ; buf < p -> buf + p -> buf_size ; buf ++ ) { state = ( state << 8 ) | * buf ; if ( ! IS_LE_MARKER ( state ) ) { continue ; } if ( IS_16LE_MARKER ( state ) ) { data_type = AV_RL16 ( buf + 1 ) ; data_size = AV_RL16 ( buf + 3 ) ; buf += 4 ; } else { data_type = AV_RL24 ( buf + 1 ) ; data_size = AV_RL24 ( buf + 4 ) ; buf += 6 ; } if ( s337m_get_offset_and_codec ( NULL , state , data_type , data_size , & offset , NULL ) ) { continue ; } i = IS_16LE_MARKER ( state ) ? 0 : IS_20LE_MARKER ( state ) ? 1 : 2 ; markers [ i ] ++ ; buf += offset ; state = 0 ; } sum = max = 0 ; for ( i = 0 ; i < FF_ARRAY_ELEMS ( markers ) ; i ++ ) { sum += markers [ i ] ; if ( markers [ max ] < markers [ i ] ) { max = i ; } } if ( markers [ max ] > 3 && markers [ max ] * 4 > sum * 3 ) { return AVPROBE_SCORE_EXTENSION + 1 ; } return 0 ; }##::##0##::##8991
void helper_single_step ( CPUX86State * env ) { # ifndef CONFIG_USER_ONLY check_hw_breakpoints ( env , 1 ) ; env -> dr [ 6 ] |= DR6_BS ; # endif raise_exception ( env , EXCP01_DB ) ; }##::##1##::##8754
VLANState * qemu_find_vlan ( int id , int allocate ) { VLANState * * pvlan , * vlan ; for ( vlan = first_vlan ; vlan != NULL ; vlan = vlan -> next ) { if ( vlan -> id == id ) { return vlan ; } } if ( ! allocate ) { return NULL ; } vlan = qemu_mallocz ( sizeof ( VLANState ) ) ; vlan -> id = id ; TAILQ_INIT ( & vlan -> send_queue ) ; vlan -> next = NULL ; pvlan = & first_vlan ; while ( * pvlan != NULL ) { pvlan = & ( * pvlan ) -> next ; } * pvlan = vlan ; return vlan ; }##::##0##::##2969
static void bdrv_dirty_bitmap_truncate ( BlockDriverState * bs ) { BdrvDirtyBitmap * bitmap ; uint64_t size = bdrv_nb_sectors ( bs ) ; QLIST_FOREACH ( bitmap , & bs -> dirty_bitmaps , list ) { if ( bdrv_dirty_bitmap_frozen ( bitmap ) ) { continue ; } hbitmap_truncate ( bitmap -> bitmap , size ) ; bitmap -> size = size ; } }##::##0##::##7240
static void dma_aio_cancel ( BlockDriverAIOCB * acb ) { DMAAIOCB * dbs = container_of ( acb , DMAAIOCB , common ) ; if ( dbs -> acb ) { bdrv_aio_cancel ( dbs -> acb ) ; } }##::##1##::##6794
Aml * aml_shiftright ( Aml * arg1 , Aml * count ) { Aml * var = aml_opcode ( 0x7A ) ; aml_append ( var , arg1 ) ; aml_append ( var , count ) ; build_append_byte ( var -> buf , 0x00 ) ; return var ; }##::##0##::##1011
static void vnc_client_write_locked ( void * opaque ) { VncState * vs = opaque ; # ifdef CONFIG_VNC_SASL if ( vs -> sasl . conn && vs -> sasl . runSSF && ! vs -> sasl . waitWriteSSF ) { vnc_client_write_sasl ( vs ) ; } else # endif { # ifdef CONFIG_VNC_WS if ( vs -> encode_ws ) { vnc_client_write_ws ( vs ) ; } else # endif { vnc_client_write_plain ( vs ) ; } } }##::##0##::##13182
void qmp_blockdev_mirror ( const char * device , const char * target , bool has_replaces , const char * replaces , MirrorSyncMode sync , bool has_speed , int64_t speed , bool has_granularity , uint32_t granularity , bool has_buf_size , int64_t buf_size , bool has_on_source_error , BlockdevOnError on_source_error , bool has_on_target_error , BlockdevOnError on_target_error , Error * * errp ) { BlockDriverState * bs ; BlockBackend * blk ; BlockDriverState * target_bs ; AioContext * aio_context ; BlockMirrorBackingMode backing_mode = MIRROR_LEAVE_BACKING_CHAIN ; Error * local_err = NULL ; blk = blk_by_name ( device ) ; if ( ! blk ) { error_setg ( errp , "Device '%s' not found" , device ) ; return ; } bs = blk_bs ( blk ) ; if ( ! bs ) { error_setg ( errp , "Device '%s' has no media" , device ) ; return ; } target_bs = bdrv_lookup_bs ( target , target , errp ) ; if ( ! target_bs ) { return ; } aio_context = bdrv_get_aio_context ( bs ) ; aio_context_acquire ( aio_context ) ; bdrv_set_aio_context ( target_bs , aio_context ) ; blockdev_mirror_common ( bs , target_bs , has_replaces , replaces , sync , backing_mode , has_speed , speed , has_granularity , granularity , has_buf_size , buf_size , has_on_source_error , on_source_error , has_on_target_error , on_target_error , true , true , & local_err ) ; if ( local_err ) { error_propagate ( errp , local_err ) ; } aio_context_release ( aio_context ) ; }##::##0##::##4461
int ff_h264_execute_decode_slices ( H264Context * h , unsigned context_count ) { AVCodecContext * const avctx = h -> avctx ; H264SliceContext * sl ; int i ; av_assert0 ( context_count && h -> slice_ctx [ context_count - 1 ] . mb_y < h -> mb_height ) ; if ( h -> avctx -> hwaccel || h -> avctx -> codec -> capabilities & CODEC_CAP_HWACCEL_VDPAU ) { return 0 ; } if ( context_count == 1 ) { int ret = decode_slice ( avctx , & h -> slice_ctx [ 0 ] ) ; h -> mb_y = h -> slice_ctx [ 0 ] . mb_y ; return ret ; } else { av_assert0 ( context_count > 0 ) ; for ( i = 1 ; i < context_count ; i ++ ) { sl = & h -> slice_ctx [ i ] ; if ( CONFIG_ERROR_RESILIENCE ) { sl -> er . error_count = 0 ; } } avctx -> execute ( avctx , decode_slice , h -> slice_ctx , NULL , context_count , sizeof ( h -> slice_ctx [ 0 ] ) ) ; sl = & h -> slice_ctx [ context_count - 1 ] ; h -> mb_y = sl -> mb_y ; if ( CONFIG_ERROR_RESILIENCE ) { for ( i = 1 ; i < context_count ; i ++ ) { h -> slice_ctx [ 0 ] . er . error_count += h -> slice_ctx [ i ] . er . error_count ; } } } return 0 ; }##::##1##::##9153
QCryptoHmac * qcrypto_hmac_new ( QCryptoHashAlgorithm alg , const uint8_t * key , size_t nkey , Error * * errp ) { QCryptoHmac * hmac ; void * ctx = NULL ; Error * err2 = NULL ; QCryptoHmacDriver * drv = NULL ; # ifdef CONFIG_AF_ALG ctx = qcrypto_afalg_hmac_ctx_new ( alg , key , nkey , & err2 ) ; if ( ctx ) { drv = & qcrypto_hmac_afalg_driver ; } # endif if ( ! ctx ) { ctx = qcrypto_hmac_ctx_new ( alg , key , nkey , errp ) ; if ( ! ctx ) { return NULL ; } drv = & qcrypto_hmac_lib_driver ; error_free ( err2 ) ; } hmac = g_new0 ( QCryptoHmac , 1 ) ; hmac -> alg = alg ; hmac -> opaque = ctx ; hmac -> driver = ( void * ) drv ; return hmac ; }##::##1##::##2323
static int usb_serial_initfn ( USBDevice * dev ) { USBSerialState * s = DO_UPCAST ( USBSerialState , dev , dev ) ; s -> dev . speed = USB_SPEED_FULL ; if ( ! s -> cs ) { error_report ( "Property chardev is required" ) ; return - 1 ; } qemu_chr_add_handlers ( s -> cs , usb_serial_can_read , usb_serial_read , usb_serial_event , s ) ; usb_serial_handle_reset ( dev ) ; return 0 ; }##::##0##::##11363
static void mv88w8618_eth_write ( void * opaque , target_phys_addr_t offset , uint64_t value , unsigned size ) { mv88w8618_eth_state * s = opaque ; switch ( offset ) { case MP_ETH_SMIR : s -> smir = value ; break ; case MP_ETH_PCXR : s -> vlan_header = ( ( value >> MP_ETH_PCXR_2BSM_BIT ) & 1 ) * 2 ; break ; case MP_ETH_SDCMR : if ( value & MP_ETH_CMD_TXHI ) { eth_send ( s , 1 ) ; } if ( value & MP_ETH_CMD_TXLO ) { eth_send ( s , 0 ) ; } if ( value & ( MP_ETH_CMD_TXHI | MP_ETH_CMD_TXLO ) && s -> icr & s -> imr ) { qemu_irq_raise ( s -> irq ) ; } break ; case MP_ETH_ICR : s -> icr &= value ; break ; case MP_ETH_IMR : s -> imr = value ; if ( s -> icr & s -> imr ) { qemu_irq_raise ( s -> irq ) ; } break ; case MP_ETH_FRDP0 ... MP_ETH_FRDP3 : s -> frx_queue [ ( offset - MP_ETH_FRDP0 ) / 4 ] = value ; break ; case MP_ETH_CRDP0 ... MP_ETH_CRDP3 : s -> rx_queue [ ( offset - MP_ETH_CRDP0 ) / 4 ] = s -> cur_rx [ ( offset - MP_ETH_CRDP0 ) / 4 ] = value ; break ; case MP_ETH_CTDP0 ... MP_ETH_CTDP3 : s -> tx_queue [ ( offset - MP_ETH_CTDP0 ) / 4 ] = value ; break ; } }##::##0##::##4755
ssize_t v9fs_list_xattr ( FsContext * ctx , const char * path , void * value , size_t vsize ) { ssize_t size = 0 ; char buffer [ PATH_MAX ] ; void * ovalue = value ; XattrOperations * xops ; char * orig_value , * orig_value_start ; ssize_t xattr_len , parsed_len = 0 , attr_len ; xattr_len = llistxattr ( rpath ( ctx , path , buffer ) , value , 0 ) ; if ( xattr_len <= 0 ) { return xattr_len ; } orig_value = g_malloc ( xattr_len ) ; xattr_len = llistxattr ( rpath ( ctx , path , buffer ) , orig_value , xattr_len ) ; orig_value_start = orig_value ; while ( xattr_len > parsed_len ) { xops = get_xattr_operations ( ctx -> xops , orig_value ) ; if ( ! xops ) { goto next_entry ; } if ( ! value ) { size += xops -> listxattr ( ctx , path , orig_value , value , vsize ) ; } else { size = xops -> listxattr ( ctx , path , orig_value , value , vsize ) ; if ( size < 0 ) { goto err_out ; } value += size ; vsize -= size ; } next_entry : attr_len = strlen ( orig_value ) + 1 ; parsed_len += attr_len ; orig_value += attr_len ; } if ( value ) { size = value - ovalue ; } err_out : g_free ( orig_value_start ) ; return size ; }##::##0##::##9671
static int img_check ( int argc , char * * argv ) { int c , ret ; OutputFormat output_format = OFORMAT_HUMAN ; const char * filename , * fmt , * output , * cache ; BlockBackend * blk ; BlockDriverState * bs ; int fix = 0 ; int flags = BDRV_O_FLAGS | BDRV_O_CHECK ; ImageCheck * check ; bool quiet = false ; fmt = NULL ; output = NULL ; cache = BDRV_DEFAULT_CACHE ; for ( ; ; ) { int option_index = 0 ; static const struct option long_options [ ] = { { "help" , no_argument , 0 , 'h' } , { "format" , required_argument , 0 , 'f' } , { "repair" , required_argument , 0 , 'r' } , { "output" , required_argument , 0 , OPTION_OUTPUT } , { 0 , 0 , 0 , 0 } } ; c = getopt_long ( argc , argv , "hf:r:T:q" , long_options , & option_index ) ; if ( c == - 1 ) { break ; } switch ( c ) { case '?' : case 'h' : help ( ) ; break ; case 'f' : fmt = optarg ; break ; case 'r' : flags |= BDRV_O_RDWR ; if ( ! strcmp ( optarg , "leaks" ) ) { fix = BDRV_FIX_LEAKS ; } else if ( ! strcmp ( optarg , "all" ) ) { fix = BDRV_FIX_LEAKS | BDRV_FIX_ERRORS ; } else { error_exit ( "Unknown option value for -r " "(expecting 'leaks' or 'all'): %s" , optarg ) ; } break ; case OPTION_OUTPUT : output = optarg ; break ; case 'T' : cache = optarg ; break ; case 'q' : quiet = true ; break ; } } if ( optind != argc - 1 ) { error_exit ( "Expecting one image file name" ) ; } filename = argv [ optind ++ ] ; if ( output && ! strcmp ( output , "json" ) ) { output_format = OFORMAT_JSON ; } else if ( output && ! strcmp ( output , "human" ) ) { output_format = OFORMAT_HUMAN ; } else if ( output ) { error_report ( "--output must be used with human or json as argument." ) ; return 1 ; } ret = bdrv_parse_cache_flags ( cache , & flags ) ; if ( ret < 0 ) { error_report ( "Invalid source cache option: %s" , cache ) ; return 1 ; } blk = img_open ( "image" , filename , fmt , flags , true , quiet ) ; if ( ! blk ) { return 1 ; } bs = blk_bs ( blk ) ; check = g_new0 ( ImageCheck , 1 ) ; ret = collect_image_check ( bs , check , filename , fmt , fix ) ; if ( ret == - ENOTSUP ) { error_report ( "This image format does not support checks" ) ; ret = 63 ; goto fail ; } if ( check -> corruptions_fixed || check -> leaks_fixed ) { int corruptions_fixed , leaks_fixed ; leaks_fixed = check -> leaks_fixed ; corruptions_fixed = check -> corruptions_fixed ; if ( output_format == OFORMAT_HUMAN ) { qprintf ( quiet , "The following inconsistencies were found and repaired:\n\n" "    %" PRId64 " leaked clusters\n" "    %" PRId64 " corruptions\n\n" "Double checking the fixed image now...\n" , check -> leaks_fixed , check -> corruptions_fixed ) ; } ret = collect_image_check ( bs , check , filename , fmt , 0 ) ; check -> leaks_fixed = leaks_fixed ; check -> corruptions_fixed = corruptions_fixed ; } switch ( output_format ) { case OFORMAT_HUMAN : dump_human_image_check ( check , quiet ) ; break ; case OFORMAT_JSON : dump_json_image_check ( check , quiet ) ; break ; } if ( ret || check -> check_errors ) { ret = 1 ; goto fail ; } if ( check -> corruptions ) { ret = 2 ; } else if ( check -> leaks ) { ret = 3 ; } else { ret = 0 ; } fail : qapi_free_ImageCheck ( check ) ; blk_unref ( blk ) ; return ret ; }##::##1##::##1348
static int64_t mpegts_get_pcr ( AVFormatContext * s , int stream_index , int64_t * ppos , int64_t pos_limit ) { MpegTSContext * ts = s -> priv_data ; int64_t pos , timestamp ; uint8_t buf [ TS_PACKET_SIZE ] ; int pcr_l , pcr_pid = ( ( PESContext * ) s -> streams [ stream_index ] -> priv_data ) -> pcr_pid ; pos = ( ( * ppos + ts -> raw_packet_size - 1 - ts -> pos47 ) / ts -> raw_packet_size ) * ts -> raw_packet_size + ts -> pos47 ; while ( pos < pos_limit ) { avio_seek ( s -> pb , pos , SEEK_SET ) ; if ( avio_read ( s -> pb , buf , TS_PACKET_SIZE ) != TS_PACKET_SIZE ) { return AV_NOPTS_VALUE ; } if ( ( pcr_pid < 0 || ( AV_RB16 ( buf + 1 ) & 0x1fff ) == pcr_pid ) && parse_pcr ( & timestamp , & pcr_l , buf ) == 0 ) { * ppos = pos ; return timestamp ; } pos += ts -> raw_packet_size ; } return AV_NOPTS_VALUE ; }##::##0##::##13499
static bool msix_is_masked ( PCIDevice * dev , int vector ) { return msix_vector_masked ( dev , vector , dev -> msix_function_masked ) ; }##::##0##::##11094
static void input_visitor_test_add ( const char * testpath , TestInputVisitorData * data , void ( * test_func ) ( TestInputVisitorData * data , const void * user_data ) ) { g_test_add ( testpath , TestInputVisitorData , data , NULL , test_func , visitor_input_teardown ) ; }##::##0##::##11661
static int jpeg2000_decode_packets_po_iteration ( Jpeg2000DecoderContext * s , Jpeg2000Tile * tile , int RSpoc , int CSpoc , int LYEpoc , int REpoc , int CEpoc , int Ppoc ) { int ret = 0 ; int layno , reslevelno , compno , precno , ok_reslevel ; int x , y ; int tp_index = 0 ; int step_x , step_y ; switch ( Ppoc ) { case JPEG2000_PGOD_RLCP : av_log ( s -> avctx , AV_LOG_DEBUG , "Progression order RLCP\n" ) ; ok_reslevel = 1 ; for ( reslevelno = RSpoc ; ok_reslevel && reslevelno < REpoc ; reslevelno ++ ) { ok_reslevel = 0 ; for ( layno = 0 ; layno < LYEpoc ; layno ++ ) { for ( compno = CSpoc ; compno < CEpoc ; compno ++ ) { Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; Jpeg2000QuantStyle * qntsty = tile -> qntsty + compno ; if ( reslevelno < codsty -> nreslevels ) { Jpeg2000ResLevel * rlevel = tile -> comp [ compno ] . reslevel + reslevelno ; ok_reslevel = 1 ; for ( precno = 0 ; precno < rlevel -> num_precincts_x * rlevel -> num_precincts_y ; precno ++ ) if ( ( ret = jpeg2000_decode_packet ( s , tile , & tp_index , codsty , rlevel , precno , layno , qntsty -> expn + ( reslevelno ? 3 * ( reslevelno - 1 ) + 1 : 0 ) , qntsty -> nguardbits ) ) < 0 ) { return ret ; } } } } } break ; case JPEG2000_PGOD_LRCP : av_log ( s -> avctx , AV_LOG_DEBUG , "Progression order LRCP\n" ) ; for ( layno = 0 ; layno < LYEpoc ; layno ++ ) { ok_reslevel = 1 ; for ( reslevelno = RSpoc ; ok_reslevel && reslevelno < REpoc ; reslevelno ++ ) { ok_reslevel = 0 ; for ( compno = CSpoc ; compno < CEpoc ; compno ++ ) { Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; Jpeg2000QuantStyle * qntsty = tile -> qntsty + compno ; if ( reslevelno < codsty -> nreslevels ) { Jpeg2000ResLevel * rlevel = tile -> comp [ compno ] . reslevel + reslevelno ; ok_reslevel = 1 ; for ( precno = 0 ; precno < rlevel -> num_precincts_x * rlevel -> num_precincts_y ; precno ++ ) if ( ( ret = jpeg2000_decode_packet ( s , tile , & tp_index , codsty , rlevel , precno , layno , qntsty -> expn + ( reslevelno ? 3 * ( reslevelno - 1 ) + 1 : 0 ) , qntsty -> nguardbits ) ) < 0 ) { return ret ; } } } } } break ; case JPEG2000_PGOD_CPRL : av_log ( s -> avctx , AV_LOG_DEBUG , "Progression order CPRL\n" ) ; for ( compno = CSpoc ; compno < CEpoc ; compno ++ ) { Jpeg2000Component * comp = tile -> comp + compno ; Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; Jpeg2000QuantStyle * qntsty = tile -> qntsty + compno ; step_x = 32 ; step_y = 32 ; for ( reslevelno = RSpoc ; reslevelno < FFMIN ( codsty -> nreslevels , REpoc ) ; reslevelno ++ ) { uint8_t reducedresno = codsty -> nreslevels - 1 - reslevelno ; Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; step_x = FFMIN ( step_x , rlevel -> log2_prec_width + reducedresno ) ; step_y = FFMIN ( step_y , rlevel -> log2_prec_height + reducedresno ) ; } step_x = 1 << step_x ; step_y = 1 << step_y ; for ( y = tile -> coord [ 1 ] [ 0 ] ; y < tile -> coord [ 1 ] [ 1 ] ; y = ( y / step_y + 1 ) * step_y ) { for ( x = tile -> coord [ 0 ] [ 0 ] ; x < tile -> coord [ 0 ] [ 1 ] ; x = ( x / step_x + 1 ) * step_x ) { for ( reslevelno = RSpoc ; reslevelno < FFMIN ( codsty -> nreslevels , REpoc ) ; reslevelno ++ ) { unsigned prcx , prcy ; uint8_t reducedresno = codsty -> nreslevels - 1 - reslevelno ; Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; int xc = x / s -> cdx [ compno ] ; int yc = y / s -> cdy [ compno ] ; if ( yc % ( 1 << ( rlevel -> log2_prec_height + reducedresno ) ) && y != tile -> coord [ 1 ] [ 0 ] ) { continue ; } if ( xc % ( 1 << ( rlevel -> log2_prec_width + reducedresno ) ) && x != tile -> coord [ 0 ] [ 0 ] ) { continue ; } prcx = ff_jpeg2000_ceildivpow2 ( xc , reducedresno ) >> rlevel -> log2_prec_width ; prcy = ff_jpeg2000_ceildivpow2 ( yc , reducedresno ) >> rlevel -> log2_prec_height ; prcx -= ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ 0 ] [ 0 ] , reducedresno ) >> rlevel -> log2_prec_width ; prcy -= ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ 1 ] [ 0 ] , reducedresno ) >> rlevel -> log2_prec_height ; precno = prcx + rlevel -> num_precincts_x * prcy ; if ( prcx >= rlevel -> num_precincts_x || prcy >= rlevel -> num_precincts_y ) { av_log ( s -> avctx , AV_LOG_WARNING , "prc %d %d outside limits %d %d\n" , prcx , prcy , rlevel -> num_precincts_x , rlevel -> num_precincts_y ) ; continue ; } for ( layno = 0 ; layno < LYEpoc ; layno ++ ) { if ( ( ret = jpeg2000_decode_packet ( s , tile , & tp_index , codsty , rlevel , precno , layno , qntsty -> expn + ( reslevelno ? 3 * ( reslevelno - 1 ) + 1 : 0 ) , qntsty -> nguardbits ) ) < 0 ) { return ret ; } } } } } } break ; case JPEG2000_PGOD_RPCL : av_log ( s -> avctx , AV_LOG_WARNING , "Progression order RPCL\n" ) ; ok_reslevel = 1 ; for ( reslevelno = RSpoc ; ok_reslevel && reslevelno < REpoc ; reslevelno ++ ) { ok_reslevel = 0 ; step_x = 30 ; step_y = 30 ; for ( compno = CSpoc ; compno < CEpoc ; compno ++ ) { Jpeg2000Component * comp = tile -> comp + compno ; Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; if ( reslevelno < codsty -> nreslevels ) { uint8_t reducedresno = codsty -> nreslevels - 1 - reslevelno ; Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; step_x = FFMIN ( step_x , rlevel -> log2_prec_width + reducedresno ) ; step_y = FFMIN ( step_y , rlevel -> log2_prec_height + reducedresno ) ; } } step_x = 1 << step_x ; step_y = 1 << step_y ; for ( y = tile -> coord [ 1 ] [ 0 ] ; y < tile -> coord [ 1 ] [ 1 ] ; y = ( y / step_y + 1 ) * step_y ) { for ( x = tile -> coord [ 0 ] [ 0 ] ; x < tile -> coord [ 0 ] [ 1 ] ; x = ( x / step_x + 1 ) * step_x ) { for ( compno = CSpoc ; compno < CEpoc ; compno ++ ) { Jpeg2000Component * comp = tile -> comp + compno ; Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; Jpeg2000QuantStyle * qntsty = tile -> qntsty + compno ; uint8_t reducedresno = codsty -> nreslevels - 1 - reslevelno ; Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; unsigned prcx , prcy ; int xc = x / s -> cdx [ compno ] ; int yc = y / s -> cdy [ compno ] ; if ( reslevelno >= codsty -> nreslevels ) { continue ; } if ( yc % ( 1 << ( rlevel -> log2_prec_height + reducedresno ) ) && y != tile -> coord [ 1 ] [ 0 ] ) { continue ; } if ( xc % ( 1 << ( rlevel -> log2_prec_width + reducedresno ) ) && x != tile -> coord [ 0 ] [ 0 ] ) { continue ; } prcx = ff_jpeg2000_ceildivpow2 ( xc , reducedresno ) >> rlevel -> log2_prec_width ; prcy = ff_jpeg2000_ceildivpow2 ( yc , reducedresno ) >> rlevel -> log2_prec_height ; prcx -= ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ 0 ] [ 0 ] , reducedresno ) >> rlevel -> log2_prec_width ; prcy -= ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ 1 ] [ 0 ] , reducedresno ) >> rlevel -> log2_prec_height ; precno = prcx + rlevel -> num_precincts_x * prcy ; ok_reslevel = 1 ; if ( prcx >= rlevel -> num_precincts_x || prcy >= rlevel -> num_precincts_y ) { av_log ( s -> avctx , AV_LOG_WARNING , "prc %d %d outside limits %d %d\n" , prcx , prcy , rlevel -> num_precincts_x , rlevel -> num_precincts_y ) ; continue ; } for ( layno = 0 ; layno < LYEpoc ; layno ++ ) { if ( ( ret = jpeg2000_decode_packet ( s , tile , & tp_index , codsty , rlevel , precno , layno , qntsty -> expn + ( reslevelno ? 3 * ( reslevelno - 1 ) + 1 : 0 ) , qntsty -> nguardbits ) ) < 0 ) { return ret ; } } } } } } break ; case JPEG2000_PGOD_PCRL : av_log ( s -> avctx , AV_LOG_WARNING , "Progression order PCRL\n" ) ; step_x = 32 ; step_y = 32 ; for ( compno = CSpoc ; compno < CEpoc ; compno ++ ) { Jpeg2000Component * comp = tile -> comp + compno ; Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; Jpeg2000QuantStyle * qntsty = tile -> qntsty + compno ; for ( reslevelno = RSpoc ; reslevelno < FFMIN ( codsty -> nreslevels , REpoc ) ; reslevelno ++ ) { uint8_t reducedresno = codsty -> nreslevels - 1 - reslevelno ; Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; step_x = FFMIN ( step_x , rlevel -> log2_prec_width + reducedresno ) ; step_y = FFMIN ( step_y , rlevel -> log2_prec_height + reducedresno ) ; } } step_x = 1 << step_x ; step_y = 1 << step_y ; for ( y = tile -> coord [ 1 ] [ 0 ] ; y < tile -> coord [ 1 ] [ 1 ] ; y = ( y / step_y + 1 ) * step_y ) { for ( x = tile -> coord [ 0 ] [ 0 ] ; x < tile -> coord [ 0 ] [ 1 ] ; x = ( x / step_x + 1 ) * step_x ) { for ( compno = CSpoc ; compno < CEpoc ; compno ++ ) { Jpeg2000Component * comp = tile -> comp + compno ; Jpeg2000CodingStyle * codsty = tile -> codsty + compno ; Jpeg2000QuantStyle * qntsty = tile -> qntsty + compno ; int xc = x / s -> cdx [ compno ] ; int yc = y / s -> cdy [ compno ] ; for ( reslevelno = RSpoc ; reslevelno < FFMIN ( codsty -> nreslevels , REpoc ) ; reslevelno ++ ) { unsigned prcx , prcy ; uint8_t reducedresno = codsty -> nreslevels - 1 - reslevelno ; Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ; if ( yc % ( 1 << ( rlevel -> log2_prec_height + reducedresno ) ) && y != tile -> coord [ 1 ] [ 0 ] ) { continue ; } if ( xc % ( 1 << ( rlevel -> log2_prec_width + reducedresno ) ) && x != tile -> coord [ 0 ] [ 0 ] ) { continue ; } prcx = ff_jpeg2000_ceildivpow2 ( xc , reducedresno ) >> rlevel -> log2_prec_width ; prcy = ff_jpeg2000_ceildivpow2 ( yc , reducedresno ) >> rlevel -> log2_prec_height ; prcx -= ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ 0 ] [ 0 ] , reducedresno ) >> rlevel -> log2_prec_width ; prcy -= ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ 1 ] [ 0 ] , reducedresno ) >> rlevel -> log2_prec_height ; precno = prcx + rlevel -> num_precincts_x * prcy ; if ( prcx >= rlevel -> num_precincts_x || prcy >= rlevel -> num_precincts_y ) { av_log ( s -> avctx , AV_LOG_WARNING , "prc %d %d outside limits %d %d\n" , prcx , prcy , rlevel -> num_precincts_x , rlevel -> num_precincts_y ) ; continue ; } for ( layno = 0 ; layno < LYEpoc ; layno ++ ) { if ( ( ret = jpeg2000_decode_packet ( s , tile , & tp_index , codsty , rlevel , precno , layno , qntsty -> expn + ( reslevelno ? 3 * ( reslevelno - 1 ) + 1 : 0 ) , qntsty -> nguardbits ) ) < 0 ) { return ret ; } } } } } } break ; default : break ; } return ret ; }##::##0##::##8584
int MPV_encode_init ( AVCodecContext * avctx ) { MpegEncContext * s = avctx -> priv_data ; int i , dummy ; int chroma_h_shift , chroma_v_shift ; avctx -> pix_fmt = PIX_FMT_YUV420P ; s -> bit_rate = avctx -> bit_rate ; s -> width = avctx -> width ; s -> height = avctx -> height ; if ( avctx -> gop_size > 600 ) { av_log ( avctx , AV_LOG_ERROR , "Warning keyframe interval too large! reducing it ...\n" ) ; avctx -> gop_size = 600 ; } s -> gop_size = avctx -> gop_size ; s -> avctx = avctx ; s -> flags = avctx -> flags ; s -> flags2 = avctx -> flags2 ; s -> max_b_frames = avctx -> max_b_frames ; s -> codec_id = avctx -> codec -> id ; s -> luma_elim_threshold = avctx -> luma_elim_threshold ; s -> chroma_elim_threshold = avctx -> chroma_elim_threshold ; s -> strict_std_compliance = avctx -> strict_std_compliance ; s -> data_partitioning = avctx -> flags & CODEC_FLAG_PART ; s -> quarter_sample = ( avctx -> flags & CODEC_FLAG_QPEL ) != 0 ; s -> mpeg_quant = avctx -> mpeg_quant ; s -> rtp_mode = ! ! avctx -> rtp_payload_size ; if ( s -> gop_size <= 1 ) { s -> intra_only = 1 ; s -> gop_size = 12 ; } else { s -> intra_only = 0 ; } s -> me_method = avctx -> me_method ; s -> fixed_qscale = ! ! ( avctx -> flags & CODEC_FLAG_QSCALE ) ; s -> adaptive_quant = ( s -> avctx -> lumi_masking || s -> avctx -> dark_masking || s -> avctx -> temporal_cplx_masking || s -> avctx -> spatial_cplx_masking || s -> avctx -> p_masking || ( s -> flags & CODEC_FLAG_QP_RD ) ) && ! s -> fixed_qscale ; s -> obmc = ! ! ( s -> flags & CODEC_FLAG_OBMC ) ; s -> loop_filter = ! ! ( s -> flags & CODEC_FLAG_LOOP_FILTER ) ; s -> alternate_scan = ! ! ( s -> flags & CODEC_FLAG_ALT_SCAN ) ; if ( avctx -> rc_max_rate && ! avctx -> rc_buffer_size ) { av_log ( avctx , AV_LOG_ERROR , "a vbv buffer size is needed, for encoding with a maximum bitrate\n" ) ; return - 1 ; } if ( avctx -> rc_min_rate && avctx -> rc_max_rate != avctx -> rc_min_rate ) { av_log ( avctx , AV_LOG_INFO , "Warning min_rate > 0 but min_rate != max_rate isnt recommanded!\n" ) ; } if ( ( s -> flags & CODEC_FLAG_4MV ) && s -> codec_id != CODEC_ID_MPEG4 && s -> codec_id != CODEC_ID_H263 && s -> codec_id != CODEC_ID_H263P ) { av_log ( avctx , AV_LOG_ERROR , "4MV not supported by codec\n" ) ; return - 1 ; } if ( s -> obmc && s -> avctx -> mb_decision != FF_MB_DECISION_SIMPLE ) { av_log ( avctx , AV_LOG_ERROR , "OBMC is only supported with simple mb decission\n" ) ; return - 1 ; } if ( s -> obmc && s -> codec_id != CODEC_ID_H263 && s -> codec_id != CODEC_ID_H263P ) { av_log ( avctx , AV_LOG_ERROR , "OBMC is only supported with H263(+)\n" ) ; return - 1 ; } if ( s -> quarter_sample && s -> codec_id != CODEC_ID_MPEG4 ) { av_log ( avctx , AV_LOG_ERROR , "qpel not supported by codec\n" ) ; return - 1 ; } if ( s -> data_partitioning && s -> codec_id != CODEC_ID_MPEG4 ) { av_log ( avctx , AV_LOG_ERROR , "data partitioning not supported by codec\n" ) ; return - 1 ; } if ( s -> max_b_frames && s -> codec_id != CODEC_ID_MPEG4 && s -> codec_id != CODEC_ID_MPEG1VIDEO && s -> codec_id != CODEC_ID_MPEG2VIDEO ) { av_log ( avctx , AV_LOG_ERROR , "b frames not supported by codec\n" ) ; return - 1 ; } if ( s -> mpeg_quant && s -> codec_id != CODEC_ID_MPEG4 ) { av_log ( avctx , AV_LOG_ERROR , "mpeg2 style quantization not supporetd by codec\n" ) ; return - 1 ; } if ( ( s -> flags & CODEC_FLAG_CBP_RD ) && ! ( s -> flags & CODEC_FLAG_TRELLIS_QUANT ) ) { av_log ( avctx , AV_LOG_ERROR , "CBP RD needs trellis quant\n" ) ; return - 1 ; } if ( ( s -> flags & CODEC_FLAG_QP_RD ) && s -> avctx -> mb_decision != FF_MB_DECISION_RD ) { av_log ( avctx , AV_LOG_ERROR , "QP RD needs mbd=2\n" ) ; return - 1 ; } if ( s -> avctx -> scenechange_threshold < 1000000000 && ( s -> flags & CODEC_FLAG_CLOSED_GOP ) ) { av_log ( avctx , AV_LOG_ERROR , "closed gop with scene change detection arent supported yet\n" ) ; return - 1 ; } i = ff_gcd ( avctx -> frame_rate , avctx -> frame_rate_base ) ; if ( i > 1 ) { av_log ( avctx , AV_LOG_INFO , "removing common factors from framerate\n" ) ; avctx -> frame_rate /= i ; avctx -> frame_rate_base /= i ; } if ( s -> codec_id == CODEC_ID_MJPEG ) { s -> intra_quant_bias = 1 << ( QUANT_BIAS_SHIFT - 1 ) ; s -> inter_quant_bias = 0 ; } else if ( s -> mpeg_quant || s -> codec_id == CODEC_ID_MPEG1VIDEO || s -> codec_id == CODEC_ID_MPEG2VIDEO ) { s -> intra_quant_bias = 3 << ( QUANT_BIAS_SHIFT - 3 ) ; s -> inter_quant_bias = 0 ; } else { s -> intra_quant_bias = 0 ; s -> inter_quant_bias = - ( 1 << ( QUANT_BIAS_SHIFT - 2 ) ) ; } if ( avctx -> intra_quant_bias != FF_DEFAULT_QUANT_BIAS ) { s -> intra_quant_bias = avctx -> intra_quant_bias ; } if ( avctx -> inter_quant_bias != FF_DEFAULT_QUANT_BIAS ) { s -> inter_quant_bias = avctx -> inter_quant_bias ; } avcodec_get_chroma_sub_sample ( avctx -> pix_fmt , & chroma_h_shift , & chroma_v_shift ) ; av_reduce ( & s -> time_increment_resolution , & dummy , s -> avctx -> frame_rate , s -> avctx -> frame_rate_base , ( 1 << 16 ) - 1 ) ; s -> time_increment_bits = av_log2 ( s -> time_increment_resolution - 1 ) + 1 ; switch ( avctx -> codec -> id ) { case CODEC_ID_MPEG1VIDEO : s -> out_format = FMT_MPEG1 ; s -> low_delay = 0 ; avctx -> delay = s -> low_delay ? 0 : ( s -> max_b_frames + 1 ) ; break ; case CODEC_ID_MPEG2VIDEO : s -> out_format = FMT_MPEG1 ; s -> low_delay = 0 ; avctx -> delay = s -> low_delay ? 0 : ( s -> max_b_frames + 1 ) ; s -> rtp_mode = 1 ; break ; case CODEC_ID_LJPEG : case CODEC_ID_MJPEG : s -> out_format = FMT_MJPEG ; s -> intra_only = 1 ; s -> mjpeg_write_tables = 1 ; s -> mjpeg_data_only_frames = 0 ; s -> mjpeg_vsample [ 0 ] = 1 << chroma_v_shift ; s -> mjpeg_vsample [ 1 ] = 1 ; s -> mjpeg_vsample [ 2 ] = 1 ; s -> mjpeg_hsample [ 0 ] = 1 << chroma_h_shift ; s -> mjpeg_hsample [ 1 ] = 1 ; s -> mjpeg_hsample [ 2 ] = 1 ; if ( mjpeg_init ( s ) < 0 ) { return - 1 ; } avctx -> delay = 0 ; s -> low_delay = 1 ; break ; # ifdef CONFIG_RISKY case CODEC_ID_H263 : if ( h263_get_picture_format ( s -> width , s -> height ) == 7 ) { av_log ( avctx , AV_LOG_INFO , "Input picture size isn't suitable for h263 codec! try h263+\n" ) ; return - 1 ; } s -> out_format = FMT_H263 ; s -> obmc = ( avctx -> flags & CODEC_FLAG_OBMC ) ? 1 : 0 ; avctx -> delay = 0 ; s -> low_delay = 1 ; break ; case CODEC_ID_H263P : s -> out_format = FMT_H263 ; s -> h263_plus = 1 ; s -> umvplus = ( avctx -> flags & CODEC_FLAG_H263P_UMV ) ? 1 : 0 ; s -> h263_aic = ( avctx -> flags & CODEC_FLAG_H263P_AIC ) ? 1 : 0 ; s -> modified_quant = s -> h263_aic ; s -> alt_inter_vlc = ( avctx -> flags & CODEC_FLAG_H263P_AIV ) ? 1 : 0 ; s -> obmc = ( avctx -> flags & CODEC_FLAG_OBMC ) ? 1 : 0 ; s -> loop_filter = ( avctx -> flags & CODEC_FLAG_LOOP_FILTER ) ? 1 : 0 ; s -> unrestricted_mv = s -> obmc || s -> loop_filter || s -> umvplus ; s -> h263_slice_structured = ( s -> flags & CODEC_FLAG_H263P_SLICE_STRUCT ) ? 1 : 0 ; avctx -> delay = 0 ; s -> low_delay = 1 ; break ; case CODEC_ID_FLV1 : s -> out_format = FMT_H263 ; s -> h263_flv = 2 ; s -> unrestricted_mv = 1 ; s -> rtp_mode = 0 ; avctx -> delay = 0 ; s -> low_delay = 1 ; break ; case CODEC_ID_RV10 : s -> out_format = FMT_H263 ; avctx -> delay = 0 ; s -> low_delay = 1 ; break ; case CODEC_ID_MPEG4 : s -> out_format = FMT_H263 ; s -> h263_pred = 1 ; s -> unrestricted_mv = 1 ; s -> low_delay = s -> max_b_frames ? 0 : 1 ; avctx -> delay = s -> low_delay ? 0 : ( s -> max_b_frames + 1 ) ; break ; case CODEC_ID_MSMPEG4V1 : s -> out_format = FMT_H263 ; s -> h263_msmpeg4 = 1 ; s -> h263_pred = 1 ; s -> unrestricted_mv = 1 ; s -> msmpeg4_version = 1 ; avctx -> delay = 0 ; s -> low_delay = 1 ; break ; case CODEC_ID_MSMPEG4V2 : s -> out_format = FMT_H263 ; s -> h263_msmpeg4 = 1 ; s -> h263_pred = 1 ; s -> unrestricted_mv = 1 ; s -> msmpeg4_version = 2 ; avctx -> delay = 0 ; s -> low_delay = 1 ; break ; case CODEC_ID_MSMPEG4V3 : s -> out_format = FMT_H263 ; s -> h263_msmpeg4 = 1 ; s -> h263_pred = 1 ; s -> unrestricted_mv = 1 ; s -> msmpeg4_version = 3 ; s -> flipflop_rounding = 1 ; avctx -> delay = 0 ; s -> low_delay = 1 ; break ; case CODEC_ID_WMV1 : s -> out_format = FMT_H263 ; s -> h263_msmpeg4 = 1 ; s -> h263_pred = 1 ; s -> unrestricted_mv = 1 ; s -> msmpeg4_version = 4 ; s -> flipflop_rounding = 1 ; avctx -> delay = 0 ; s -> low_delay = 1 ; break ; case CODEC_ID_WMV2 : s -> out_format = FMT_H263 ; s -> h263_msmpeg4 = 1 ; s -> h263_pred = 1 ; s -> unrestricted_mv = 1 ; s -> msmpeg4_version = 5 ; s -> flipflop_rounding = 1 ; avctx -> delay = 0 ; s -> low_delay = 1 ; break ; # endif default : return - 1 ; } { static int done = 0 ; if ( ! done ) { int i ; done = 1 ; default_mv_penalty = av_mallocz ( sizeof ( uint8_t ) * ( MAX_FCODE + 1 ) * ( 2 * MAX_MV + 1 ) ) ; memset ( default_mv_penalty , 0 , sizeof ( uint8_t ) * ( MAX_FCODE + 1 ) * ( 2 * MAX_MV + 1 ) ) ; memset ( default_fcode_tab , 0 , sizeof ( uint8_t ) * ( 2 * MAX_MV + 1 ) ) ; for ( i = - 16 ; i < 16 ; i ++ ) { default_fcode_tab [ i + MAX_MV ] = 1 ; } } } s -> me . mv_penalty = default_mv_penalty ; s -> fcode_tab = default_fcode_tab ; if ( s -> me_method < ME_EPZS ) { s -> me . mv_penalty = default_mv_penalty ; } s -> encoding = 1 ; if ( MPV_common_init ( s ) < 0 ) { return - 1 ; } if ( s -> modified_quant ) { s -> chroma_qscale_table = ff_h263_chroma_qscale_table ; } s -> progressive_frame = s -> progressive_sequence = ! ( avctx -> flags & ( CODEC_FLAG_INTERLACED_DCT | CODEC_FLAG_INTERLACED_ME ) ) ; ff_set_cmp ( & s -> dsp , s -> dsp . ildct_cmp , s -> avctx -> ildct_cmp ) ; ff_init_me ( s ) ; # ifdef CONFIG_ENCODERS # ifdef CONFIG_RISKY if ( s -> out_format == FMT_H263 ) { h263_encode_init ( s ) ; } if ( s -> msmpeg4_version ) { ff_msmpeg4_encode_init ( s ) ; } # endif if ( s -> out_format == FMT_MPEG1 ) { ff_mpeg1_encode_init ( s ) ; } # endif for ( i = 0 ; i < 64 ; i ++ ) { int j = s -> dsp . idct_permutation [ i ] ; # ifdef CONFIG_RISKY if ( s -> codec_id == CODEC_ID_MPEG4 && s -> mpeg_quant ) { s -> intra_matrix [ j ] = ff_mpeg4_default_intra_matrix [ i ] ; s -> inter_matrix [ j ] = ff_mpeg4_default_non_intra_matrix [ i ] ; } else if ( s -> out_format == FMT_H263 ) { s -> intra_matrix [ j ] = s -> inter_matrix [ j ] = ff_mpeg1_default_non_intra_matrix [ i ] ; } else # endif { s -> intra_matrix [ j ] = ff_mpeg1_default_intra_matrix [ i ] ; s -> inter_matrix [ j ] = ff_mpeg1_default_non_intra_matrix [ i ] ; } if ( s -> avctx -> intra_matrix ) { s -> intra_matrix [ j ] = s -> avctx -> intra_matrix [ i ] ; } if ( s -> avctx -> inter_matrix ) { s -> inter_matrix [ j ] = s -> avctx -> inter_matrix [ i ] ; } } if ( s -> out_format != FMT_MJPEG ) { convert_matrix ( & s -> dsp , s -> q_intra_matrix , s -> q_intra_matrix16 , s -> intra_matrix , s -> intra_quant_bias , 1 , 31 ) ; convert_matrix ( & s -> dsp , s -> q_inter_matrix , s -> q_inter_matrix16 , s -> inter_matrix , s -> inter_quant_bias , 1 , 31 ) ; } if ( ff_rate_control_init ( s ) < 0 ) { return - 1 ; } s -> picture_number = 0 ; s -> input_picture_number = 0 ; s -> picture_in_gop_number = 0 ; s -> f_code = 1 ; s -> b_code = 1 ; return 0 ; }##::##1##::##8432
static void hybrid4_8_12_cx ( float ( * in ) [ 2 ] , float ( * out ) [ 32 ] [ 2 ] , const float ( * filter ) [ 7 ] [ 2 ] , int N , int len ) { int i , j , ssb ; for ( i = 0 ; i < len ; i ++ , in ++ ) { for ( ssb = 0 ; ssb < N ; ssb ++ ) { float sum_re = filter [ ssb ] [ 6 ] [ 0 ] * in [ 6 ] [ 0 ] , sum_im = filter [ ssb ] [ 6 ] [ 0 ] * in [ 6 ] [ 1 ] ; for ( j = 0 ; j < 6 ; j ++ ) { float in0_re = in [ j ] [ 0 ] ; float in0_im = in [ j ] [ 1 ] ; float in1_re = in [ 12 - j ] [ 0 ] ; float in1_im = in [ 12 - j ] [ 1 ] ; sum_re += filter [ ssb ] [ j ] [ 0 ] * ( in0_re + in1_re ) - filter [ ssb ] [ j ] [ 1 ] * ( in0_im - in1_im ) ; sum_im += filter [ ssb ] [ j ] [ 0 ] * ( in0_im + in1_im ) + filter [ ssb ] [ j ] [ 1 ] * ( in0_re - in1_re ) ; } out [ ssb ] [ i ] [ 0 ] = sum_re ; out [ ssb ] [ i ] [ 1 ] = sum_im ; } } }##::##0##::##5831
static inline void rgtc_block_internal ( uint8_t * dst , ptrdiff_t stride , const uint8_t * block , const int * color_tab ) { uint8_t indices [ 16 ] ; int x , y ; decompress_indices ( indices , block + 2 ) ; for ( y = 0 ; y < 4 ; y ++ ) { for ( x = 0 ; x < 4 ; x ++ ) { int i = indices [ x + y * 4 ] ; int c = color_tab [ i ] ; uint32_t pixel = RGBA ( c , c , c , 255 ) ; AV_WL32 ( dst + x * 4 + y * stride , pixel ) ; } } }##::##1##::##177
QBool * qbool_from_bool ( bool value ) { QBool * qb ; qb = g_malloc ( sizeof ( * qb ) ) ; qb -> value = value ; QOBJECT_INIT ( qb , & qbool_type ) ; return qb ; }##::##0##::##346
static int wma_decode_block ( WMACodecContext * s ) { int n , v , a , ch , bsize ; int coef_nb_bits , total_gain ; int nb_coefs [ MAX_CHANNELS ] ; float mdct_norm ; FFTContext * mdct ; # ifdef TRACE tprintf ( s -> avctx , "***decode_block: %d:%d\n" , s -> frame_count - 1 , s -> block_num ) ; # endif if ( s -> use_variable_block_len ) { n = av_log2 ( s -> nb_block_sizes - 1 ) + 1 ; if ( s -> reset_block_lengths ) { s -> reset_block_lengths = 0 ; v = get_bits ( & s -> gb , n ) ; if ( v >= s -> nb_block_sizes ) { av_log ( s -> avctx , AV_LOG_ERROR , "prev_block_len_bits %d out of range\n" , s -> frame_len_bits - v ) ; return - 1 ; s -> prev_block_len_bits = s -> frame_len_bits - v ; v = get_bits ( & s -> gb , n ) ; if ( v >= s -> nb_block_sizes ) { av_log ( s -> avctx , AV_LOG_ERROR , "block_len_bits %d out of range\n" , s -> frame_len_bits - v ) ; return - 1 ; s -> block_len_bits = s -> frame_len_bits - v ; } else { s -> prev_block_len_bits = s -> block_len_bits ; s -> block_len_bits = s -> next_block_len_bits ; v = get_bits ( & s -> gb , n ) ; if ( v >= s -> nb_block_sizes ) { av_log ( s -> avctx , AV_LOG_ERROR , "next_block_len_bits %d out of range\n" , s -> frame_len_bits - v ) ; return - 1 ; s -> next_block_len_bits = s -> frame_len_bits - v ; } else { s -> next_block_len_bits = s -> frame_len_bits ; s -> prev_block_len_bits = s -> frame_len_bits ; s -> block_len_bits = s -> frame_len_bits ; if ( s -> frame_len_bits - s -> block_len_bits >= s -> nb_block_sizes ) { av_log ( s -> avctx , AV_LOG_ERROR , "block_len_bits not initialized to a valid value\n" ) ; return - 1 ; s -> block_len = 1 << s -> block_len_bits ; if ( ( s -> block_pos + s -> block_len ) > s -> frame_len ) { av_log ( s -> avctx , AV_LOG_ERROR , "frame_len overflow\n" ) ; return - 1 ; if ( s -> avctx -> channels == 2 ) { s -> ms_stereo = get_bits1 ( & s -> gb ) ; v = 0 ; for ( ch = 0 ; ch < s -> avctx -> channels ; ch ++ ) { a = get_bits1 ( & s -> gb ) ; s -> channel_coded [ ch ] = a ; v |= a ; bsize = s -> frame_len_bits - s -> block_len_bits ; if ( ! v ) { goto next ; } total_gain = 1 ; for ( ; ; ) { a = get_bits ( & s -> gb , 7 ) ; total_gain += a ; if ( a != 127 ) { break ; } coef_nb_bits = ff_wma_total_gain_to_bits ( total_gain ) ; n = s -> coefs_end [ bsize ] - s -> coefs_start ; for ( ch = 0 ; ch < s -> avctx -> channels ; ch ++ ) { nb_coefs [ ch ] = n ; } if ( s -> use_noise_coding ) { for ( ch = 0 ; ch < s -> avctx -> channels ; ch ++ ) { if ( s -> channel_coded [ ch ] ) { int i , n , a ; n = s -> exponent_high_sizes [ bsize ] ; for ( i = 0 ; i < n ; i ++ ) { a = get_bits1 ( & s -> gb ) ; s -> high_band_coded [ ch ] [ i ] = a ; if ( a ) { nb_coefs [ ch ] -= s -> exponent_high_bands [ bsize ] [ i ] ; } for ( ch = 0 ; ch < s -> avctx -> channels ; ch ++ ) { if ( s -> channel_coded [ ch ] ) { int i , n , val , code ; n = s -> exponent_high_sizes [ bsize ] ; val = ( int ) 0x80000000 ; for ( i = 0 ; i < n ; i ++ ) { if ( s -> high_band_coded [ ch ] [ i ] ) { if ( val == ( int ) 0x80000000 ) { val = get_bits ( & s -> gb , 7 ) - 19 ; } else { code = get_vlc2 ( & s -> gb , s -> hgain_vlc . table , HGAINVLCBITS , HGAINMAX ) ; if ( code < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , "hgain vlc invalid\n" ) ; return - 1 ; val += code - 18 ; s -> high_band_values [ ch ] [ i ] = val ; if ( ( s -> block_len_bits == s -> frame_len_bits ) || get_bits1 ( & s -> gb ) ) { for ( ch = 0 ; ch < s -> avctx -> channels ; ch ++ ) { if ( s -> channel_coded [ ch ] ) { if ( s -> use_exp_vlc ) { if ( decode_exp_vlc ( s , ch ) < 0 ) { return - 1 ; } } else { decode_exp_lsp ( s , ch ) ; s -> exponents_bsize [ ch ] = bsize ; for ( ch = 0 ; ch < s -> avctx -> channels ; ch ++ ) { if ( s -> channel_coded [ ch ] ) { int tindex ; WMACoef * ptr = & s -> coefs1 [ ch ] [ 0 ] ; tindex = ( ch == 1 && s -> ms_stereo ) ; memset ( ptr , 0 , s -> block_len * sizeof ( WMACoef ) ) ; ff_wma_run_level_decode ( s -> avctx , & s -> gb , & s -> coef_vlc [ tindex ] , s -> level_table [ tindex ] , s -> run_table [ tindex ] , 0 , ptr , 0 , nb_coefs [ ch ] , s -> block_len , s -> frame_len_bits , coef_nb_bits ) ; if ( s -> version == 1 && s -> avctx -> channels >= 2 ) { align_get_bits ( & s -> gb ) ; { int n4 = s -> block_len / 2 ; mdct_norm = 1.0 / ( float ) n4 ; if ( s -> version == 1 ) { mdct_norm *= sqrt ( n4 ) ; for ( ch = 0 ; ch < s -> avctx -> channels ; ch ++ ) { if ( s -> channel_coded [ ch ] ) { WMACoef * coefs1 ; float * coefs , * exponents , mult , mult1 , noise ; int i , j , n , n1 , last_high_band , esize ; float exp_power [ HIGH_BAND_MAX_SIZE ] ; coefs1 = s -> coefs1 [ ch ] ; exponents = s -> exponents [ ch ] ; esize = s -> exponents_bsize [ ch ] ; mult = pow ( 10 , total_gain * 0.05 ) / s -> max_exponent [ ch ] ; mult *= mdct_norm ; coefs = s -> coefs [ ch ] ; if ( s -> use_noise_coding ) { mult1 = mult ; for ( i = 0 ; i < s -> coefs_start ; i ++ ) { * coefs ++ = s -> noise_table [ s -> noise_index ] * exponents [ i << bsize >> esize ] * mult1 ; s -> noise_index = ( s -> noise_index + 1 ) & ( NOISE_TAB_SIZE - 1 ) ; n1 = s -> exponent_high_sizes [ bsize ] ; exponents = s -> exponents [ ch ] + ( s -> high_band_start [ bsize ] << bsize >> esize ) ; last_high_band = 0 ; for ( j = 0 ; j < n1 ; j ++ ) { n = s -> exponent_high_bands [ s -> frame_len_bits - s -> block_len_bits ] [ j ] ; if ( s -> high_band_coded [ ch ] [ j ] ) { float e2 , v ; e2 = 0 ; for ( i = 0 ; i < n ; i ++ ) { v = exponents [ i << bsize >> esize ] ; e2 += v * v ; exp_power [ j ] = e2 / n ; last_high_band = j ; tprintf ( s -> avctx , "%d: power=%f (%d)\n" , j , exp_power [ j ] , n ) ; exponents += n << bsize >> esize ; exponents = s -> exponents [ ch ] + ( s -> coefs_start << bsize >> esize ) ; for ( j = - 1 ; j < n1 ; j ++ ) { if ( j < 0 ) { n = s -> high_band_start [ bsize ] - s -> coefs_start ; } else { n = s -> exponent_high_bands [ s -> frame_len_bits - s -> block_len_bits ] [ j ] ; if ( j >= 0 && s -> high_band_coded [ ch ] [ j ] ) { mult1 = sqrt ( exp_power [ j ] / exp_power [ last_high_band ] ) ; mult1 = mult1 * pow ( 10 , s -> high_band_values [ ch ] [ j ] * 0.05 ) ; mult1 = mult1 / ( s -> max_exponent [ ch ] * s -> noise_mult ) ; mult1 *= mdct_norm ; for ( i = 0 ; i < n ; i ++ ) { noise = s -> noise_table [ s -> noise_index ] ; s -> noise_index = ( s -> noise_index + 1 ) & ( NOISE_TAB_SIZE - 1 ) ; * coefs ++ = noise * exponents [ i << bsize >> esize ] * mult1 ; exponents += n << bsize >> esize ; } else { for ( i = 0 ; i < n ; i ++ ) { noise = s -> noise_table [ s -> noise_index ] ; s -> noise_index = ( s -> noise_index + 1 ) & ( NOISE_TAB_SIZE - 1 ) ; * coefs ++ = ( ( * coefs1 ++ ) + noise ) * exponents [ i << bsize >> esize ] * mult ; exponents += n << bsize >> esize ; n = s -> block_len - s -> coefs_end [ bsize ] ; mult1 = mult * exponents [ ( ( - 1 << bsize ) ) >> esize ] ; for ( i = 0 ; i < n ; i ++ ) { * coefs ++ = s -> noise_table [ s -> noise_index ] * mult1 ; s -> noise_index = ( s -> noise_index + 1 ) & ( NOISE_TAB_SIZE - 1 ) ; } else { for ( i = 0 ; i < s -> coefs_start ; i ++ ) { * coefs ++ = 0.0 ; } n = nb_coefs [ ch ] ; for ( i = 0 ; i < n ; i ++ ) { * coefs ++ = coefs1 [ i ] * exponents [ i << bsize >> esize ] * mult ; n = s -> block_len - s -> coefs_end [ bsize ] ; for ( i = 0 ; i < n ; i ++ ) { * coefs ++ = 0.0 ; } # ifdef TRACE for ( ch = 0 ; ch < s -> avctx -> channels ; ch ++ ) { if ( s -> channel_coded [ ch ] ) { dump_floats ( s , "exponents" , 3 , s -> exponents [ ch ] , s -> block_len ) ; dump_floats ( s , "coefs" , 1 , s -> coefs [ ch ] , s -> block_len ) ; # endif if ( s -> ms_stereo && s -> channel_coded [ 1 ] ) { if ( ! s -> channel_coded [ 0 ] ) { tprintf ( s -> avctx , "rare ms-stereo case happened\n" ) ; memset ( s -> coefs [ 0 ] , 0 , sizeof ( float ) * s -> block_len ) ; s -> channel_coded [ 0 ] = 1 ; s -> fdsp . butterflies_float ( s -> coefs [ 0 ] , s -> coefs [ 1 ] , s -> block_len ) ; next : mdct = & s -> mdct_ctx [ bsize ] ; for ( ch = 0 ; ch < s -> avctx -> channels ; ch ++ ) { int n4 , index ; n4 = s -> block_len / 2 ; if ( s -> channel_coded [ ch ] ) { mdct -> imdct_calc ( mdct , s -> output , s -> coefs [ ch ] ) ; } else if ( ! ( s -> ms_stereo && ch == 1 ) ) { memset ( s -> output , 0 , sizeof ( s -> output ) ) ; } index = ( s -> frame_len / 2 ) + s -> block_pos - n4 ; wma_window ( s , & s -> frame_out [ ch ] [ index ] ) ; s -> block_num ++ ; s -> block_pos += s -> block_len ; if ( s -> block_pos >= s -> frame_len ) { return 1 ; } else { return 0 ; }##::##1##::##7383
static void virtio_init_pci ( VirtIOPCIProxy * proxy , VirtIODevice * vdev , uint16_t vendor , uint16_t device , uint16_t class_code , uint8_t pif ) { uint8_t * config ; uint32_t size ; proxy -> vdev = vdev ; config = proxy -> pci_dev . config ; pci_config_set_vendor_id ( config , vendor ) ; pci_config_set_device_id ( config , device ) ; config [ 0x08 ] = VIRTIO_PCI_ABI_VERSION ; config [ 0x09 ] = pif ; pci_config_set_class ( config , class_code ) ; config [ PCI_HEADER_TYPE ] = PCI_HEADER_TYPE_NORMAL ; config [ 0x2c ] = vendor & 0xFF ; config [ 0x2d ] = ( vendor >> 8 ) & 0xFF ; config [ 0x2e ] = vdev -> device_id & 0xFF ; config [ 0x2f ] = ( vdev -> device_id >> 8 ) & 0xFF ; config [ 0x3d ] = 1 ; if ( vdev -> nvectors && ! msix_init ( & proxy -> pci_dev , vdev -> nvectors , 1 , 0 , TARGET_PAGE_SIZE ) ) { pci_register_bar ( & proxy -> pci_dev , 1 , msix_bar_size ( & proxy -> pci_dev ) , PCI_ADDRESS_SPACE_MEM , msix_mmio_map ) ; } else { vdev -> nvectors = 0 ; } proxy -> pci_dev . config_write = virtio_write_config ; size = VIRTIO_PCI_REGION_SIZE ( & proxy -> pci_dev ) + vdev -> config_len ; if ( size & ( size - 1 ) ) { size = 1 << qemu_fls ( size ) ; } pci_register_bar ( & proxy -> pci_dev , 0 , size , PCI_ADDRESS_SPACE_IO , virtio_map ) ; qemu_register_reset ( virtio_pci_reset , proxy ) ; virtio_bind_device ( vdev , & virtio_pci_bindings , proxy ) ; }##::##1##::##6225
static int add_string_metadata ( int count , const char * name , TiffContext * s ) { char * value ; if ( bytestream2_get_bytes_left ( & s -> gb ) < count ) { return AVERROR_INVALIDDATA ; } value = av_malloc ( count + 1 ) ; if ( ! value ) { return AVERROR ( ENOMEM ) ; } bytestream2_get_bufferu ( & s -> gb , value , count ) ; value [ count ] = 0 ; av_dict_set ( & s -> picture . metadata , name , value , AV_DICT_DONT_STRDUP_VAL ) ; return 0 ; }##::##0##::##9794
static bool ga_open_pidfile ( const char * pidfile ) { int pidfd ; char pidstr [ 32 ] ; pidfd = open ( pidfile , O_CREAT | O_WRONLY , S_IRUSR | S_IWUSR ) ; if ( pidfd == - 1 || lockf ( pidfd , F_TLOCK , 0 ) ) { g_critical ( "Cannot lock pid file, %s" , strerror ( errno ) ) ; if ( pidfd != - 1 ) { close ( pidfd ) ; } return false ; } if ( ftruncate ( pidfd , 0 ) || lseek ( pidfd , 0 , SEEK_SET ) ) { g_critical ( "Failed to truncate pid file" ) ; goto fail ; } snprintf ( pidstr , sizeof ( pidstr ) , "%d\n" , getpid ( ) ) ; if ( write ( pidfd , pidstr , strlen ( pidstr ) ) != strlen ( pidstr ) ) { g_critical ( "Failed to write pid file" ) ; goto fail ; } return true ; fail : unlink ( pidfile ) ; return false ; }##::##1##::##11226
static int rv10_decode_init ( AVCodecContext * avctx ) { MpegEncContext * s = avctx -> priv_data ; static int done = 0 ; MPV_decode_defaults ( s ) ; s -> avctx = avctx ; s -> out_format = FMT_H263 ; s -> codec_id = avctx -> codec_id ; s -> width = avctx -> width ; s -> height = avctx -> height ; switch ( avctx -> sub_id ) { case 0x10000000 : s -> rv10_version = 0 ; s -> h263_long_vectors = 0 ; s -> low_delay = 1 ; break ; case 0x10002000 : s -> rv10_version = 3 ; s -> h263_long_vectors = 1 ; s -> low_delay = 1 ; s -> obmc = 1 ; break ; case 0x10003000 : s -> rv10_version = 3 ; s -> h263_long_vectors = 1 ; s -> low_delay = 1 ; break ; case 0x10003001 : s -> rv10_version = 3 ; s -> h263_long_vectors = 0 ; s -> low_delay = 1 ; break ; case 0x20001000 : case 0x20100001 : case 0x20101001 : case 0x20103001 : s -> low_delay = 1 ; break ; case 0x20200002 : case 0x20201002 : case 0x30202002 : case 0x30203002 : s -> low_delay = 0 ; s -> avctx -> has_b_frames = 1 ; break ; default : av_log ( s -> avctx , AV_LOG_ERROR , "unknown header %X\n" , avctx -> sub_id ) ; } if ( MPV_common_init ( s ) < 0 ) { return - 1 ; } h263_decode_init_vlc ( s ) ; if ( ! done ) { init_vlc ( & rv_dc_lum , DC_VLC_BITS , 256 , rv_lum_bits , 1 , 1 , rv_lum_code , 2 , 2 ) ; init_vlc ( & rv_dc_chrom , DC_VLC_BITS , 256 , rv_chrom_bits , 1 , 1 , rv_chrom_code , 2 , 2 ) ; done = 1 ; } avctx -> pix_fmt = PIX_FMT_YUV420P ; return 0 ; }##::##1##::##5741
static int multiwrite_f ( int argc , char * * argv ) { struct timeval t1 , t2 ; int Cflag = 0 , qflag = 0 ; int c , cnt ; char * * buf ; int64_t offset , first_offset = 0 ; int total = 0 ; int nr_iov ; int nr_reqs ; int pattern = 0xcd ; QEMUIOVector * qiovs ; int i ; BlockRequest * reqs ; while ( ( c = getopt ( argc , argv , "CqP:" ) ) != EOF ) { switch ( c ) { case 'C' : Cflag = 1 ; break ; case 'q' : qflag = 1 ; break ; case 'P' : pattern = parse_pattern ( optarg ) ; if ( pattern < 0 ) { return 0 ; } break ; default : return command_usage ( & writev_cmd ) ; } } if ( optind > argc - 2 ) { return command_usage ( & writev_cmd ) ; } nr_reqs = 1 ; for ( i = optind ; i < argc ; i ++ ) { if ( ! strcmp ( argv [ i ] , ";" ) ) { nr_reqs ++ ; } } reqs = g_malloc0 ( nr_reqs * sizeof ( * reqs ) ) ; buf = g_malloc0 ( nr_reqs * sizeof ( * buf ) ) ; qiovs = g_malloc ( nr_reqs * sizeof ( * qiovs ) ) ; for ( i = 0 ; i < nr_reqs ; i ++ ) { int j ; offset = cvtnum ( argv [ optind ] ) ; if ( offset < 0 ) { printf ( "non-numeric offset argument -- %s\n" , argv [ optind ] ) ; return 0 ; } optind ++ ; if ( offset & 0x1ff ) { printf ( "offset %lld is not sector aligned\n" , ( long long ) offset ) ; return 0 ; } if ( i == 0 ) { first_offset = offset ; } for ( j = optind ; j < argc ; j ++ ) { if ( ! strcmp ( argv [ j ] , ";" ) ) { break ; } } nr_iov = j - optind ; buf [ i ] = create_iovec ( & qiovs [ i ] , & argv [ optind ] , nr_iov , pattern ) ; if ( buf [ i ] == NULL ) { goto out ; } reqs [ i ] . qiov = & qiovs [ i ] ; reqs [ i ] . sector = offset >> 9 ; reqs [ i ] . nb_sectors = reqs [ i ] . qiov -> size >> 9 ; optind = j + 1 ; pattern ++ ; } gettimeofday ( & t1 , NULL ) ; cnt = do_aio_multiwrite ( reqs , nr_reqs , & total ) ; gettimeofday ( & t2 , NULL ) ; if ( cnt < 0 ) { printf ( "aio_multiwrite failed: %s\n" , strerror ( - cnt ) ) ; goto out ; } if ( qflag ) { goto out ; } t2 = tsub ( t2 , t1 ) ; print_report ( "wrote" , & t2 , first_offset , total , total , cnt , Cflag ) ; out : for ( i = 0 ; i < nr_reqs ; i ++ ) { qemu_io_free ( buf [ i ] ) ; if ( reqs [ i ] . qiov != NULL ) { qemu_iovec_destroy ( & qiovs [ i ] ) ; } } g_free ( buf ) ; g_free ( reqs ) ; g_free ( qiovs ) ; return 0 ; }##::##1##::##5459
static void musicpal_misc_write ( void * opaque , target_phys_addr_t offset , uint64_t value , unsigned size ) { }##::##0##::##5344
static void test_tco_second_timeout_pause ( void ) { TestData td ; const uint16_t ticks = TCO_SECS_TO_TICKS ( 32 ) ; QDict * ad ; td . args = "-watchdog-action pause" ; td . noreboot = false ; test_init ( & td ) ; stop_tco ( & td ) ; clear_tco_status ( & td ) ; reset_on_second_timeout ( true ) ; set_tco_timeout ( & td , TCO_SECS_TO_TICKS ( 16 ) ) ; load_tco ( & td ) ; start_tco ( & td ) ; clock_step ( ticks * TCO_TICK_NSEC * 2 ) ; ad = get_watchdog_action ( ) ; g_assert ( ! strcmp ( qdict_get_str ( ad , "action" ) , "pause" ) ) ; QDECREF ( ad ) ; stop_tco ( & td ) ; qtest_end ( ) ; }##::##1##::##139
static void group_exponents ( AC3EncodeContext * s ) { int blk , ch , i ; int group_size , nb_groups , bit_count ; uint8_t * p ; int delta0 , delta1 , delta2 ; int exp0 , exp1 ; bit_count = 0 ; for ( blk = 0 ; blk < AC3_MAX_BLOCKS ; blk ++ ) { AC3Block * block = & s -> blocks [ blk ] ; for ( ch = 0 ; ch < s -> channels ; ch ++ ) { if ( s -> exp_strategy [ ch ] [ blk ] == EXP_REUSE ) { continue ; } group_size = s -> exp_strategy [ ch ] [ blk ] + ( s -> exp_strategy [ ch ] [ blk ] == EXP_D45 ) ; nb_groups = exponent_group_tab [ s -> exp_strategy [ ch ] [ blk ] - 1 ] [ s -> nb_coefs [ ch ] ] ; bit_count += 4 + ( nb_groups * 7 ) ; p = block -> exp [ ch ] ; exp1 = * p ++ ; block -> grouped_exp [ ch ] [ 0 ] = exp1 ; for ( i = 1 ; i <= nb_groups ; i ++ ) { exp0 = exp1 ; exp1 = p [ 0 ] ; p += group_size ; delta0 = exp1 - exp0 + 2 ; exp0 = exp1 ; exp1 = p [ 0 ] ; p += group_size ; delta1 = exp1 - exp0 + 2 ; exp0 = exp1 ; exp1 = p [ 0 ] ; p += group_size ; delta2 = exp1 - exp0 + 2 ; block -> grouped_exp [ ch ] [ i ] = ( ( delta0 * 5 + delta1 ) * 5 ) + delta2 ; } } } s -> exponent_bits = bit_count ; }##::##0##::##556
static int parse_ffconfig ( const char * filename ) { FILE * f ; char line [ 1024 ] ; char cmd [ 64 ] ; char arg [ 1024 ] ; const char * p ; int val , errors , line_num ; FFStream * * last_stream , * stream , * redirect ; FFStream * * last_feed , * feed , * s ; AVCodecContext audio_enc , video_enc ; enum CodecID audio_id , video_id ; f = fopen ( filename , "r" ) ; if ( ! f ) { perror ( filename ) ; return - 1 ; } errors = 0 ; line_num = 0 ; first_stream = NULL ; last_stream = & first_stream ; first_feed = NULL ; last_feed = & first_feed ; stream = NULL ; feed = NULL ; redirect = NULL ; audio_id = CODEC_ID_NONE ; video_id = CODEC_ID_NONE ; for ( ; ; ) { if ( fgets ( line , sizeof ( line ) , f ) == NULL ) { break ; } line_num ++ ; p = line ; while ( isspace ( * p ) ) { p ++ ; } if ( * p == '\0' || * p == '#' ) { continue ; } get_arg ( cmd , sizeof ( cmd ) , & p ) ; if ( ! strcasecmp ( cmd , "Port" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; val = atoi ( arg ) ; if ( val < 1 || val > 65536 ) { fprintf ( stderr , "%s:%d: Invalid port: %s\n" , filename , line_num , arg ) ; errors ++ ; } my_http_addr . sin_port = htons ( val ) ; } else if ( ! strcasecmp ( cmd , "BindAddress" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( resolve_host ( & my_http_addr . sin_addr , arg ) != 0 ) { fprintf ( stderr , "%s:%d: Invalid host/IP address: %s\n" , filename , line_num , arg ) ; errors ++ ; } } else if ( ! strcasecmp ( cmd , "NoDaemon" ) ) { ffserver_daemon = 0 ; } else if ( ! strcasecmp ( cmd , "RTSPPort" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; val = atoi ( arg ) ; if ( val < 1 || val > 65536 ) { fprintf ( stderr , "%s:%d: Invalid port: %s\n" , filename , line_num , arg ) ; errors ++ ; } my_rtsp_addr . sin_port = htons ( atoi ( arg ) ) ; } else if ( ! strcasecmp ( cmd , "RTSPBindAddress" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( resolve_host ( & my_rtsp_addr . sin_addr , arg ) != 0 ) { fprintf ( stderr , "%s:%d: Invalid host/IP address: %s\n" , filename , line_num , arg ) ; errors ++ ; } } else if ( ! strcasecmp ( cmd , "MaxHTTPConnections" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; val = atoi ( arg ) ; if ( val < 1 || val > 65536 ) { fprintf ( stderr , "%s:%d: Invalid MaxHTTPConnections: %s\n" , filename , line_num , arg ) ; errors ++ ; } nb_max_http_connections = val ; } else if ( ! strcasecmp ( cmd , "MaxClients" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; val = atoi ( arg ) ; if ( val < 1 || val > nb_max_http_connections ) { fprintf ( stderr , "%s:%d: Invalid MaxClients: %s\n" , filename , line_num , arg ) ; errors ++ ; } else { nb_max_connections = val ; } } else if ( ! strcasecmp ( cmd , "MaxBandwidth" ) ) { int64_t llval ; get_arg ( arg , sizeof ( arg ) , & p ) ; llval = atoll ( arg ) ; if ( llval < 10 || llval > 10000000 ) { fprintf ( stderr , "%s:%d: Invalid MaxBandwidth: %s\n" , filename , line_num , arg ) ; errors ++ ; } else { max_bandwidth = llval ; } } else if ( ! strcasecmp ( cmd , "CustomLog" ) ) { if ( ! ffserver_debug ) { get_arg ( logfilename , sizeof ( logfilename ) , & p ) ; } } else if ( ! strcasecmp ( cmd , "<Feed" ) ) { char * q ; if ( stream || feed ) { fprintf ( stderr , "%s:%d: Already in a tag\n" , filename , line_num ) ; } else { feed = av_mallocz ( sizeof ( FFStream ) ) ; get_arg ( feed -> filename , sizeof ( feed -> filename ) , & p ) ; q = strrchr ( feed -> filename , '>' ) ; if ( * q ) { * q = '\0' ; } for ( s = first_feed ; s ; s = s -> next ) { if ( ! strcmp ( feed -> filename , s -> filename ) ) { fprintf ( stderr , "%s:%d: Feed '%s' already registered\n" , filename , line_num , s -> filename ) ; errors ++ ; } } feed -> fmt = guess_format ( "ffm" , NULL , NULL ) ; snprintf ( feed -> feed_filename , sizeof ( feed -> feed_filename ) , "/tmp/%s.ffm" , feed -> filename ) ; feed -> feed_max_size = 5 * 1024 * 1024 ; feed -> is_feed = 1 ; feed -> feed = feed ; * last_stream = feed ; last_stream = & feed -> next ; * last_feed = feed ; last_feed = & feed -> next_feed ; } } else if ( ! strcasecmp ( cmd , "Launch" ) ) { if ( feed ) { int i ; feed -> child_argv = av_mallocz ( 64 * sizeof ( char * ) ) ; for ( i = 0 ; i < 62 ; i ++ ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( ! arg [ 0 ] ) { break ; } feed -> child_argv [ i ] = av_strdup ( arg ) ; } feed -> child_argv [ i ] = av_malloc ( 30 + strlen ( feed -> filename ) ) ; snprintf ( feed -> child_argv [ i ] , 30 + strlen ( feed -> filename ) , "http://%s:%d/%s" , ( my_http_addr . sin_addr . s_addr == INADDR_ANY ) ? "127.0.0.1" : inet_ntoa ( my_http_addr . sin_addr ) , ntohs ( my_http_addr . sin_port ) , feed -> filename ) ; } } else if ( ! strcasecmp ( cmd , "ReadOnlyFile" ) ) { if ( feed ) { get_arg ( feed -> feed_filename , sizeof ( feed -> feed_filename ) , & p ) ; feed -> readonly = 1 ; } else if ( stream ) { get_arg ( stream -> feed_filename , sizeof ( stream -> feed_filename ) , & p ) ; } } else if ( ! strcasecmp ( cmd , "File" ) ) { if ( feed ) { get_arg ( feed -> feed_filename , sizeof ( feed -> feed_filename ) , & p ) ; } else if ( stream ) { get_arg ( stream -> feed_filename , sizeof ( stream -> feed_filename ) , & p ) ; } } else if ( ! strcasecmp ( cmd , "Truncate" ) ) { if ( feed ) { get_arg ( arg , sizeof ( arg ) , & p ) ; feed -> truncate = strtod ( arg , NULL ) ; } } else if ( ! strcasecmp ( cmd , "FileMaxSize" ) ) { if ( feed ) { char * p1 ; double fsize ; get_arg ( arg , sizeof ( arg ) , & p ) ; p1 = arg ; fsize = strtod ( p1 , & p1 ) ; switch ( toupper ( * p1 ) ) { case 'K' : fsize *= 1024 ; break ; case 'M' : fsize *= 1024 * 1024 ; break ; case 'G' : fsize *= 1024 * 1024 * 1024 ; break ; } feed -> feed_max_size = ( int64_t ) fsize ; if ( feed -> feed_max_size < FFM_PACKET_SIZE * 4 ) { fprintf ( stderr , "%s:%d: Feed max file size is too small, " "must be at least %d\n" , filename , line_num , FFM_PACKET_SIZE * 4 ) ; errors ++ ; } } } else if ( ! strcasecmp ( cmd , "</Feed>" ) ) { if ( ! feed ) { fprintf ( stderr , "%s:%d: No corresponding <Feed> for </Feed>\n" , filename , line_num ) ; errors ++ ; } feed = NULL ; } else if ( ! strcasecmp ( cmd , "<Stream" ) ) { char * q ; if ( stream || feed ) { fprintf ( stderr , "%s:%d: Already in a tag\n" , filename , line_num ) ; } else { FFStream * s ; const AVClass * class ; stream = av_mallocz ( sizeof ( FFStream ) ) ; get_arg ( stream -> filename , sizeof ( stream -> filename ) , & p ) ; q = strrchr ( stream -> filename , '>' ) ; if ( * q ) { * q = '\0' ; } for ( s = first_stream ; s ; s = s -> next ) { if ( ! strcmp ( stream -> filename , s -> filename ) ) { fprintf ( stderr , "%s:%d: Stream '%s' already registered\n" , filename , line_num , s -> filename ) ; errors ++ ; } } stream -> fmt = guess_stream_format ( NULL , stream -> filename , NULL ) ; avcodec_get_context_defaults ( & video_enc ) ; class = video_enc . av_class ; memset ( & audio_enc , 0 , sizeof ( AVCodecContext ) ) ; memset ( & video_enc , 0 , sizeof ( AVCodecContext ) ) ; audio_enc . av_class = class ; video_enc . av_class = class ; audio_id = CODEC_ID_NONE ; video_id = CODEC_ID_NONE ; if ( stream -> fmt ) { audio_id = stream -> fmt -> audio_codec ; video_id = stream -> fmt -> video_codec ; } * last_stream = stream ; last_stream = & stream -> next ; } } else if ( ! strcasecmp ( cmd , "Feed" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { FFStream * sfeed ; sfeed = first_feed ; while ( sfeed != NULL ) { if ( ! strcmp ( sfeed -> filename , arg ) ) { break ; } sfeed = sfeed -> next_feed ; } if ( ! sfeed ) fprintf ( stderr , "%s:%d: feed '%s' not defined\n" , filename , line_num , arg ) ; else { stream -> feed = sfeed ; } } } else if ( ! strcasecmp ( cmd , "Format" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { if ( ! strcmp ( arg , "status" ) ) { stream -> stream_type = STREAM_TYPE_STATUS ; stream -> fmt = NULL ; } else { stream -> stream_type = STREAM_TYPE_LIVE ; if ( ! strcmp ( arg , "jpeg" ) ) { strcpy ( arg , "mjpeg" ) ; } stream -> fmt = guess_stream_format ( arg , NULL , NULL ) ; if ( ! stream -> fmt ) { fprintf ( stderr , "%s:%d: Unknown Format: %s\n" , filename , line_num , arg ) ; errors ++ ; } } if ( stream -> fmt ) { audio_id = stream -> fmt -> audio_codec ; video_id = stream -> fmt -> video_codec ; } } } else if ( ! strcasecmp ( cmd , "InputFormat" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { stream -> ifmt = av_find_input_format ( arg ) ; if ( ! stream -> ifmt ) { fprintf ( stderr , "%s:%d: Unknown input format: %s\n" , filename , line_num , arg ) ; } } } else if ( ! strcasecmp ( cmd , "FaviconURL" ) ) { if ( stream && stream -> stream_type == STREAM_TYPE_STATUS ) { get_arg ( stream -> feed_filename , sizeof ( stream -> feed_filename ) , & p ) ; } else { fprintf ( stderr , "%s:%d: FaviconURL only permitted for status streams\n" , filename , line_num ) ; errors ++ ; } } else if ( ! strcasecmp ( cmd , "Author" ) ) { if ( stream ) { get_arg ( stream -> author , sizeof ( stream -> author ) , & p ) ; } } else if ( ! strcasecmp ( cmd , "Comment" ) ) { if ( stream ) { get_arg ( stream -> comment , sizeof ( stream -> comment ) , & p ) ; } } else if ( ! strcasecmp ( cmd , "Copyright" ) ) { if ( stream ) { get_arg ( stream -> copyright , sizeof ( stream -> copyright ) , & p ) ; } } else if ( ! strcasecmp ( cmd , "Title" ) ) { if ( stream ) { get_arg ( stream -> title , sizeof ( stream -> title ) , & p ) ; } } else if ( ! strcasecmp ( cmd , "Preroll" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { stream -> prebuffer = atof ( arg ) * 1000 ; } } else if ( ! strcasecmp ( cmd , "StartSendOnKey" ) ) { if ( stream ) { stream -> send_on_key = 1 ; } } else if ( ! strcasecmp ( cmd , "AudioCodec" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; audio_id = opt_audio_codec ( arg ) ; if ( audio_id == CODEC_ID_NONE ) { fprintf ( stderr , "%s:%d: Unknown AudioCodec: %s\n" , filename , line_num , arg ) ; errors ++ ; } } else if ( ! strcasecmp ( cmd , "VideoCodec" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; video_id = opt_video_codec ( arg ) ; if ( video_id == CODEC_ID_NONE ) { fprintf ( stderr , "%s:%d: Unknown VideoCodec: %s\n" , filename , line_num , arg ) ; errors ++ ; } } else if ( ! strcasecmp ( cmd , "MaxTime" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { stream -> max_time = atof ( arg ) * 1000 ; } } else if ( ! strcasecmp ( cmd , "AudioBitRate" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { audio_enc . bit_rate = atoi ( arg ) * 1000 ; } } else if ( ! strcasecmp ( cmd , "AudioChannels" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { audio_enc . channels = atoi ( arg ) ; } } else if ( ! strcasecmp ( cmd , "AudioSampleRate" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { audio_enc . sample_rate = atoi ( arg ) ; } } else if ( ! strcasecmp ( cmd , "AudioQuality" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { } } else if ( ! strcasecmp ( cmd , "VideoBitRateRange" ) ) { if ( stream ) { int minrate , maxrate ; get_arg ( arg , sizeof ( arg ) , & p ) ; if ( sscanf ( arg , "%d-%d" , & minrate , & maxrate ) == 2 ) { video_enc . rc_min_rate = minrate * 1000 ; video_enc . rc_max_rate = maxrate * 1000 ; } else { fprintf ( stderr , "%s:%d: Incorrect format for VideoBitRateRange -- should be <min>-<max>: %s\n" , filename , line_num , arg ) ; errors ++ ; } } } else if ( ! strcasecmp ( cmd , "Debug" ) ) { if ( stream ) { get_arg ( arg , sizeof ( arg ) , & p ) ; video_enc . debug = strtol ( arg , 0 , 0 ) ; } } else if ( ! strcasecmp ( cmd , "Strict" ) ) { if ( stream ) { get_arg ( arg , sizeof ( arg ) , & p ) ; video_enc . strict_std_compliance = atoi ( arg ) ; } } else if ( ! strcasecmp ( cmd , "VideoBufferSize" ) ) { if ( stream ) { get_arg ( arg , sizeof ( arg ) , & p ) ; video_enc . rc_buffer_size = atoi ( arg ) * 8 * 1024 ; } } else if ( ! strcasecmp ( cmd , "VideoBitRateTolerance" ) ) { if ( stream ) { get_arg ( arg , sizeof ( arg ) , & p ) ; video_enc . bit_rate_tolerance = atoi ( arg ) * 1000 ; } } else if ( ! strcasecmp ( cmd , "VideoBitRate" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { video_enc . bit_rate = atoi ( arg ) * 1000 ; } } else if ( ! strcasecmp ( cmd , "VideoSize" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { av_parse_video_frame_size ( & video_enc . width , & video_enc . height , arg ) ; if ( ( video_enc . width % 16 ) != 0 || ( video_enc . height % 16 ) != 0 ) { fprintf ( stderr , "%s:%d: Image size must be a multiple of 16\n" , filename , line_num ) ; errors ++ ; } } } else if ( ! strcasecmp ( cmd , "VideoFrameRate" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { AVRational frame_rate ; if ( av_parse_video_frame_rate ( & frame_rate , arg ) < 0 ) { fprintf ( stderr , "Incorrect frame rate\n" ) ; errors ++ ; } else { video_enc . time_base . num = frame_rate . den ; video_enc . time_base . den = frame_rate . num ; } } } else if ( ! strcasecmp ( cmd , "VideoGopSize" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { video_enc . gop_size = atoi ( arg ) ; } } else if ( ! strcasecmp ( cmd , "VideoIntraOnly" ) ) { if ( stream ) { video_enc . gop_size = 1 ; } } else if ( ! strcasecmp ( cmd , "VideoHighQuality" ) ) { if ( stream ) { video_enc . mb_decision = FF_MB_DECISION_BITS ; } } else if ( ! strcasecmp ( cmd , "Video4MotionVector" ) ) { if ( stream ) { video_enc . mb_decision = FF_MB_DECISION_BITS ; video_enc . flags |= CODEC_FLAG_4MV ; } } else if ( ! strcasecmp ( cmd , "AVOptionVideo" ) || ! strcasecmp ( cmd , "AVOptionAudio" ) ) { char arg2 [ 1024 ] ; AVCodecContext * avctx ; int type ; get_arg ( arg , sizeof ( arg ) , & p ) ; get_arg ( arg2 , sizeof ( arg2 ) , & p ) ; if ( ! strcasecmp ( cmd , "AVOptionVideo" ) ) { avctx = & video_enc ; type = AV_OPT_FLAG_VIDEO_PARAM ; } else { avctx = & audio_enc ; type = AV_OPT_FLAG_AUDIO_PARAM ; } if ( ffserver_opt_default ( arg , arg2 , avctx , type | AV_OPT_FLAG_ENCODING_PARAM ) ) { fprintf ( stderr , "AVOption error: %s %s\n" , arg , arg2 ) ; errors ++ ; } } else if ( ! strcasecmp ( cmd , "VideoTag" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( ( strlen ( arg ) == 4 ) && stream ) { video_enc . codec_tag = AV_RL32 ( arg ) ; } } else if ( ! strcasecmp ( cmd , "BitExact" ) ) { if ( stream ) { video_enc . flags |= CODEC_FLAG_BITEXACT ; } } else if ( ! strcasecmp ( cmd , "DctFastint" ) ) { if ( stream ) { video_enc . dct_algo = FF_DCT_FASTINT ; } } else if ( ! strcasecmp ( cmd , "IdctSimple" ) ) { if ( stream ) { video_enc . idct_algo = FF_IDCT_SIMPLE ; } } else if ( ! strcasecmp ( cmd , "Qscale" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { video_enc . flags |= CODEC_FLAG_QSCALE ; video_enc . global_quality = FF_QP2LAMBDA * atoi ( arg ) ; } } else if ( ! strcasecmp ( cmd , "VideoQDiff" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { video_enc . max_qdiff = atoi ( arg ) ; if ( video_enc . max_qdiff < 1 || video_enc . max_qdiff > 31 ) { fprintf ( stderr , "%s:%d: VideoQDiff out of range\n" , filename , line_num ) ; errors ++ ; } } } else if ( ! strcasecmp ( cmd , "VideoQMax" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { video_enc . qmax = atoi ( arg ) ; if ( video_enc . qmax < 1 || video_enc . qmax > 31 ) { fprintf ( stderr , "%s:%d: VideoQMax out of range\n" , filename , line_num ) ; errors ++ ; } } } else if ( ! strcasecmp ( cmd , "VideoQMin" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { video_enc . qmin = atoi ( arg ) ; if ( video_enc . qmin < 1 || video_enc . qmin > 31 ) { fprintf ( stderr , "%s:%d: VideoQMin out of range\n" , filename , line_num ) ; errors ++ ; } } } else if ( ! strcasecmp ( cmd , "LumaElim" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { video_enc . luma_elim_threshold = atoi ( arg ) ; } } else if ( ! strcasecmp ( cmd , "ChromaElim" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { video_enc . chroma_elim_threshold = atoi ( arg ) ; } } else if ( ! strcasecmp ( cmd , "LumiMask" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { video_enc . lumi_masking = atof ( arg ) ; } } else if ( ! strcasecmp ( cmd , "DarkMask" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { video_enc . dark_masking = atof ( arg ) ; } } else if ( ! strcasecmp ( cmd , "NoVideo" ) ) { video_id = CODEC_ID_NONE ; } else if ( ! strcasecmp ( cmd , "NoAudio" ) ) { audio_id = CODEC_ID_NONE ; } else if ( ! strcasecmp ( cmd , "ACL" ) ) { IPAddressACL acl ; get_arg ( arg , sizeof ( arg ) , & p ) ; if ( strcasecmp ( arg , "allow" ) == 0 ) { acl . action = IP_ALLOW ; } else if ( strcasecmp ( arg , "deny" ) == 0 ) { acl . action = IP_DENY ; } else { fprintf ( stderr , "%s:%d: ACL action '%s' is not ALLOW or DENY\n" , filename , line_num , arg ) ; errors ++ ; } get_arg ( arg , sizeof ( arg ) , & p ) ; if ( resolve_host ( & acl . first , arg ) != 0 ) { fprintf ( stderr , "%s:%d: ACL refers to invalid host or ip address '%s'\n" , filename , line_num , arg ) ; errors ++ ; } else { acl . last = acl . first ; } get_arg ( arg , sizeof ( arg ) , & p ) ; if ( arg [ 0 ] ) { if ( resolve_host ( & acl . last , arg ) != 0 ) { fprintf ( stderr , "%s:%d: ACL refers to invalid host or ip address '%s'\n" , filename , line_num , arg ) ; errors ++ ; } } if ( ! errors ) { IPAddressACL * nacl = av_mallocz ( sizeof ( * nacl ) ) ; IPAddressACL * * naclp = 0 ; acl . next = 0 ; * nacl = acl ; if ( stream ) { naclp = & stream -> acl ; } else if ( feed ) { naclp = & feed -> acl ; } else { fprintf ( stderr , "%s:%d: ACL found not in <stream> or <feed>\n" , filename , line_num ) ; errors ++ ; } if ( naclp ) { while ( * naclp ) { naclp = & ( * naclp ) -> next ; } * naclp = nacl ; } } } else if ( ! strcasecmp ( cmd , "RTSPOption" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { av_freep ( & stream -> rtsp_option ) ; stream -> rtsp_option = av_strdup ( arg ) ; } } else if ( ! strcasecmp ( cmd , "MulticastAddress" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { if ( resolve_host ( & stream -> multicast_ip , arg ) != 0 ) { fprintf ( stderr , "%s:%d: Invalid host/IP address: %s\n" , filename , line_num , arg ) ; errors ++ ; } stream -> is_multicast = 1 ; stream -> loop = 1 ; } } else if ( ! strcasecmp ( cmd , "MulticastPort" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { stream -> multicast_port = atoi ( arg ) ; } } else if ( ! strcasecmp ( cmd , "MulticastTTL" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; if ( stream ) { stream -> multicast_ttl = atoi ( arg ) ; } } else if ( ! strcasecmp ( cmd , "NoLoop" ) ) { if ( stream ) { stream -> loop = 0 ; } } else if ( ! strcasecmp ( cmd , "</Stream>" ) ) { if ( ! stream ) { fprintf ( stderr , "%s:%d: No corresponding <Stream> for </Stream>\n" , filename , line_num ) ; errors ++ ; } else { if ( stream -> feed && stream -> fmt && strcmp ( stream -> fmt -> name , "ffm" ) != 0 ) { if ( audio_id != CODEC_ID_NONE ) { audio_enc . codec_type = CODEC_TYPE_AUDIO ; audio_enc . codec_id = audio_id ; add_codec ( stream , & audio_enc ) ; } if ( video_id != CODEC_ID_NONE ) { video_enc . codec_type = CODEC_TYPE_VIDEO ; video_enc . codec_id = video_id ; add_codec ( stream , & video_enc ) ; } } stream = NULL ; } } else if ( ! strcasecmp ( cmd , "<Redirect" ) ) { char * q ; if ( stream || feed || redirect ) { fprintf ( stderr , "%s:%d: Already in a tag\n" , filename , line_num ) ; errors ++ ; } else { redirect = av_mallocz ( sizeof ( FFStream ) ) ; * last_stream = redirect ; last_stream = & redirect -> next ; get_arg ( redirect -> filename , sizeof ( redirect -> filename ) , & p ) ; q = strrchr ( redirect -> filename , '>' ) ; if ( * q ) { * q = '\0' ; } redirect -> stream_type = STREAM_TYPE_REDIRECT ; } } else if ( ! strcasecmp ( cmd , "URL" ) ) { if ( redirect ) { get_arg ( redirect -> feed_filename , sizeof ( redirect -> feed_filename ) , & p ) ; } } else if ( ! strcasecmp ( cmd , "</Redirect>" ) ) { if ( ! redirect ) { fprintf ( stderr , "%s:%d: No corresponding <Redirect> for </Redirect>\n" , filename , line_num ) ; errors ++ ; } else { if ( ! redirect -> feed_filename [ 0 ] ) { fprintf ( stderr , "%s:%d: No URL found for <Redirect>\n" , filename , line_num ) ; errors ++ ; } redirect = NULL ; } } else if ( ! strcasecmp ( cmd , "LoadModule" ) ) { get_arg ( arg , sizeof ( arg ) , & p ) ; # if HAVE_DLOPEN load_module ( arg ) ; # else fprintf ( stderr , "%s:%d: Module support not compiled into this version: '%s'\n" , filename , line_num , arg ) ; errors ++ ; # endif } else { fprintf ( stderr , "%s:%d: Incorrect keyword: '%s'\n" , filename , line_num , cmd ) ; } } fclose ( f ) ; if ( errors ) { return - 1 ; } else { return 0 ; } }##::##0##::##11370
static void gen_tlbia ( DisasContext * ctx ) { # if defined ( CONFIG_USER_ONLY ) gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_OPC ) ; # else if ( unlikely ( ctx -> pr ) ) { gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_OPC ) ; return ; } gen_helper_tlbia ( cpu_env ) ; # endif }##::##1##::##7962
static void arm_sysctl_write ( void * opaque , target_phys_addr_t offset , uint64_t val , unsigned size ) { arm_sysctl_state * s = ( arm_sysctl_state * ) opaque ; switch ( offset ) { case 0x08 : s -> leds = val ; case 0x0c : case 0x10 : case 0x14 : case 0x18 : case 0x1c : break ; case 0x20 : if ( val == LOCK_VALUE ) { s -> lockval = val ; } else { s -> lockval = val & 0x7fff ; } break ; case 0x28 : s -> cfgdata1 = val ; break ; case 0x2c : s -> cfgdata2 = val ; break ; case 0x30 : s -> flags |= val ; break ; case 0x34 : s -> flags &= ~ val ; break ; case 0x38 : s -> nvflags |= val ; break ; case 0x3c : s -> nvflags &= ~ val ; break ; case 0x40 : switch ( board_id ( s ) ) { case BOARD_ID_PB926 : if ( s -> lockval == LOCK_VALUE ) { s -> resetlevel = val ; if ( val & 0x100 ) { qemu_system_reset_request ( ) ; } } break ; case BOARD_ID_PBX : case BOARD_ID_PBA8 : if ( s -> lockval == LOCK_VALUE ) { s -> resetlevel = val ; if ( val & 0x04 ) { qemu_system_reset_request ( ) ; } } break ; case BOARD_ID_VEXPRESS : case BOARD_ID_EB : default : break ; } break ; case 0x44 : break ; case 0x4c : break ; case 0x50 : switch ( board_id ( s ) ) { case BOARD_ID_PB926 : s -> sys_clcd &= 0x3f00 ; s -> sys_clcd |= val & ~ 0x3f00 ; qemu_set_irq ( s -> pl110_mux_ctrl , val & 3 ) ; break ; case BOARD_ID_EB : s -> sys_clcd &= 0x3f00 ; s -> sys_clcd |= val & ~ 0x3f00 ; break ; case BOARD_ID_PBA8 : case BOARD_ID_PBX : s -> sys_clcd &= ( 1 << 7 ) ; s -> sys_clcd |= val & ~ ( 1 << 7 ) ; break ; case BOARD_ID_VEXPRESS : default : break ; } case 0x54 : case 0x64 : case 0x68 : case 0x6c : case 0x70 : case 0x74 : case 0x80 : case 0x84 : case 0x88 : case 0x8c : case 0x90 : case 0x94 : case 0x98 : case 0x9c : break ; case 0xa0 : if ( board_id ( s ) != BOARD_ID_VEXPRESS ) { goto bad_reg ; } s -> sys_cfgdata = val ; return ; case 0xa4 : if ( board_id ( s ) != BOARD_ID_VEXPRESS ) { goto bad_reg ; } s -> sys_cfgctrl = val & ~ ( 3 << 18 ) ; s -> sys_cfgstat = 1 ; switch ( s -> sys_cfgctrl ) { case 0xc0800000 : qemu_system_shutdown_request ( ) ; break ; case 0xc0900000 : qemu_system_reset_request ( ) ; break ; default : s -> sys_cfgstat |= 2 ; } return ; case 0xa8 : if ( board_id ( s ) != BOARD_ID_VEXPRESS ) { goto bad_reg ; } s -> sys_cfgstat = val & 3 ; return ; default : bad_reg : printf ( "arm_sysctl_write: Bad register offset 0x%x\n" , ( int ) offset ) ; return ; } }##::##0##::##5367
static void h263_h_loop_filter_mmx ( uint8_t * src , int stride , int qscale ) { if ( CONFIG_H263_DECODER || CONFIG_H263_ENCODER ) { const int strength = ff_h263_loop_filter_strength [ qscale ] ; DECLARE_ALIGNED ( 8 , uint64_t , temp ) [ 4 ] ; uint8_t * btemp = ( uint8_t * ) temp ; src -= 2 ; transpose4x4 ( btemp , src , 8 , stride ) ; transpose4x4 ( btemp + 4 , src + 4 * stride , 8 , stride ) ; __asm__ volatile ( H263_LOOP_FILTER : "+m" ( temp [ 0 ] ) , "+m" ( temp [ 1 ] ) , "+m" ( temp [ 2 ] ) , "+m" ( temp [ 3 ] ) : "g" ( 2 * strength ) , "m" ( ff_pb_FC ) ) ; __asm__ volatile ( "movq      %%mm5, %%mm1         \n\t" "movq      %%mm4, %%mm0         \n\t" "punpcklbw %%mm3, %%mm5         \n\t" "punpcklbw %%mm6, %%mm4         \n\t" "punpckhbw %%mm3, %%mm1         \n\t" "punpckhbw %%mm6, %%mm0         \n\t" "movq      %%mm5, %%mm3         \n\t" "movq      %%mm1, %%mm6         \n\t" "punpcklwd %%mm4, %%mm5         \n\t" "punpcklwd %%mm0, %%mm1         \n\t" "punpckhwd %%mm4, %%mm3         \n\t" "punpckhwd %%mm0, %%mm6         \n\t" "movd      %%mm5, (%0)          \n\t" "punpckhdq %%mm5, %%mm5         \n\t" "movd      %%mm5, (%0, %2)      \n\t" "movd      %%mm3, (%0, %2, 2)   \n\t" "punpckhdq %%mm3, %%mm3         \n\t" "movd      %%mm3, (%0, %3)      \n\t" "movd      %%mm1, (%1)          \n\t" "punpckhdq %%mm1, %%mm1         \n\t" "movd      %%mm1, (%1, %2)      \n\t" "movd      %%mm6, (%1, %2, 2)   \n\t" "punpckhdq %%mm6, %%mm6         \n\t" "movd      %%mm6, (%1, %3)      \n\t" :: "r" ( src ) , "r" ( src + 4 * stride ) , "r" ( ( x86_reg ) stride ) , "r" ( ( x86_reg ) ( 3 * stride ) ) ) ; } }##::##0##::##14016
qcrypto_tls_creds_x509_unload ( QCryptoTLSCredsX509 * creds ) { if ( creds -> data ) { gnutls_certificate_free_credentials ( creds -> data ) ; creds -> data = NULL ;##::##1##::##4503
static void read_storage_element1_info ( SCLPDevice * sclp , SCCB * sccb ) { ReadStorageElementInfo * storage_info = ( ReadStorageElementInfo * ) sccb ; sclpMemoryHotplugDev * mhd = get_sclp_memory_hotplug_dev ( ) ; assert ( mhd ) ; if ( ( mhd -> standby_mem_size >> mhd -> increment_size ) >= 0x10000 ) { sccb -> h . response_code = cpu_to_be16 ( SCLP_RC_SCCB_BOUNDARY_VIOLATION ) ; return ; } storage_info -> max_id = cpu_to_be16 ( mhd -> standby_mem_size ? 1 : 0 ) ; storage_info -> assigned = cpu_to_be16 ( mhd -> standby_mem_size >> mhd -> increment_size ) ; storage_info -> standby = cpu_to_be16 ( mhd -> standby_mem_size >> mhd -> increment_size ) ; sccb -> h . response_code = cpu_to_be16 ( SCLP_RC_STANDBY_READ_COMPLETION ) ; }##::##0##::##1526
void * qemu_blockalign ( BlockDriverState * bs , size_t size ) { return qemu_memalign ( bdrv_opt_mem_align ( bs ) , size ) ; }##::##0##::##5751
static void virtio_ccw_blk_realize ( VirtioCcwDevice * ccw_dev , Error * * errp ) { VirtIOBlkCcw * dev = VIRTIO_BLK_CCW ( ccw_dev ) ; DeviceState * vdev = DEVICE ( & dev -> vdev ) ; Error * err = NULL ; qdev_set_parent_bus ( vdev , BUS ( & ccw_dev -> bus ) ) ; object_property_set_bool ( OBJECT ( vdev ) , true , "realized" , & err ) ; if ( err ) { error_propagate ( errp , err ) ; } }##::##0##::##8737
static inline int mxf_read_utf16_string ( AVIOContext * pb , int size , char * * str , int be ) { int ret ; size_t buf_size ; if ( size < 0 ) { return AVERROR ( EINVAL ) ; } buf_size = size + size / 2 + 1 ; * str = av_malloc ( buf_size ) ; if ( ! * str ) { return AVERROR ( ENOMEM ) ; } if ( be ) { ret = avio_get_str16be ( pb , size , * str , buf_size ) ; } else { ret = avio_get_str16le ( pb , size , * str , buf_size ) ; } if ( ret < 0 ) { av_freep ( str ) ; return ret ; } return ret ; }##::##1##::##11785
static ssize_t local_readlink ( FsContext * fs_ctx , V9fsPath * fs_path , char * buf , size_t bufsz ) { ssize_t tsize = - 1 ; char * buffer ; char * path = fs_path -> data ; if ( ( fs_ctx -> export_flags & V9FS_SM_MAPPED ) || ( fs_ctx -> export_flags & V9FS_SM_MAPPED_FILE ) ) { int fd ; buffer = rpath ( fs_ctx , path ) ; fd = open ( buffer , O_RDONLY | O_NOFOLLOW ) ; g_free ( buffer ) ; if ( fd == - 1 ) { return - 1 ; } do { tsize = read ( fd , ( void * ) buf , bufsz ) ; } while ( tsize == - 1 && errno == EINTR ) ; close ( fd ) ; } else if ( ( fs_ctx -> export_flags & V9FS_SM_PASSTHROUGH ) || ( fs_ctx -> export_flags & V9FS_SM_NONE ) ) { buffer = rpath ( fs_ctx , path ) ; tsize = readlink ( buffer , buf , bufsz ) ; g_free ( buffer ) ; } return tsize ; }##::##1##::##10767
static int draw_glyphs ( DrawTextContext * s , AVFrame * frame , int width , int height , const uint8_t rgbcolor [ 4 ] , const uint8_t yuvcolor [ 4 ] , int x , int y ) { char * text = HAVE_LOCALTIME_R ? s -> expanded_text : s -> text ; uint32_t code = 0 ; int i ; uint8_t * p ; Glyph * glyph = NULL ; for ( i = 0 , p = text ; * p ; i ++ ) { Glyph dummy = { 0 } ; GET_UTF8 ( code , * p ++ , continue ; ) ; if ( code == '\n' || code == '\r' || code == '\t' ) { continue ; } dummy . code = code ; glyph = av_tree_find ( s -> glyphs , & dummy , ( void * ) glyph_cmp , NULL ) ; if ( glyph -> bitmap . pixel_mode != FT_PIXEL_MODE_MONO && glyph -> bitmap . pixel_mode != FT_PIXEL_MODE_GRAY ) { return AVERROR ( EINVAL ) ; } if ( s -> is_packed_rgb ) { draw_glyph_rgb ( frame , & glyph -> bitmap , s -> positions [ i ] . x + x , s -> positions [ i ] . y + y , width , height , s -> pixel_step [ 0 ] , rgbcolor , s -> rgba_map , s -> alpha ) ; } else { draw_glyph_yuv ( frame , & glyph -> bitmap , s -> positions [ i ] . x + x , s -> positions [ i ] . y + y , width , height , yuvcolor , s -> hsub , s -> vsub , s -> alpha ) ; } } return 0 ; }##::##0##::##4422
static void kvm_getput_reg ( __u64 * kvm_reg , target_ulong * qemu_reg , int set ) { if ( set ) { * kvm_reg = * qemu_reg ; } else { * qemu_reg = * kvm_reg ; } }##::##0##::##7041
static inline void RENAME ( rgb32to24 ) ( const uint8_t * src , uint8_t * dst , long src_size ) { uint8_t * dest = dst ; const uint8_t * s = src ; const uint8_t * end ; # ifdef HAVE_MMX const uint8_t * mm_end ; # endif end = s + src_size ; # ifdef HAVE_MMX __asm __volatile ( PREFETCH "	%0" :: "m" ( * s ) : "memory" ) ; mm_end = end - 31 ; while ( s < mm_end ) { __asm __volatile ( PREFETCH "	32%1\n\t" "movq	%1, %%mm0\n\t" "movq	8%1, %%mm1\n\t" "movq	16%1, %%mm4\n\t" "movq	24%1, %%mm5\n\t" "movq	%%mm0, %%mm2\n\t" "movq	%%mm1, %%mm3\n\t" "movq	%%mm4, %%mm6\n\t" "movq	%%mm5, %%mm7\n\t" "psrlq	$8, %%mm2\n\t" "psrlq	$8, %%mm3\n\t" "psrlq	$8, %%mm6\n\t" "psrlq	$8, %%mm7\n\t" "pand	%2, %%mm0\n\t" "pand	%2, %%mm1\n\t" "pand	%2, %%mm4\n\t" "pand	%2, %%mm5\n\t" "pand	%3, %%mm2\n\t" "pand	%3, %%mm3\n\t" "pand	%3, %%mm6\n\t" "pand	%3, %%mm7\n\t" "por	%%mm2, %%mm0\n\t" "por	%%mm3, %%mm1\n\t" "por	%%mm6, %%mm4\n\t" "por	%%mm7, %%mm5\n\t" "movq	%%mm1, %%mm2\n\t" "movq	%%mm4, %%mm3\n\t" "psllq	$48, %%mm2\n\t" "psllq	$32, %%mm3\n\t" "pand	%4, %%mm2\n\t" "pand	%5, %%mm3\n\t" "por	%%mm2, %%mm0\n\t" "psrlq	$16, %%mm1\n\t" "psrlq	$32, %%mm4\n\t" "psllq	$16, %%mm5\n\t" "por	%%mm3, %%mm1\n\t" "pand	%6, %%mm5\n\t" "por	%%mm5, %%mm4\n\t" MOVNTQ "	%%mm0, %0\n\t" MOVNTQ "	%%mm1, 8%0\n\t" MOVNTQ "	%%mm4, 16%0" : "=m" ( * dest ) : "m" ( * s ) , "m" ( mask24l ) , "m" ( mask24h ) , "m" ( mask24hh ) , "m" ( mask24hhh ) , "m" ( mask24hhhh ) : "memory" ) ; dest += 24 ; s += 32 ; } __asm __volatile ( SFENCE :: : "memory" ) ; __asm __volatile ( EMMS :: : "memory" ) ; # endif while ( s < end ) { # ifdef WORDS_BIGENDIAN s ++ ; dest [ 2 ] = * s ++ ; dest [ 1 ] = * s ++ ; dest [ 0 ] = * s ++ ; dest += 3 ; # else * dest ++ = * s ++ ; * dest ++ = * s ++ ; * dest ++ = * s ++ ; s ++ ; # endif } }##::##1##::##662
static int decode_nal_units ( H264Context * h , const uint8_t * buf , int buf_size , int parse_extradata ) { AVCodecContext * const avctx = h -> avctx ; H264SliceContext * sl ; int buf_index ; unsigned context_count ; int next_avc ; int nals_needed = 0 ; int nal_index ; int idr_cleared = 0 ; int ret = 0 ; h -> nal_unit_type = 0 ; if ( ! h -> slice_context_count ) { h -> slice_context_count = 1 ; } h -> max_contexts = h -> slice_context_count ; if ( ! ( avctx -> flags2 & AV_CODEC_FLAG2_CHUNKS ) ) { h -> current_slice = 0 ; if ( ! h -> first_field ) { h -> cur_pic_ptr = NULL ; } ff_h264_reset_sei ( h ) ; if ( h -> nal_length_size == 4 ) { if ( buf_size > 8 && AV_RB32 ( buf ) == 1 && AV_RB32 ( buf + 5 ) > ( unsigned ) buf_size ) { h -> is_avc = 0 ; } else if ( buf_size > 3 && AV_RB32 ( buf ) > 1 && AV_RB32 ( buf ) <= ( unsigned ) buf_size ) { h -> is_avc = 1 ; } if ( avctx -> active_thread_type & FF_THREAD_FRAME ) { nals_needed = get_last_needed_nal ( h , buf , buf_size ) ; } { buf_index = 0 ; context_count = 0 ; next_avc = h -> is_avc ? 0 : buf_size ; nal_index = 0 ; for ( ; ; ) { int consumed ; int dst_length ; int bit_length ; const uint8_t * ptr ; int nalsize = 0 ; int err ; if ( buf_index >= next_avc ) { nalsize = get_avc_nalsize ( h , buf , buf_size , & buf_index ) ; if ( nalsize < 0 ) { break ; } next_avc = buf_index + nalsize ; } else { buf_index = find_start_code ( buf , buf_size , buf_index , next_avc ) ; if ( buf_index >= buf_size ) { break ; } if ( buf_index >= next_avc ) { continue ; } sl = & h -> slice_ctx [ context_count ] ; ptr = ff_h264_decode_nal ( h , sl , buf + buf_index , & dst_length , & consumed , next_avc - buf_index ) ; if ( ! ptr || dst_length < 0 ) { ret = - 1 ; goto end ; bit_length = get_bit_length ( h , buf , ptr , dst_length , buf_index + consumed , next_avc ) ; if ( h -> avctx -> debug & FF_DEBUG_STARTCODE ) av_log ( h -> avctx , AV_LOG_DEBUG , "NAL %d/%d at %d/%d length %d\n" , h -> nal_unit_type , h -> nal_ref_idc , buf_index , buf_size , dst_length ) ; if ( h -> is_avc && ( nalsize != consumed ) && nalsize ) av_log ( h -> avctx , AV_LOG_DEBUG , "AVC: Consumed only %d bytes instead of %d\n" , consumed , nalsize ) ; buf_index += consumed ; nal_index ++ ; if ( avctx -> skip_frame >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 && h -> nal_unit_type != NAL_SEI ) { continue ; } again : if ( parse_extradata ) { switch ( h -> nal_unit_type ) { case NAL_IDR_SLICE : case NAL_SLICE : case NAL_DPA : case NAL_DPB : case NAL_DPC : av_log ( h -> avctx , AV_LOG_WARNING , "Ignoring NAL %d in global header/extradata\n" , h -> nal_unit_type ) ; case NAL_AUXILIARY_SLICE : h -> nal_unit_type = NAL_FF_IGNORE ; err = 0 ; switch ( h -> nal_unit_type ) { case NAL_IDR_SLICE : if ( ( ptr [ 0 ] & 0xFC ) == 0x98 ) { av_log ( h -> avctx , AV_LOG_ERROR , "Invalid inter IDR frame\n" ) ; h -> next_outputed_poc = INT_MIN ; ret = - 1 ; goto end ; if ( h -> nal_unit_type != NAL_IDR_SLICE ) { av_log ( h -> avctx , AV_LOG_ERROR , "Invalid mix of idr and non-idr slices\n" ) ; ret = - 1 ; goto end ; if ( ! idr_cleared ) { if ( h -> current_slice && ( avctx -> active_thread_type & FF_THREAD_SLICE ) ) { av_log ( h , AV_LOG_ERROR , "invalid mixed IDR / non IDR frames cannot be decoded in slice multithreading mode\n" ) ; ret = AVERROR_INVALIDDATA ; goto end ; idr ( h ) ; idr_cleared = 1 ; h -> has_recovery_point = 1 ; case NAL_SLICE : init_get_bits ( & sl -> gb , ptr , bit_length ) ; if ( nals_needed >= nal_index || ( ! ( avctx -> active_thread_type & FF_THREAD_FRAME ) && ! context_count ) ) { h -> au_pps_id = - 1 ; } if ( ( err = ff_h264_decode_slice_header ( h , sl ) ) ) { break ; } if ( h -> sei_recovery_frame_cnt >= 0 ) { if ( h -> frame_num != h -> sei_recovery_frame_cnt || sl -> slice_type_nos != AV_PICTURE_TYPE_I ) { h -> valid_recovery_point = 1 ; } if ( h -> recovery_frame < 0 || av_mod_uintp2 ( h -> recovery_frame - h -> frame_num , h -> sps . log2_max_frame_num ) > h -> sei_recovery_frame_cnt ) { h -> recovery_frame = av_mod_uintp2 ( h -> frame_num + h -> sei_recovery_frame_cnt , h -> sps . log2_max_frame_num ) ; if ( ! h -> valid_recovery_point ) { h -> recovery_frame = h -> frame_num ; } h -> cur_pic_ptr -> f -> key_frame |= ( h -> nal_unit_type == NAL_IDR_SLICE ) ; if ( h -> nal_unit_type == NAL_IDR_SLICE || h -> recovery_frame == h -> frame_num ) { h -> recovery_frame = - 1 ; h -> cur_pic_ptr -> recovered = 1 ; if ( h -> nal_unit_type == NAL_IDR_SLICE ) { h -> frame_recovered |= FRAME_RECOVERED_IDR ; } # if 1 h -> cur_pic_ptr -> recovered |= h -> frame_recovered ; # else h -> cur_pic_ptr -> recovered |= ! ! ( h -> frame_recovered & FRAME_RECOVERED_IDR ) ; # endif if ( h -> current_slice == 1 ) { if ( ! ( avctx -> flags2 & AV_CODEC_FLAG2_CHUNKS ) ) { decode_postinit ( h , nal_index >= nals_needed ) ; } if ( h -> avctx -> hwaccel && ( ret = h -> avctx -> hwaccel -> start_frame ( h -> avctx , buf , buf_size ) ) < 0 ) { goto end ; } # if FF_API_CAP_VDPAU if ( CONFIG_H264_VDPAU_DECODER && h -> avctx -> codec -> capabilities & AV_CODEC_CAP_HWACCEL_VDPAU ) { ff_vdpau_h264_picture_start ( h ) ; } # endif if ( sl -> redundant_pic_count == 0 ) { if ( avctx -> hwaccel ) { ret = avctx -> hwaccel -> decode_slice ( avctx , & buf [ buf_index - consumed ] , consumed ) ; if ( ret < 0 ) { goto end ; } # if FF_API_CAP_VDPAU } else if ( CONFIG_H264_VDPAU_DECODER && h -> avctx -> codec -> capabilities & AV_CODEC_CAP_HWACCEL_VDPAU ) { ff_vdpau_add_data_chunk ( h -> cur_pic_ptr -> f -> data [ 0 ] , start_code , sizeof ( start_code ) ) ; ff_vdpau_add_data_chunk ( h -> cur_pic_ptr -> f -> data [ 0 ] , & buf [ buf_index - consumed ] , consumed ) ; # endif context_count ++ ; break ; case NAL_DPA : case NAL_DPB : case NAL_DPC : avpriv_request_sample ( avctx , "data partitioning" ) ; break ; case NAL_SEI : init_get_bits ( & h -> gb , ptr , bit_length ) ; ret = ff_h264_decode_sei ( h ) ; if ( ret < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ) { goto end ; } break ; case NAL_SPS : init_get_bits ( & h -> gb , ptr , bit_length ) ; if ( ff_h264_decode_seq_parameter_set ( h , 0 ) >= 0 ) { break ; } if ( h -> is_avc ? nalsize : 1 ) { av_log ( h -> avctx , AV_LOG_DEBUG , "SPS decoding failure, trying again with the complete NAL\n" ) ; if ( h -> is_avc ) { av_assert0 ( next_avc - buf_index + consumed == nalsize ) ; } if ( ( next_avc - buf_index + consumed - 1 ) >= INT_MAX / 8 ) { break ; } init_get_bits ( & h -> gb , & buf [ buf_index + 1 - consumed ] , 8 * ( next_avc - buf_index + consumed - 1 ) ) ; if ( ff_h264_decode_seq_parameter_set ( h , 0 ) >= 0 ) { break ; } init_get_bits ( & h -> gb , ptr , bit_length ) ; ff_h264_decode_seq_parameter_set ( h , 1 ) ; break ; case NAL_PPS : init_get_bits ( & h -> gb , ptr , bit_length ) ; ret = ff_h264_decode_picture_parameter_set ( h , bit_length ) ; if ( ret < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ) { goto end ; } break ; case NAL_AUD : case NAL_END_SEQUENCE : case NAL_END_STREAM : case NAL_FILLER_DATA : case NAL_SPS_EXT : case NAL_AUXILIARY_SLICE : break ; case NAL_FF_IGNORE : break ; default : av_log ( avctx , AV_LOG_DEBUG , "Unknown NAL code: %d (%d bits)\n" , h -> nal_unit_type , bit_length ) ; if ( context_count == h -> max_contexts ) { ret = ff_h264_execute_decode_slices ( h , context_count ) ; if ( ret < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ) { goto end ; } context_count = 0 ; if ( err < 0 || err == SLICE_SKIPED ) { if ( err < 0 ) { av_log ( h -> avctx , AV_LOG_ERROR , "decode_slice_header error\n" ) ; } sl -> ref_count [ 0 ] = sl -> ref_count [ 1 ] = sl -> list_count = 0 ; } else if ( err == SLICE_SINGLETHREAD ) { if ( context_count > 1 ) { ret = ff_h264_execute_decode_slices ( h , context_count - 1 ) ; if ( ret < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ) { goto end ; } context_count = 0 ; sl = & h -> slice_ctx [ 0 ] ; goto again ; if ( context_count ) { ret = ff_h264_execute_decode_slices ( h , context_count ) ; if ( ret < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ) { goto end ; } ret = 0 ; end : if ( h -> cur_pic_ptr && ! h -> droppable ) { ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , h -> picture_structure == PICT_BOTTOM_FIELD ) ; return ( ret < 0 ) ? ret : buf_index ;##::##1##::##5717
static av_always_inline int even ( uint64_t layout ) { return ( ! layout || ( layout & ( layout - 1 ) ) ) ; }##::##1##::##6922
static int unpack_block_qpis ( Vp3DecodeContext * s , GetBitContext * gb ) { int qpi , i , j , bit , run_length , blocks_decoded , num_blocks_at_qpi ; int num_blocks = s -> coded_fragment_list_index ; for ( qpi = 0 ; qpi < s -> nqps - 1 && num_blocks > 0 ; qpi ++ ) { i = blocks_decoded = num_blocks_at_qpi = 0 ; bit = get_bits1 ( gb ) ; do { run_length = get_vlc2 ( gb , s -> superblock_run_length_vlc . table , 6 , 2 ) + 1 ; if ( run_length == 34 ) { run_length += get_bits ( gb , 12 ) ; } blocks_decoded += run_length ; if ( ! bit ) { num_blocks_at_qpi += run_length ; } for ( j = 0 ; j < run_length ; i ++ ) { if ( i > s -> coded_fragment_list_index ) { return - 1 ; } if ( s -> all_fragments [ s -> coded_fragment_list [ i ] ] . qpi == qpi ) { s -> all_fragments [ s -> coded_fragment_list [ i ] ] . qpi += bit ; j ++ ; } } if ( run_length == 4129 ) { bit = get_bits1 ( gb ) ; } else { bit ^= 1 ; } } while ( blocks_decoded < num_blocks ) ; num_blocks -= num_blocks_at_qpi ; } return 0 ; }##::##0##::##8088
void qemu_put_be16 ( QEMUFile * f , unsigned int v ) { qemu_put_byte ( f , v >> 8 ) ; qemu_put_byte ( f , v ) ; }##::##1##::##10677
static int event_thread ( void * arg ) { AVFormatContext * s = arg ; SDLContext * sdl = s -> priv_data ; int flags = SDL_BASE_FLAGS | ( sdl -> window_fullscreen ? SDL_FULLSCREEN : 0 ) ; AVStream * st = s -> streams [ 0 ] ; AVCodecContext * encctx = st -> codec ; if ( SDL_Init ( SDL_INIT_VIDEO ) != 0 ) { av_log ( s , AV_LOG_ERROR , "Unable to initialize SDL: %s\n" , SDL_GetError ( ) ) ; sdl -> init_ret = AVERROR ( EINVAL ) ; goto init_end ; } SDL_WM_SetCaption ( sdl -> window_title , sdl -> icon_title ) ; sdl -> surface = SDL_SetVideoMode ( sdl -> window_width , sdl -> window_height , 24 , flags ) ; if ( ! sdl -> surface ) { av_log ( sdl , AV_LOG_ERROR , "Unable to set video mode: %s\n" , SDL_GetError ( ) ) ; sdl -> init_ret = AVERROR ( EINVAL ) ; goto init_end ; } sdl -> overlay = SDL_CreateYUVOverlay ( encctx -> width , encctx -> height , sdl -> overlay_fmt , sdl -> surface ) ; if ( ! sdl -> overlay || sdl -> overlay -> pitches [ 0 ] < encctx -> width ) { av_log ( s , AV_LOG_ERROR , "SDL does not support an overlay with size of %dx%d pixels\n" , encctx -> width , encctx -> height ) ; sdl -> init_ret = AVERROR ( EINVAL ) ; goto init_end ; } sdl -> init_ret = 0 ; av_log ( s , AV_LOG_VERBOSE , "w:%d h:%d fmt:%s -> w:%d h:%d\n" , encctx -> width , encctx -> height , av_get_pix_fmt_name ( encctx -> pix_fmt ) , sdl -> overlay_rect . w , sdl -> overlay_rect . h ) ; init_end : SDL_LockMutex ( sdl -> mutex ) ; sdl -> inited = 1 ; SDL_UnlockMutex ( sdl -> mutex ) ; SDL_CondSignal ( sdl -> init_cond ) ; if ( sdl -> init_ret < 0 ) { return sdl -> init_ret ; } while ( ! sdl -> quit ) { int ret ; SDL_Event event ; SDL_PumpEvents ( ) ; ret = SDL_PeepEvents ( & event , 1 , SDL_GETEVENT , SDL_ALLEVENTS ) ; if ( ret < 0 ) { av_log ( s , AV_LOG_ERROR , "Error when getting SDL event: %s\n" , SDL_GetError ( ) ) ; } if ( ret <= 0 ) { continue ; } switch ( event . type ) { case SDL_KEYDOWN : switch ( event . key . keysym . sym ) { case SDLK_ESCAPE : case SDLK_q : sdl -> quit = 1 ; break ; } break ; case SDL_QUIT : sdl -> quit = 1 ; break ; case SDL_VIDEORESIZE : sdl -> window_width = event . resize . w ; sdl -> window_height = event . resize . h ; SDL_LockMutex ( sdl -> mutex ) ; sdl -> surface = SDL_SetVideoMode ( sdl -> window_width , sdl -> window_height , 24 , SDL_BASE_FLAGS ) ; if ( ! sdl -> surface ) { av_log ( s , AV_LOG_ERROR , "Failed to set SDL video mode: %s\n" , SDL_GetError ( ) ) ; sdl -> quit = 1 ; } else { compute_overlay_rect ( s ) ; } SDL_UnlockMutex ( sdl -> mutex ) ; break ; default : break ; } } return 0 ; }##::##0##::##9371
QOSState * qtest_vboot ( QOSOps * ops , const char * cmdline_fmt , va_list ap ) { char * cmdline ; struct QOSState * qs = g_malloc ( sizeof ( QOSState ) ) ; cmdline = g_strdup_vprintf ( cmdline_fmt , ap ) ; qs -> qts = qtest_start ( cmdline ) ; qs -> ops = ops ; qtest_irq_intercept_in ( global_qtest , "ioapic" ) ; if ( ops && ops -> init_allocator ) { qs -> alloc = ops -> init_allocator ( ALLOC_NO_FLAGS ) ; } g_free ( cmdline ) ; return qs ; }##::##0##::##13823
static void tm_put ( QEMUFile * f , struct tm * tm ) { qemu_put_be16 ( f , tm -> tm_sec ) ; qemu_put_be16 ( f , tm -> tm_min ) ; qemu_put_be16 ( f , tm -> tm_hour ) ; qemu_put_be16 ( f , tm -> tm_mday ) ; qemu_put_be16 ( f , tm -> tm_min ) ; qemu_put_be16 ( f , tm -> tm_year ) ; }##::##0##::##14750
sPAPRTCETable * spapr_tce_new_table ( DeviceState * owner , uint32_t liobn ) { sPAPRTCETable * tcet ; char tmp [ 32 ] ; if ( spapr_tce_find_by_liobn ( liobn ) ) { error_report ( "Attempted to create TCE table with duplicate" " LIOBN 0x%x" , liobn ) ; return NULL ; } tcet = SPAPR_TCE_TABLE ( object_new ( TYPE_SPAPR_TCE_TABLE ) ) ; tcet -> liobn = liobn ; snprintf ( tmp , sizeof ( tmp ) , "tce-table-%x" , liobn ) ; object_property_add_child ( OBJECT ( owner ) , tmp , OBJECT ( tcet ) , NULL ) ; object_property_set_bool ( OBJECT ( tcet ) , true , "realized" , NULL ) ; return tcet ; }##::##0##::##1466
int ff_lpc_calc_coefs ( DSPContext * s , const int32_t * samples , int blocksize , int min_order , int max_order , int precision , int32_t coefs [ ] [ MAX_LPC_ORDER ] , int * shift , int use_lpc , int omethod , int max_shift , int zero_shift ) { double autoc [ MAX_LPC_ORDER + 1 ] ; double ref [ MAX_LPC_ORDER ] ; double lpc [ MAX_LPC_ORDER ] [ MAX_LPC_ORDER ] ; int i , j , pass ; int opt_order ; assert ( max_order >= MIN_LPC_ORDER && max_order <= MAX_LPC_ORDER ) ; if ( use_lpc == 1 ) { s -> flac_compute_autocorr ( samples , blocksize , max_order , autoc ) ; compute_lpc_coefs ( autoc , max_order , & lpc [ 0 ] [ 0 ] , MAX_LPC_ORDER , 0 , 1 ) ; for ( i = 0 ; i < max_order ; i ++ ) { ref [ i ] = fabs ( lpc [ i ] [ i ] ) ; } } else { LLSModel m [ 2 ] ; double var [ MAX_LPC_ORDER + 1 ] , weight ; for ( pass = 0 ; pass < use_lpc - 1 ; pass ++ ) { av_init_lls ( & m [ pass & 1 ] , max_order ) ; weight = 0 ; for ( i = max_order ; i < blocksize ; i ++ ) { for ( j = 0 ; j <= max_order ; j ++ ) { var [ j ] = samples [ i - j ] ; } if ( pass ) { double eval , inv , rinv ; eval = av_evaluate_lls ( & m [ ( pass - 1 ) & 1 ] , var + 1 , max_order - 1 ) ; eval = ( 512 >> pass ) + fabs ( eval - var [ 0 ] ) ; inv = 1 / eval ; rinv = sqrt ( inv ) ; for ( j = 0 ; j <= max_order ; j ++ ) { var [ j ] *= rinv ; } weight += inv ; } else { weight ++ ; } av_update_lls ( & m [ pass & 1 ] , var , 1.0 ) ; } av_solve_lls ( & m [ pass & 1 ] , 0.001 , 0 ) ; } for ( i = 0 ; i < max_order ; i ++ ) { for ( j = 0 ; j < max_order ; j ++ ) { lpc [ i ] [ j ] = - m [ ( pass - 1 ) & 1 ] . coeff [ i ] [ j ] ; } ref [ i ] = sqrt ( m [ ( pass - 1 ) & 1 ] . variance [ i ] / weight ) * ( blocksize - max_order ) / 4000 ; } for ( i = max_order - 1 ; i > 0 ; i -- ) { ref [ i ] = ref [ i - 1 ] - ref [ i ] ; } } opt_order = max_order ; if ( omethod == ORDER_METHOD_EST ) { opt_order = estimate_best_order ( ref , min_order , max_order ) ; i = opt_order - 1 ; quantize_lpc_coefs ( lpc [ i ] , i + 1 , precision , coefs [ i ] , & shift [ i ] , max_shift , zero_shift ) ; } else { for ( i = min_order - 1 ; i < max_order ; i ++ ) { quantize_lpc_coefs ( lpc [ i ] , i + 1 , precision , coefs [ i ] , & shift [ i ] , max_shift , zero_shift ) ; } } return opt_order ; }##::##0##::##11494
static ssize_t qsb_grow ( QEMUSizedBuffer * qsb , size_t new_size ) { size_t needed_chunks , i ; if ( qsb -> size < new_size ) { struct iovec * new_iov ; size_t size_diff = new_size - qsb -> size ; size_t chunk_size = ( size_diff > QSB_MAX_CHUNK_SIZE ) ? QSB_MAX_CHUNK_SIZE : QSB_CHUNK_SIZE ; needed_chunks = DIV_ROUND_UP ( size_diff , chunk_size ) ; new_iov = g_try_new ( struct iovec , qsb -> n_iov + needed_chunks ) ; if ( new_iov == NULL ) { return - ENOMEM ; } for ( i = qsb -> n_iov ; i < qsb -> n_iov + needed_chunks ; i ++ ) { new_iov [ i ] . iov_base = g_try_malloc0 ( chunk_size ) ; new_iov [ i ] . iov_len = chunk_size ; if ( ! new_iov [ i ] . iov_base ) { size_t j ; for ( j = qsb -> n_iov ; j < i ; j ++ ) { g_free ( new_iov [ j ] . iov_base ) ; } g_free ( new_iov ) ; return - ENOMEM ; } } for ( i = 0 ; i < qsb -> n_iov ; i ++ ) { new_iov [ i ] = qsb -> iov [ i ] ; } qsb -> n_iov += needed_chunks ; g_free ( qsb -> iov ) ; qsb -> iov = new_iov ; qsb -> size += ( needed_chunks * chunk_size ) ; } return qsb -> size ; }##::##1##::##2554
static uint64_t htonll ( uint64_t v ) { union { uint32_t lv [ 2 ] ; uint64_t llv ; } u ; u . lv [ 0 ] = htonl ( v >> 32 ) ; u . lv [ 1 ] = htonl ( v & 0xFFFFFFFFULL ) ; return u . llv ; }##::##1##::##4539
static void handle_input ( VirtIODevice * vdev , VirtQueue * vq ) { VirtIORNG * vrng = DO_UPCAST ( VirtIORNG , vdev , vdev ) ; size_t size ; size = pop_an_elem ( vrng ) ; if ( size ) { rng_backend_request_entropy ( vrng -> rng , size , chr_read , vrng ) ; } }##::##0##::##5320
static void fw_cfg_data_mem_write ( void * opaque , hwaddr addr , uint64_t value , unsigned size ) { fw_cfg_write ( opaque , ( uint8_t ) value ) ; }##::##0##::##7726
static int nsv_parse_NSVf_header ( AVFormatContext * s ) { NSVContext * nsv = s -> priv_data ; AVIOContext * pb = s -> pb ; unsigned int av_unused file_size ; unsigned int size ; int64_t duration ; int strings_size ; int table_entries ; int table_entries_used ; av_dlog ( s , "%s()\n" , __FUNCTION__ ) ; nsv -> state = NSV_UNSYNC ; size = avio_rl32 ( pb ) ; if ( size < 28 ) { return - 1 ; } nsv -> NSVf_end = size ; file_size = ( uint32_t ) avio_rl32 ( pb ) ; av_dlog ( s , "NSV NSVf chunk_size %u\n" , size ) ; av_dlog ( s , "NSV NSVf file_size %u\n" , file_size ) ; nsv -> duration = duration = avio_rl32 ( pb ) ; av_dlog ( s , "NSV NSVf duration %" PRId64 " ms\n" , duration ) ; strings_size = avio_rl32 ( pb ) ; table_entries = avio_rl32 ( pb ) ; table_entries_used = avio_rl32 ( pb ) ; av_dlog ( s , "NSV NSVf info-strings size: %d, table entries: %d, bis %d\n" , strings_size , table_entries , table_entries_used ) ; if ( pb -> eof_reached ) { return - 1 ; } av_dlog ( s , "NSV got header; filepos %" PRId64 "\n" , avio_tell ( pb ) ) ; if ( strings_size > 0 ) { char * strings ; char * p , * endp ; char * token , * value ; char quote ; p = strings = av_mallocz ( strings_size + 1 ) ; endp = strings + strings_size ; avio_read ( pb , strings , strings_size ) ; while ( p < endp ) { while ( * p == ' ' ) { p ++ ; } if ( p >= endp - 2 ) { break ; } token = p ; p = strchr ( p , '=' ) ; if ( ! p || p >= endp - 2 ) { break ; } * p ++ = '\0' ; quote = * p ++ ; value = p ; p = strchr ( p , quote ) ; if ( ! p || p >= endp ) { break ; } * p ++ = '\0' ; av_dlog ( s , "NSV NSVf INFO: %s='%s'\n" , token , value ) ; av_dict_set ( & s -> metadata , token , value , 0 ) ; } av_free ( strings ) ; } if ( pb -> eof_reached ) { return - 1 ; } av_dlog ( s , "NSV got infos; filepos %" PRId64 "\n" , avio_tell ( pb ) ) ; if ( table_entries_used > 0 ) { int i ; nsv -> index_entries = table_entries_used ; if ( ( unsigned ) table_entries_used >= UINT_MAX / sizeof ( uint32_t ) ) { return - 1 ; } nsv -> nsvs_file_offset = av_malloc ( ( unsigned ) table_entries_used * sizeof ( uint32_t ) ) ; for ( i = 0 ; i < table_entries_used ; i ++ ) { nsv -> nsvs_file_offset [ i ] = avio_rl32 ( pb ) + size ; } if ( table_entries > table_entries_used && avio_rl32 ( pb ) == MKTAG ( 'T' , 'O' , 'C' , '2' ) ) { nsv -> nsvs_timestamps = av_malloc ( ( unsigned ) table_entries_used * sizeof ( uint32_t ) ) ; for ( i = 0 ; i < table_entries_used ; i ++ ) { nsv -> nsvs_timestamps [ i ] = avio_rl32 ( pb ) ; } } } av_dlog ( s , "NSV got index; filepos %" PRId64 "\n" , avio_tell ( pb ) ) ; # ifdef DEBUG_DUMP_INDEX # define V ( v ) ( ( v < 0x20 || v > 127 ) ? '.' : v ) av_dlog ( s , "NSV %d INDEX ENTRIES:\n" , table_entries ) ; av_dlog ( s , "NSV [dataoffset][fileoffset]\n" , table_entries ) ; for ( i = 0 ; i < table_entries ; i ++ ) { unsigned char b [ 8 ] ; avio_seek ( pb , size + nsv -> nsvs_file_offset [ i ] , SEEK_SET ) ; avio_read ( pb , b , 8 ) ; av_dlog ( s , "NSV [0x%08lx][0x%08lx]: %02x %02x %02x %02x %02x %02x %02x %02x" "%c%c%c%c%c%c%c%c\n" , nsv -> nsvs_file_offset [ i ] , size + nsv -> nsvs_file_offset [ i ] , b [ 0 ] , b [ 1 ] , b [ 2 ] , b [ 3 ] , b [ 4 ] , b [ 5 ] , b [ 6 ] , b [ 7 ] , V ( b [ 0 ] ) , V ( b [ 1 ] ) , V ( b [ 2 ] ) , V ( b [ 3 ] ) , V ( b [ 4 ] ) , V ( b [ 5 ] ) , V ( b [ 6 ] ) , V ( b [ 7 ] ) ) ; } # undef V # endif avio_seek ( pb , nsv -> base_offset + size , SEEK_SET ) ; if ( pb -> eof_reached ) { return - 1 ; } nsv -> state = NSV_HAS_READ_NSVF ; return 0 ; }##::##1##::##9506
static int bdrv_open_common ( BlockDriverState * bs , BlockDriverState * file , QDict * options , int flags , BlockDriver * drv ) { int ret , open_flags ; const char * filename ; assert ( drv != NULL ) ; assert ( bs -> file == NULL ) ; assert ( options != NULL && bs -> options != options ) ; trace_bdrv_open_common ( bs , filename , flags , drv -> format_name ) ; if ( use_bdrv_whitelist && ! bdrv_is_whitelisted ( drv ) ) { return - ENOTSUP ; } if ( file != NULL && drv -> bdrv_file_open ) { bdrv_swap ( file , bs ) ; return 0 ; } bs -> open_flags = flags ; bs -> buffer_alignment = 512 ; assert ( bs -> copy_on_read == 0 ) ; if ( ( flags & BDRV_O_RDWR ) && ( flags & BDRV_O_COPY_ON_READ ) ) { bdrv_enable_copy_on_read ( bs ) ; } if ( file != NULL ) { filename = file -> filename ; } else { filename = qdict_get_try_str ( options , "filename" ) ; } if ( filename != NULL ) { pstrcpy ( bs -> filename , sizeof ( bs -> filename ) , filename ) ; } else { bs -> filename [ 0 ] = '\0' ; } bs -> drv = drv ; bs -> opaque = g_malloc0 ( drv -> instance_size ) ; bs -> enable_write_cache = ! ! ( flags & BDRV_O_CACHE_WB ) ; open_flags = bdrv_open_flags ( bs , flags ) ; bs -> read_only = ! ( open_flags & BDRV_O_RDWR ) ; if ( drv -> bdrv_file_open ) { assert ( file == NULL ) ; assert ( drv -> bdrv_parse_filename || filename != NULL ) ; ret = drv -> bdrv_file_open ( bs , options , open_flags ) ; } else { if ( file == NULL ) { qerror_report ( ERROR_CLASS_GENERIC_ERROR , "Can't use '%s' as a " "block driver for the protocol level" , drv -> format_name ) ; ret = - EINVAL ; goto free_and_fail ; } assert ( file != NULL ) ; bs -> file = file ; ret = drv -> bdrv_open ( bs , options , open_flags ) ; } if ( ret < 0 ) { goto free_and_fail ; } ret = refresh_total_sectors ( bs , bs -> total_sectors ) ; if ( ret < 0 ) { goto free_and_fail ; } # ifndef _WIN32 if ( bs -> is_temporary ) { assert ( filename != NULL ) ; unlink ( filename ) ; } # endif return 0 ; free_and_fail : bs -> file = NULL ; g_free ( bs -> opaque ) ; bs -> opaque = NULL ; bs -> drv = NULL ; return ret ; }##::##1##::##7357
static void escaped_string ( void ) { int i ; struct { const char * encoded ; const char * decoded ; int skip ; } test_cases [ ] = { { "\"\\b\"" , "\b" } , { "\"\\f\"" , "\f" } , { "\"\\n\"" , "\n" } , { "\"\\r\"" , "\r" } , { "\"\\t\"" , "\t" } , { "\"/\"" , "/" } , { "\"\\/\"" , "/" , . skip = 1 } , { "\"\\\\\"" , "\\" } , { "\"\\\"\"" , "\"" } , { "\"hello world \\\"embedded string\\\"\"" , "hello world \"embedded string\"" } , { "\"hello world\\nwith new line\"" , "hello world\nwith new line" } , { "\"single byte utf-8 \\u0020\"" , "single byte utf-8  " , . skip = 1 } , { "\"double byte utf-8 \\u00A2\"" , "double byte utf-8 \xc2\xa2" } , { "\"triple byte utf-8 \\u20AC\"" , "triple byte utf-8 \xe2\x82\xac" } , { "'\\b'" , "\b" , . skip = 1 } , { "'\\f'" , "\f" , . skip = 1 } , { "'\\n'" , "\n" , . skip = 1 } , { "'\\r'" , "\r" , . skip = 1 } , { "'\\t'" , "\t" , . skip = 1 } , { "'\\/'" , "/" , . skip = 1 } , { "'\\\\'" , "\\" , . skip = 1 } , { } } ; for ( i = 0 ; test_cases [ i ] . encoded ; i ++ ) { QObject * obj ; QString * str ; obj = qobject_from_json ( test_cases [ i ] . encoded , NULL ) ; str = qobject_to_qstring ( obj ) ; g_assert ( str ) ; g_assert_cmpstr ( qstring_get_str ( str ) , == , test_cases [ i ] . decoded ) ; if ( test_cases [ i ] . skip == 0 ) { str = qobject_to_json ( obj ) ; g_assert_cmpstr ( qstring_get_str ( str ) , == , test_cases [ i ] . encoded ) ; qobject_decref ( obj ) ; } QDECREF ( str ) ; } }##::##1##::##6591
static av_cold int atrac3_decode_init ( AVCodecContext * avctx ) { int i , ret ; int version , delay , samples_per_frame , frame_factor ; const uint8_t * edata_ptr = avctx -> extradata ; ATRAC3Context * q = avctx -> priv_data ; if ( avctx -> channels <= 0 || avctx -> channels > 2 ) { av_log ( avctx , AV_LOG_ERROR , "Channel configuration error!\n" ) ; } if ( avctx -> extradata_size == 14 ) { av_log ( avctx , AV_LOG_DEBUG , "[0-1] %d\n" , bytestream_get_le16 ( & edata_ptr ) ) ; edata_ptr += 4 ; q -> coding_mode = bytestream_get_le16 ( & edata_ptr ) ; av_log ( avctx , AV_LOG_DEBUG , "[8-9] %d\n" , bytestream_get_le16 ( & edata_ptr ) ) ; frame_factor = bytestream_get_le16 ( & edata_ptr ) ; av_log ( avctx , AV_LOG_DEBUG , "[12-13] %d\n" , bytestream_get_le16 ( & edata_ptr ) ) ; samples_per_frame = SAMPLES_PER_FRAME * avctx -> channels ; version = 4 ; delay = 0x88E ; q -> coding_mode = q -> coding_mode ? JOINT_STEREO : STEREO ; q -> scrambled_stream = 0 ; if ( avctx -> block_align != 96 * avctx -> channels * frame_factor && avctx -> block_align != 152 * avctx -> channels * frame_factor && avctx -> block_align != 192 * avctx -> channels * frame_factor ) { av_log ( avctx , AV_LOG_ERROR , "Unknown frame/channel/frame_factor " "configuration %d/%d/%d\n" , avctx -> block_align , avctx -> channels , frame_factor ) ; return AVERROR_INVALIDDATA ; } } else if ( avctx -> extradata_size == 10 ) { version = bytestream_get_be32 ( & edata_ptr ) ; samples_per_frame = bytestream_get_be16 ( & edata_ptr ) ; delay = bytestream_get_be16 ( & edata_ptr ) ; q -> coding_mode = bytestream_get_be16 ( & edata_ptr ) ; q -> scrambled_stream = 1 ; } else { av_log ( NULL , AV_LOG_ERROR , "Unknown extradata size %d.\n" , avctx -> extradata_size ) ; } if ( version != 4 ) { av_log ( avctx , AV_LOG_ERROR , "Version %d != 4.\n" , version ) ; return AVERROR_INVALIDDATA ; } if ( samples_per_frame != SAMPLES_PER_FRAME && samples_per_frame != SAMPLES_PER_FRAME * 2 ) { av_log ( avctx , AV_LOG_ERROR , "Unknown amount of samples per frame %d.\n" , samples_per_frame ) ; return AVERROR_INVALIDDATA ; } if ( delay != 0x88E ) { av_log ( avctx , AV_LOG_ERROR , "Unknown amount of delay %x != 0x88E.\n" , delay ) ; return AVERROR_INVALIDDATA ; } if ( q -> coding_mode == STEREO ) { av_log ( avctx , AV_LOG_DEBUG , "Normal stereo detected.\n" ) ; } else if ( q -> coding_mode == JOINT_STEREO ) { av_log ( avctx , AV_LOG_DEBUG , "Joint stereo detected.\n" ) ; } else { av_log ( avctx , AV_LOG_ERROR , "Unknown channel coding mode %x!\n" , q -> coding_mode ) ; return AVERROR_INVALIDDATA ; } if ( avctx -> block_align >= UINT_MAX / 2 ) q -> decoded_bytes_buffer = av_mallocz ( FFALIGN ( avctx -> block_align , 4 ) + FF_INPUT_BUFFER_PADDING_SIZE ) ; if ( q -> decoded_bytes_buffer == NULL ) { return AVERROR ( ENOMEM ) ; } avctx -> sample_fmt = AV_SAMPLE_FMT_FLTP ; if ( ( ret = ff_mdct_init ( & q -> mdct_ctx , 9 , 1 , 1.0 / 32768 ) ) < 0 ) { av_log ( avctx , AV_LOG_ERROR , "Error initializing MDCT\n" ) ; av_freep ( & q -> decoded_bytes_buffer ) ; return ret ; } q -> weighting_delay [ 0 ] = 0 ; q -> weighting_delay [ 1 ] = 7 ; q -> weighting_delay [ 2 ] = 0 ; q -> weighting_delay [ 3 ] = 7 ; q -> weighting_delay [ 4 ] = 0 ; q -> weighting_delay [ 5 ] = 7 ; for ( i = 0 ; i < 4 ; i ++ ) { q -> matrix_coeff_index_prev [ i ] = 3 ; q -> matrix_coeff_index_now [ i ] = 3 ; q -> matrix_coeff_index_next [ i ] = 3 ; } avpriv_float_dsp_init ( & q -> fdsp , avctx -> flags & CODEC_FLAG_BITEXACT ) ; ff_fmt_convert_init ( & q -> fmt_conv , avctx ) ; q -> units = av_mallocz ( sizeof ( * q -> units ) * avctx -> channels ) ; if ( ! q -> units ) { atrac3_decode_close ( avctx ) ; return AVERROR ( ENOMEM ) ; } avcodec_get_frame_defaults ( & q -> frame ) ; avctx -> coded_frame = & q -> frame ; return 0 ; }##::##1##::##4979
build_header ( GArray * linker , GArray * table_data , AcpiTableHeader * h , const char * sig , int len , uint8_t rev , const char * oem_id , const char * oem_table_id ) { memcpy ( & h -> signature , sig , 4 ) ; h -> length = cpu_to_le32 ( len ) ; h -> revision = rev ; if ( oem_id ) { strncpy ( ( char * ) h -> oem_id , oem_id , sizeof h -> oem_id ) ; } else { memcpy ( h -> oem_id , ACPI_BUILD_APPNAME6 , 6 ) ; } if ( oem_table_id ) { strncpy ( ( char * ) h -> oem_table_id , oem_table_id , sizeof ( h -> oem_table_id ) ) ; } else { memcpy ( h -> oem_table_id , ACPI_BUILD_APPNAME4 , 4 ) ; memcpy ( h -> oem_table_id + 4 , sig , 4 ) ; } h -> oem_revision = cpu_to_le32 ( 1 ) ; memcpy ( h -> asl_compiler_id , ACPI_BUILD_APPNAME4 , 4 ) ; h -> asl_compiler_revision = cpu_to_le32 ( 1 ) ; h -> checksum = 0 ; bios_linker_loader_add_checksum ( linker , ACPI_BUILD_TABLE_FILE , table_data , h , len , & h -> checksum ) ; }##::##0##::##3480
static void gen_farith ( DisasContext * ctx , uint32_t op1 , int ft , int fs , int fd , int cc ) { const char * opn = "farith" ; const char * condnames [ ] = { "c.f" , "c.un" , "c.eq" , "c.ueq" , "c.olt" , "c.ult" , "c.ole" , "c.ule" , "c.sf" , "c.ngle" , "c.seq" , "c.ngl" , "c.lt" , "c.nge" , "c.le" , "c.ngt" , } ; const char * condnames_abs [ ] = { "cabs.f" , "cabs.un" , "cabs.eq" , "cabs.ueq" , "cabs.olt" , "cabs.ult" , "cabs.ole" , "cabs.ule" , "cabs.sf" , "cabs.ngle" , "cabs.seq" , "cabs.ngl" , "cabs.lt" , "cabs.nge" , "cabs.le" , "cabs.ngt" , } ; enum { BINOP , CMPOP , OTHEROP } optype = OTHEROP ; uint32_t func = ctx -> opcode & 0x3f ; switch ( ctx -> opcode & FOP ( 0x3f , 0x1f ) ) { case FOP ( 0 , 16 ) : { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; TCGv_i32 fp1 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_load_fpr32 ( fp1 , ft ) ; gen_helper_float_add_s ( fp0 , fp0 , fp1 ) ; tcg_temp_free_i32 ( fp1 ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; } opn = "add.s" ; optype = BINOP ; break ; case FOP ( 1 , 16 ) : { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; TCGv_i32 fp1 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_load_fpr32 ( fp1 , ft ) ; gen_helper_float_sub_s ( fp0 , fp0 , fp1 ) ; tcg_temp_free_i32 ( fp1 ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; } opn = "sub.s" ; optype = BINOP ; break ; case FOP ( 2 , 16 ) : { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; TCGv_i32 fp1 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_load_fpr32 ( fp1 , ft ) ; gen_helper_float_mul_s ( fp0 , fp0 , fp1 ) ; tcg_temp_free_i32 ( fp1 ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; } opn = "mul.s" ; optype = BINOP ; break ; case FOP ( 3 , 16 ) : { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; TCGv_i32 fp1 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_load_fpr32 ( fp1 , ft ) ; gen_helper_float_div_s ( fp0 , fp0 , fp1 ) ; tcg_temp_free_i32 ( fp1 ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; } opn = "div.s" ; optype = BINOP ; break ; case FOP ( 4 , 16 ) : { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_helper_float_sqrt_s ( fp0 , fp0 ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; } opn = "sqrt.s" ; break ; case FOP ( 5 , 16 ) : { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_helper_float_abs_s ( fp0 , fp0 ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; } opn = "abs.s" ; break ; case FOP ( 6 , 16 ) : { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; } opn = "mov.s" ; break ; case FOP ( 7 , 16 ) : { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_helper_float_chs_s ( fp0 , fp0 ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; } opn = "neg.s" ; break ; case FOP ( 8 , 16 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i32 fp32 = tcg_temp_new_i32 ( ) ; TCGv_i64 fp64 = tcg_temp_new_i64 ( ) ; gen_load_fpr32 ( fp32 , fs ) ; gen_helper_float_roundl_s ( fp64 , fp32 ) ; tcg_temp_free_i32 ( fp32 ) ; gen_store_fpr64 ( ctx , fp64 , fd ) ; tcg_temp_free_i64 ( fp64 ) ; } opn = "round.l.s" ; break ; case FOP ( 9 , 16 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i32 fp32 = tcg_temp_new_i32 ( ) ; TCGv_i64 fp64 = tcg_temp_new_i64 ( ) ; gen_load_fpr32 ( fp32 , fs ) ; gen_helper_float_truncl_s ( fp64 , fp32 ) ; tcg_temp_free_i32 ( fp32 ) ; gen_store_fpr64 ( ctx , fp64 , fd ) ; tcg_temp_free_i64 ( fp64 ) ; } opn = "trunc.l.s" ; break ; case FOP ( 10 , 16 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i32 fp32 = tcg_temp_new_i32 ( ) ; TCGv_i64 fp64 = tcg_temp_new_i64 ( ) ; gen_load_fpr32 ( fp32 , fs ) ; gen_helper_float_ceill_s ( fp64 , fp32 ) ; tcg_temp_free_i32 ( fp32 ) ; gen_store_fpr64 ( ctx , fp64 , fd ) ; tcg_temp_free_i64 ( fp64 ) ; } opn = "ceil.l.s" ; break ; case FOP ( 11 , 16 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i32 fp32 = tcg_temp_new_i32 ( ) ; TCGv_i64 fp64 = tcg_temp_new_i64 ( ) ; gen_load_fpr32 ( fp32 , fs ) ; gen_helper_float_floorl_s ( fp64 , fp32 ) ; tcg_temp_free_i32 ( fp32 ) ; gen_store_fpr64 ( ctx , fp64 , fd ) ; tcg_temp_free_i64 ( fp64 ) ; } opn = "floor.l.s" ; break ; case FOP ( 12 , 16 ) : { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_helper_float_roundw_s ( fp0 , fp0 ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; } opn = "round.w.s" ; break ; case FOP ( 13 , 16 ) : { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_helper_float_truncw_s ( fp0 , fp0 ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; } opn = "trunc.w.s" ; break ; case FOP ( 14 , 16 ) : { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_helper_float_ceilw_s ( fp0 , fp0 ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; } opn = "ceil.w.s" ; break ; case FOP ( 15 , 16 ) : { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_helper_float_floorw_s ( fp0 , fp0 ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; } opn = "floor.w.s" ; break ; case FOP ( 17 , 16 ) : gen_movcf_s ( fs , fd , ( ft >> 2 ) & 0x7 , ft & 0x1 ) ; opn = "movcf.s" ; break ; case FOP ( 18 , 16 ) : { int l1 = gen_new_label ( ) ; TCGv_i32 fp0 ; if ( ft != 0 ) { tcg_gen_brcondi_tl ( TCG_COND_NE , cpu_gpr [ ft ] , 0 , l1 ) ; } fp0 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; gen_set_label ( l1 ) ; } opn = "movz.s" ; break ; case FOP ( 19 , 16 ) : { int l1 = gen_new_label ( ) ; TCGv_i32 fp0 ; if ( ft != 0 ) { tcg_gen_brcondi_tl ( TCG_COND_EQ , cpu_gpr [ ft ] , 0 , l1 ) ; fp0 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; gen_set_label ( l1 ) ; } } opn = "movn.s" ; break ; case FOP ( 21 , 16 ) : check_cop1x ( ctx ) ; { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_helper_float_recip_s ( fp0 , fp0 ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; } opn = "recip.s" ; break ; case FOP ( 22 , 16 ) : check_cop1x ( ctx ) ; { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_helper_float_rsqrt_s ( fp0 , fp0 ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; } opn = "rsqrt.s" ; break ; case FOP ( 28 , 16 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; TCGv_i32 fp1 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_load_fpr32 ( fp1 , fd ) ; gen_helper_float_recip2_s ( fp0 , fp0 , fp1 ) ; tcg_temp_free_i32 ( fp1 ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; } opn = "recip2.s" ; break ; case FOP ( 29 , 16 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_helper_float_recip1_s ( fp0 , fp0 ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; } opn = "recip1.s" ; break ; case FOP ( 30 , 16 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_helper_float_rsqrt1_s ( fp0 , fp0 ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; } opn = "rsqrt1.s" ; break ; case FOP ( 31 , 16 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; TCGv_i32 fp1 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_load_fpr32 ( fp1 , ft ) ; gen_helper_float_rsqrt2_s ( fp0 , fp0 , fp1 ) ; tcg_temp_free_i32 ( fp1 ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; } opn = "rsqrt2.s" ; break ; case FOP ( 33 , 16 ) : check_cp1_registers ( ctx , fd ) ; { TCGv_i32 fp32 = tcg_temp_new_i32 ( ) ; TCGv_i64 fp64 = tcg_temp_new_i64 ( ) ; gen_load_fpr32 ( fp32 , fs ) ; gen_helper_float_cvtd_s ( fp64 , fp32 ) ; tcg_temp_free_i32 ( fp32 ) ; gen_store_fpr64 ( ctx , fp64 , fd ) ; tcg_temp_free_i64 ( fp64 ) ; } opn = "cvt.d.s" ; break ; case FOP ( 36 , 16 ) : { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_helper_float_cvtw_s ( fp0 , fp0 ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; } opn = "cvt.w.s" ; break ; case FOP ( 37 , 16 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i32 fp32 = tcg_temp_new_i32 ( ) ; TCGv_i64 fp64 = tcg_temp_new_i64 ( ) ; gen_load_fpr32 ( fp32 , fs ) ; gen_helper_float_cvtl_s ( fp64 , fp32 ) ; tcg_temp_free_i32 ( fp32 ) ; gen_store_fpr64 ( ctx , fp64 , fd ) ; tcg_temp_free_i64 ( fp64 ) ; } opn = "cvt.l.s" ; break ; case FOP ( 38 , 16 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp64 = tcg_temp_new_i64 ( ) ; TCGv_i32 fp32_0 = tcg_temp_new_i32 ( ) ; TCGv_i32 fp32_1 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp32_0 , fs ) ; gen_load_fpr32 ( fp32_1 , ft ) ; tcg_gen_concat_i32_i64 ( fp64 , fp32_0 , fp32_1 ) ; tcg_temp_free_i32 ( fp32_1 ) ; tcg_temp_free_i32 ( fp32_0 ) ; gen_store_fpr64 ( ctx , fp64 , fd ) ; tcg_temp_free_i64 ( fp64 ) ; } opn = "cvt.ps.s" ; break ; case FOP ( 48 , 16 ) : case FOP ( 49 , 16 ) : case FOP ( 50 , 16 ) : case FOP ( 51 , 16 ) : case FOP ( 52 , 16 ) : case FOP ( 53 , 16 ) : case FOP ( 54 , 16 ) : case FOP ( 55 , 16 ) : case FOP ( 56 , 16 ) : case FOP ( 57 , 16 ) : case FOP ( 58 , 16 ) : case FOP ( 59 , 16 ) : case FOP ( 60 , 16 ) : case FOP ( 61 , 16 ) : case FOP ( 62 , 16 ) : case FOP ( 63 , 16 ) : { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; TCGv_i32 fp1 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_load_fpr32 ( fp1 , ft ) ; if ( ctx -> opcode & ( 1 << 6 ) ) { check_cop1x ( ctx ) ; gen_cmpabs_s ( func - 48 , fp0 , fp1 , cc ) ; opn = condnames_abs [ func - 48 ] ; } else { gen_cmp_s ( func - 48 , fp0 , fp1 , cc ) ; opn = condnames [ func - 48 ] ; } tcg_temp_free_i32 ( fp0 ) ; tcg_temp_free_i32 ( fp1 ) ; } break ; case FOP ( 0 , 17 ) : check_cp1_registers ( ctx , fs | ft | fd ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; TCGv_i64 fp1 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_load_fpr64 ( ctx , fp1 , ft ) ; gen_helper_float_add_d ( fp0 , fp0 , fp1 ) ; tcg_temp_free_i64 ( fp1 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "add.d" ; optype = BINOP ; break ; case FOP ( 1 , 17 ) : check_cp1_registers ( ctx , fs | ft | fd ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; TCGv_i64 fp1 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_load_fpr64 ( ctx , fp1 , ft ) ; gen_helper_float_sub_d ( fp0 , fp0 , fp1 ) ; tcg_temp_free_i64 ( fp1 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "sub.d" ; optype = BINOP ; break ; case FOP ( 2 , 17 ) : check_cp1_registers ( ctx , fs | ft | fd ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; TCGv_i64 fp1 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_load_fpr64 ( ctx , fp1 , ft ) ; gen_helper_float_mul_d ( fp0 , fp0 , fp1 ) ; tcg_temp_free_i64 ( fp1 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "mul.d" ; optype = BINOP ; break ; case FOP ( 3 , 17 ) : check_cp1_registers ( ctx , fs | ft | fd ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; TCGv_i64 fp1 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_load_fpr64 ( ctx , fp1 , ft ) ; gen_helper_float_div_d ( fp0 , fp0 , fp1 ) ; tcg_temp_free_i64 ( fp1 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "div.d" ; optype = BINOP ; break ; case FOP ( 4 , 17 ) : check_cp1_registers ( ctx , fs | fd ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_helper_float_sqrt_d ( fp0 , fp0 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "sqrt.d" ; break ; case FOP ( 5 , 17 ) : check_cp1_registers ( ctx , fs | fd ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_helper_float_abs_d ( fp0 , fp0 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "abs.d" ; break ; case FOP ( 6 , 17 ) : check_cp1_registers ( ctx , fs | fd ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "mov.d" ; break ; case FOP ( 7 , 17 ) : check_cp1_registers ( ctx , fs | fd ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_helper_float_chs_d ( fp0 , fp0 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "neg.d" ; break ; case FOP ( 8 , 17 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_helper_float_roundl_d ( fp0 , fp0 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "round.l.d" ; break ; case FOP ( 9 , 17 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_helper_float_truncl_d ( fp0 , fp0 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "trunc.l.d" ; break ; case FOP ( 10 , 17 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_helper_float_ceill_d ( fp0 , fp0 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "ceil.l.d" ; break ; case FOP ( 11 , 17 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_helper_float_floorl_d ( fp0 , fp0 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "floor.l.d" ; break ; case FOP ( 12 , 17 ) : check_cp1_registers ( ctx , fs ) ; { TCGv_i32 fp32 = tcg_temp_new_i32 ( ) ; TCGv_i64 fp64 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp64 , fs ) ; gen_helper_float_roundw_d ( fp32 , fp64 ) ; tcg_temp_free_i64 ( fp64 ) ; gen_store_fpr32 ( fp32 , fd ) ; tcg_temp_free_i32 ( fp32 ) ; } opn = "round.w.d" ; break ; case FOP ( 13 , 17 ) : check_cp1_registers ( ctx , fs ) ; { TCGv_i32 fp32 = tcg_temp_new_i32 ( ) ; TCGv_i64 fp64 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp64 , fs ) ; gen_helper_float_truncw_d ( fp32 , fp64 ) ; tcg_temp_free_i64 ( fp64 ) ; gen_store_fpr32 ( fp32 , fd ) ; tcg_temp_free_i32 ( fp32 ) ; } opn = "trunc.w.d" ; break ; case FOP ( 14 , 17 ) : check_cp1_registers ( ctx , fs ) ; { TCGv_i32 fp32 = tcg_temp_new_i32 ( ) ; TCGv_i64 fp64 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp64 , fs ) ; gen_helper_float_ceilw_d ( fp32 , fp64 ) ; tcg_temp_free_i64 ( fp64 ) ; gen_store_fpr32 ( fp32 , fd ) ; tcg_temp_free_i32 ( fp32 ) ; } opn = "ceil.w.d" ; break ; case FOP ( 15 , 17 ) : check_cp1_registers ( ctx , fs ) ; { TCGv_i32 fp32 = tcg_temp_new_i32 ( ) ; TCGv_i64 fp64 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp64 , fs ) ; gen_helper_float_floorw_d ( fp32 , fp64 ) ; tcg_temp_free_i64 ( fp64 ) ; gen_store_fpr32 ( fp32 , fd ) ; tcg_temp_free_i32 ( fp32 ) ; } opn = "floor.w.d" ; break ; case FOP ( 17 , 17 ) : gen_movcf_d ( ctx , fs , fd , ( ft >> 2 ) & 0x7 , ft & 0x1 ) ; opn = "movcf.d" ; break ; case FOP ( 18 , 17 ) : { int l1 = gen_new_label ( ) ; TCGv_i64 fp0 ; if ( ft != 0 ) { tcg_gen_brcondi_tl ( TCG_COND_NE , cpu_gpr [ ft ] , 0 , l1 ) ; } fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; gen_set_label ( l1 ) ; } opn = "movz.d" ; break ; case FOP ( 19 , 17 ) : { int l1 = gen_new_label ( ) ; TCGv_i64 fp0 ; if ( ft != 0 ) { tcg_gen_brcondi_tl ( TCG_COND_EQ , cpu_gpr [ ft ] , 0 , l1 ) ; fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; gen_set_label ( l1 ) ; } } opn = "movn.d" ; break ; case FOP ( 21 , 17 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_helper_float_recip_d ( fp0 , fp0 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "recip.d" ; break ; case FOP ( 22 , 17 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_helper_float_rsqrt_d ( fp0 , fp0 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "rsqrt.d" ; break ; case FOP ( 28 , 17 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; TCGv_i64 fp1 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_load_fpr64 ( ctx , fp1 , ft ) ; gen_helper_float_recip2_d ( fp0 , fp0 , fp1 ) ; tcg_temp_free_i64 ( fp1 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "recip2.d" ; break ; case FOP ( 29 , 17 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_helper_float_recip1_d ( fp0 , fp0 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "recip1.d" ; break ; case FOP ( 30 , 17 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_helper_float_rsqrt1_d ( fp0 , fp0 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "rsqrt1.d" ; break ; case FOP ( 31 , 17 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; TCGv_i64 fp1 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_load_fpr64 ( ctx , fp1 , ft ) ; gen_helper_float_rsqrt2_d ( fp0 , fp0 , fp1 ) ; tcg_temp_free_i64 ( fp1 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "rsqrt2.d" ; break ; case FOP ( 48 , 17 ) : case FOP ( 49 , 17 ) : case FOP ( 50 , 17 ) : case FOP ( 51 , 17 ) : case FOP ( 52 , 17 ) : case FOP ( 53 , 17 ) : case FOP ( 54 , 17 ) : case FOP ( 55 , 17 ) : case FOP ( 56 , 17 ) : case FOP ( 57 , 17 ) : case FOP ( 58 , 17 ) : case FOP ( 59 , 17 ) : case FOP ( 60 , 17 ) : case FOP ( 61 , 17 ) : case FOP ( 62 , 17 ) : case FOP ( 63 , 17 ) : { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; TCGv_i64 fp1 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_load_fpr64 ( ctx , fp1 , ft ) ; if ( ctx -> opcode & ( 1 << 6 ) ) { check_cop1x ( ctx ) ; check_cp1_registers ( ctx , fs | ft ) ; gen_cmpabs_d ( func - 48 , fp0 , fp1 , cc ) ; opn = condnames_abs [ func - 48 ] ; } else { check_cp1_registers ( ctx , fs | ft ) ; gen_cmp_d ( func - 48 , fp0 , fp1 , cc ) ; opn = condnames [ func - 48 ] ; } tcg_temp_free_i64 ( fp0 ) ; tcg_temp_free_i64 ( fp1 ) ; } break ; case FOP ( 32 , 17 ) : check_cp1_registers ( ctx , fs ) ; { TCGv_i32 fp32 = tcg_temp_new_i32 ( ) ; TCGv_i64 fp64 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp64 , fs ) ; gen_helper_float_cvts_d ( fp32 , fp64 ) ; tcg_temp_free_i64 ( fp64 ) ; gen_store_fpr32 ( fp32 , fd ) ; tcg_temp_free_i32 ( fp32 ) ; } opn = "cvt.s.d" ; break ; case FOP ( 36 , 17 ) : check_cp1_registers ( ctx , fs ) ; { TCGv_i32 fp32 = tcg_temp_new_i32 ( ) ; TCGv_i64 fp64 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp64 , fs ) ; gen_helper_float_cvtw_d ( fp32 , fp64 ) ; tcg_temp_free_i64 ( fp64 ) ; gen_store_fpr32 ( fp32 , fd ) ; tcg_temp_free_i32 ( fp32 ) ; } opn = "cvt.w.d" ; break ; case FOP ( 37 , 17 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_helper_float_cvtl_d ( fp0 , fp0 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "cvt.l.d" ; break ; case FOP ( 32 , 20 ) : { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_helper_float_cvts_w ( fp0 , fp0 ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; } opn = "cvt.s.w" ; break ; case FOP ( 33 , 20 ) : check_cp1_registers ( ctx , fd ) ; { TCGv_i32 fp32 = tcg_temp_new_i32 ( ) ; TCGv_i64 fp64 = tcg_temp_new_i64 ( ) ; gen_load_fpr32 ( fp32 , fs ) ; gen_helper_float_cvtd_w ( fp64 , fp32 ) ; tcg_temp_free_i32 ( fp32 ) ; gen_store_fpr64 ( ctx , fp64 , fd ) ; tcg_temp_free_i64 ( fp64 ) ; } opn = "cvt.d.w" ; break ; case FOP ( 32 , 21 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i32 fp32 = tcg_temp_new_i32 ( ) ; TCGv_i64 fp64 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp64 , fs ) ; gen_helper_float_cvts_l ( fp32 , fp64 ) ; tcg_temp_free_i64 ( fp64 ) ; gen_store_fpr32 ( fp32 , fd ) ; tcg_temp_free_i32 ( fp32 ) ; } opn = "cvt.s.l" ; break ; case FOP ( 33 , 21 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_helper_float_cvtd_l ( fp0 , fp0 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "cvt.d.l" ; break ; case FOP ( 38 , 20 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_helper_float_cvtps_pw ( fp0 , fp0 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "cvt.ps.pw" ; break ; case FOP ( 0 , 22 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; TCGv_i64 fp1 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_load_fpr64 ( ctx , fp1 , ft ) ; gen_helper_float_add_ps ( fp0 , fp0 , fp1 ) ; tcg_temp_free_i64 ( fp1 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "add.ps" ; break ; case FOP ( 1 , 22 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; TCGv_i64 fp1 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_load_fpr64 ( ctx , fp1 , ft ) ; gen_helper_float_sub_ps ( fp0 , fp0 , fp1 ) ; tcg_temp_free_i64 ( fp1 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "sub.ps" ; break ; case FOP ( 2 , 22 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; TCGv_i64 fp1 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_load_fpr64 ( ctx , fp1 , ft ) ; gen_helper_float_mul_ps ( fp0 , fp0 , fp1 ) ; tcg_temp_free_i64 ( fp1 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "mul.ps" ; break ; case FOP ( 5 , 22 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_helper_float_abs_ps ( fp0 , fp0 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "abs.ps" ; break ; case FOP ( 6 , 22 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "mov.ps" ; break ; case FOP ( 7 , 22 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_helper_float_chs_ps ( fp0 , fp0 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "neg.ps" ; break ; case FOP ( 17 , 22 ) : check_cp1_64bitmode ( ctx ) ; gen_movcf_ps ( fs , fd , ( ft >> 2 ) & 0x7 , ft & 0x1 ) ; opn = "movcf.ps" ; break ; case FOP ( 18 , 22 ) : check_cp1_64bitmode ( ctx ) ; { int l1 = gen_new_label ( ) ; TCGv_i64 fp0 ; if ( ft != 0 ) { tcg_gen_brcondi_tl ( TCG_COND_NE , cpu_gpr [ ft ] , 0 , l1 ) ; } fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; gen_set_label ( l1 ) ; } opn = "movz.ps" ; break ; case FOP ( 19 , 22 ) : check_cp1_64bitmode ( ctx ) ; { int l1 = gen_new_label ( ) ; TCGv_i64 fp0 ; if ( ft != 0 ) { tcg_gen_brcondi_tl ( TCG_COND_EQ , cpu_gpr [ ft ] , 0 , l1 ) ; fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; gen_set_label ( l1 ) ; } } opn = "movn.ps" ; break ; case FOP ( 24 , 22 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; TCGv_i64 fp1 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , ft ) ; gen_load_fpr64 ( ctx , fp1 , fs ) ; gen_helper_float_addr_ps ( fp0 , fp0 , fp1 ) ; tcg_temp_free_i64 ( fp1 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "addr.ps" ; break ; case FOP ( 26 , 22 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; TCGv_i64 fp1 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , ft ) ; gen_load_fpr64 ( ctx , fp1 , fs ) ; gen_helper_float_mulr_ps ( fp0 , fp0 , fp1 ) ; tcg_temp_free_i64 ( fp1 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "mulr.ps" ; break ; case FOP ( 28 , 22 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; TCGv_i64 fp1 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_load_fpr64 ( ctx , fp1 , fd ) ; gen_helper_float_recip2_ps ( fp0 , fp0 , fp1 ) ; tcg_temp_free_i64 ( fp1 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "recip2.ps" ; break ; case FOP ( 29 , 22 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_helper_float_recip1_ps ( fp0 , fp0 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "recip1.ps" ; break ; case FOP ( 30 , 22 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_helper_float_rsqrt1_ps ( fp0 , fp0 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "rsqrt1.ps" ; break ; case FOP ( 31 , 22 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; TCGv_i64 fp1 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_load_fpr64 ( ctx , fp1 , ft ) ; gen_helper_float_rsqrt2_ps ( fp0 , fp0 , fp1 ) ; tcg_temp_free_i64 ( fp1 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "rsqrt2.ps" ; break ; case FOP ( 32 , 22 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; gen_load_fpr32h ( fp0 , fs ) ; gen_helper_float_cvts_pu ( fp0 , fp0 ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; } opn = "cvt.s.pu" ; break ; case FOP ( 36 , 22 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_helper_float_cvtpw_ps ( fp0 , fp0 ) ; gen_store_fpr64 ( ctx , fp0 , fd ) ; tcg_temp_free_i64 ( fp0 ) ; } opn = "cvt.pw.ps" ; break ; case FOP ( 40 , 22 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_helper_float_cvts_pl ( fp0 , fp0 ) ; gen_store_fpr32 ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; } opn = "cvt.s.pl" ; break ; case FOP ( 44 , 22 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; TCGv_i32 fp1 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_load_fpr32 ( fp1 , ft ) ; gen_store_fpr32h ( fp0 , fd ) ; gen_store_fpr32 ( fp1 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; tcg_temp_free_i32 ( fp1 ) ; } opn = "pll.ps" ; break ; case FOP ( 45 , 22 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; TCGv_i32 fp1 = tcg_temp_new_i32 ( ) ; gen_load_fpr32 ( fp0 , fs ) ; gen_load_fpr32h ( fp1 , ft ) ; gen_store_fpr32 ( fp1 , fd ) ; gen_store_fpr32h ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; tcg_temp_free_i32 ( fp1 ) ; } opn = "plu.ps" ; break ; case FOP ( 46 , 22 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; TCGv_i32 fp1 = tcg_temp_new_i32 ( ) ; gen_load_fpr32h ( fp0 , fs ) ; gen_load_fpr32 ( fp1 , ft ) ; gen_store_fpr32 ( fp1 , fd ) ; gen_store_fpr32h ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; tcg_temp_free_i32 ( fp1 ) ; } opn = "pul.ps" ; break ; case FOP ( 47 , 22 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i32 fp0 = tcg_temp_new_i32 ( ) ; TCGv_i32 fp1 = tcg_temp_new_i32 ( ) ; gen_load_fpr32h ( fp0 , fs ) ; gen_load_fpr32h ( fp1 , ft ) ; gen_store_fpr32 ( fp1 , fd ) ; gen_store_fpr32h ( fp0 , fd ) ; tcg_temp_free_i32 ( fp0 ) ; tcg_temp_free_i32 ( fp1 ) ; } opn = "puu.ps" ; break ; case FOP ( 48 , 22 ) : case FOP ( 49 , 22 ) : case FOP ( 50 , 22 ) : case FOP ( 51 , 22 ) : case FOP ( 52 , 22 ) : case FOP ( 53 , 22 ) : case FOP ( 54 , 22 ) : case FOP ( 55 , 22 ) : case FOP ( 56 , 22 ) : case FOP ( 57 , 22 ) : case FOP ( 58 , 22 ) : case FOP ( 59 , 22 ) : case FOP ( 60 , 22 ) : case FOP ( 61 , 22 ) : case FOP ( 62 , 22 ) : case FOP ( 63 , 22 ) : check_cp1_64bitmode ( ctx ) ; { TCGv_i64 fp0 = tcg_temp_new_i64 ( ) ; TCGv_i64 fp1 = tcg_temp_new_i64 ( ) ; gen_load_fpr64 ( ctx , fp0 , fs ) ; gen_load_fpr64 ( ctx , fp1 , ft ) ; if ( ctx -> opcode & ( 1 << 6 ) ) { gen_cmpabs_ps ( func - 48 , fp0 , fp1 , cc ) ; opn = condnames_abs [ func - 48 ] ; } else { gen_cmp_ps ( func - 48 , fp0 , fp1 , cc ) ; opn = condnames [ func - 48 ] ; } tcg_temp_free_i64 ( fp0 ) ; tcg_temp_free_i64 ( fp1 ) ; } break ; default : MIPS_INVAL ( opn ) ; generate_exception ( ctx , EXCP_RI ) ; return ; } switch ( optype ) { case BINOP : MIPS_DEBUG ( "%s %s, %s, %s" , opn , fregnames [ fd ] , fregnames [ fs ] , fregnames [ ft ] ) ; break ; case CMPOP : MIPS_DEBUG ( "%s %s,%s" , opn , fregnames [ fs ] , fregnames [ ft ] ) ; break ; default : MIPS_DEBUG ( "%s %s,%s" , opn , fregnames [ fd ] , fregnames [ fs ] ) ; break ; } }##::##0##::##4277
static av_cold int libopenjpeg_encode_close ( AVCodecContext * avctx ) { LibOpenJPEGContext * ctx = avctx -> priv_data ; opj_destroy_compress ( ctx -> compress ) ; opj_image_destroy ( ctx -> image ) ; av_freep ( & avctx -> coded_frame ) ; return 0 ; }##::##0##::##9049
static USBDevice * usb_try_create_simple ( USBBus * bus , const char * name , Error * * errp ) { Error * err = NULL ; USBDevice * dev ; dev = USB_DEVICE ( qdev_try_create ( & bus -> qbus , name ) ) ; if ( ! dev ) { error_setg ( errp , "Failed to create USB device '%s'" , name ) ; return NULL ; } object_property_set_bool ( OBJECT ( dev ) , true , "realized" , & err ) ; if ( err ) { error_propagate ( errp , err ) ; error_prepend ( errp , "Failed to initialize USB device '%s': " , name ) ; object_unparent ( OBJECT ( dev ) ) ; return NULL ; } return dev ; }##::##1##::##1591
static int libkvazaar_encode ( AVCodecContext * avctx , AVPacket * avpkt , const AVFrame * frame , int * got_packet_ptr ) { int retval = 0 ; kvz_picture * img_in = NULL ; kvz_data_chunk * data_out = NULL ; uint32_t len_out = 0 ; kvz_frame_info frame_info ; LibkvazaarContext * ctx = avctx -> priv_data ; * got_packet_ptr = 0 ; if ( frame ) { int i = 0 ; av_assert0 ( frame -> width == ctx -> config -> width ) ; av_assert0 ( frame -> height == ctx -> config -> height ) ; av_assert0 ( frame -> format == avctx -> pix_fmt ) ; img_in = ctx -> api -> picture_alloc ( frame -> width , frame -> height ) ; if ( ! img_in ) { av_log ( avctx , AV_LOG_ERROR , "Failed to allocate picture.\n" ) ; retval = AVERROR ( ENOMEM ) ; goto done ; } for ( i = 0 ; i < 3 ; ++ i ) { uint8_t * dst = img_in -> data [ i ] ; uint8_t * src = frame -> data [ i ] ; int width = ( i == 0 ) ? frame -> width : ( frame -> width / 2 ) ; int height = ( i == 0 ) ? frame -> height : ( frame -> height / 2 ) ; int y = 0 ; for ( y = 0 ; y < height ; ++ y ) { memcpy ( dst , src , width ) ; src += frame -> linesize [ i ] ; dst += width ; } } } if ( ! ctx -> api -> encoder_encode ( ctx -> encoder , img_in , & data_out , & len_out , NULL , NULL , & frame_info ) ) { av_log ( avctx , AV_LOG_ERROR , "Failed to encode frame.\n" ) ; retval = AVERROR_EXTERNAL ; goto done ; } if ( data_out ) { kvz_data_chunk * chunk = NULL ; uint64_t written = 0 ; retval = ff_alloc_packet ( avpkt , len_out ) ; if ( retval < 0 ) { av_log ( avctx , AV_LOG_ERROR , "Failed to allocate output packet.\n" ) ; goto done ; } for ( chunk = data_out ; chunk != NULL ; chunk = chunk -> next ) { av_assert0 ( written + chunk -> len <= len_out ) ; memcpy ( avpkt -> data + written , chunk -> data , chunk -> len ) ; written += chunk -> len ; } * got_packet_ptr = 1 ; ctx -> api -> chunk_free ( data_out ) ; data_out = NULL ; avpkt -> flags = 0 ; if ( frame_info . nal_unit_type >= KVZ_NAL_BLA_W_LP && frame_info . nal_unit_type <= KVZ_NAL_RSV_IRAP_VCL23 ) { avpkt -> flags |= AV_PKT_FLAG_KEY ; } } done : ctx -> api -> picture_free ( img_in ) ; ctx -> api -> chunk_free ( data_out ) ; return retval ; }##::##1##::##4947
static bool gscb_needed ( void * opaque ) { return kvm_s390_get_gs ( ) ; }##::##1##::##514
static int config_props ( AVFilterLink * outlink ) { AVFilterContext * ctx = outlink -> src ; AVFilterLink * inlink = outlink -> src -> inputs [ 0 ] ; ScaleContext * scale = ctx -> priv ; int64_t w , h ; double var_values [ VARS_NB ] , res ; char * expr ; int ret ; var_values [ VAR_PI ] = M_PI ; var_values [ VAR_PHI ] = M_PHI ; var_values [ VAR_E ] = M_E ; var_values [ VAR_IN_W ] = var_values [ VAR_IW ] = inlink -> w ; var_values [ VAR_IN_H ] = var_values [ VAR_IH ] = inlink -> h ; var_values [ VAR_OUT_W ] = var_values [ VAR_OW ] = NAN ; var_values [ VAR_OUT_H ] = var_values [ VAR_OH ] = NAN ; var_values [ VAR_DAR ] = var_values [ VAR_A ] = ( float ) inlink -> w / inlink -> h ; var_values [ VAR_SAR ] = inlink -> sample_aspect_ratio . num ? ( float ) inlink -> sample_aspect_ratio . num / inlink -> sample_aspect_ratio . den : 1 ; var_values [ VAR_HSUB ] = 1 << av_pix_fmt_descriptors [ inlink -> format ] . log2_chroma_w ; var_values [ VAR_VSUB ] = 1 << av_pix_fmt_descriptors [ inlink -> format ] . log2_chroma_h ; av_expr_parse_and_eval ( & res , ( expr = scale -> w_expr ) , var_names , var_values , NULL , NULL , NULL , NULL , NULL , 0 , ctx ) ; scale -> w = var_values [ VAR_OUT_W ] = var_values [ VAR_OW ] = res ; if ( ( ret = av_expr_parse_and_eval ( & res , ( expr = scale -> h_expr ) , var_names , var_values , NULL , NULL , NULL , NULL , NULL , 0 , ctx ) ) < 0 ) { goto fail ; } scale -> h = var_values [ VAR_OUT_H ] = var_values [ VAR_OH ] = res ; if ( ( ret = av_expr_parse_and_eval ( & res , ( expr = scale -> w_expr ) , var_names , var_values , NULL , NULL , NULL , NULL , NULL , 0 , ctx ) ) < 0 ) { goto fail ; } scale -> w = res ; w = scale -> w ; h = scale -> h ; if ( w < - 1 || h < - 1 ) { av_log ( ctx , AV_LOG_ERROR , "Size values less than -1 are not acceptable.\n" ) ; return AVERROR ( EINVAL ) ; } if ( w == - 1 && h == - 1 ) { scale -> w = scale -> h = 0 ; } if ( ! ( w = scale -> w ) ) { w = inlink -> w ; } if ( ! ( h = scale -> h ) ) { h = inlink -> h ; } if ( w == - 1 ) { w = av_rescale ( h , inlink -> w , inlink -> h ) ; } if ( h == - 1 ) { h = av_rescale ( w , inlink -> h , inlink -> w ) ; } if ( w > INT_MAX || h > INT_MAX || ( h * inlink -> w ) > INT_MAX || ( w * inlink -> h ) > INT_MAX ) { av_log ( ctx , AV_LOG_ERROR , "Rescaled value for width or height is too big.\n" ) ; } outlink -> w = w ; outlink -> h = h ; av_log ( ctx , AV_LOG_INFO , "w:%d h:%d fmt:%s -> w:%d h:%d fmt:%s flags:0x%0x\n" , inlink -> w , inlink -> h , av_pix_fmt_descriptors [ inlink -> format ] . name , outlink -> w , outlink -> h , av_pix_fmt_descriptors [ outlink -> format ] . name , scale -> flags ) ; scale -> input_is_pal = av_pix_fmt_descriptors [ inlink -> format ] . flags & PIX_FMT_PAL ; if ( scale -> sws ) { sws_freeContext ( scale -> sws ) ; } scale -> sws = sws_getContext ( inlink -> w , inlink -> h , inlink -> format , outlink -> w , outlink -> h , outlink -> format , scale -> flags , NULL , NULL , NULL ) ; if ( ! scale -> sws ) { return AVERROR ( EINVAL ) ; } if ( inlink -> sample_aspect_ratio . num ) outlink -> sample_aspect_ratio = av_mul_q ( ( AVRational ) { outlink -> h * inlink -> w , outlink -> w * inlink -> h } , inlink -> sample_aspect_ratio ) ; else { outlink -> sample_aspect_ratio = inlink -> sample_aspect_ratio ; } return 0 ; fail : av_log ( NULL , AV_LOG_ERROR , "Error when evaluating the expression '%s'\n" , expr ) ; return ret ; }##::##1##::##5764
static void update_stream_timings ( AVFormatContext * ic ) { int64_t start_time , start_time1 , start_time_text , end_time , end_time1 ; int64_t duration , duration1 , filesize ; int i ; AVStream * st ; AVProgram * p ; start_time = INT64_MAX ; start_time_text = INT64_MAX ; end_time = INT64_MIN ; duration = INT64_MIN ; for ( i = 0 ; i < ic -> nb_streams ; i ++ ) { st = ic -> streams [ i ] ; if ( st -> start_time != AV_NOPTS_VALUE && st -> time_base . den ) { start_time1 = av_rescale_q ( st -> start_time , st -> time_base , AV_TIME_BASE_Q ) ; if ( st -> codec -> codec_type == AVMEDIA_TYPE_SUBTITLE || st -> codec -> codec_type == AVMEDIA_TYPE_DATA ) { if ( start_time1 < start_time_text ) { start_time_text = start_time1 ; } } else { start_time = FFMIN ( start_time , start_time1 ) ; } end_time1 = AV_NOPTS_VALUE ; if ( st -> duration != AV_NOPTS_VALUE ) { end_time1 = start_time1 + av_rescale_q ( st -> duration , st -> time_base , AV_TIME_BASE_Q ) ; end_time = FFMAX ( end_time , end_time1 ) ; } for ( p = NULL ; ( p = av_find_program_from_stream ( ic , p , i ) ) ; ) { if ( p -> start_time == AV_NOPTS_VALUE || p -> start_time > start_time1 ) { p -> start_time = start_time1 ; } if ( p -> end_time < end_time1 ) { p -> end_time = end_time1 ; } } } if ( st -> duration != AV_NOPTS_VALUE ) { duration1 = av_rescale_q ( st -> duration , st -> time_base , AV_TIME_BASE_Q ) ; duration = FFMAX ( duration , duration1 ) ; } } if ( start_time == INT64_MAX || ( start_time > start_time_text && start_time - start_time_text < AV_TIME_BASE ) ) { start_time = start_time_text ; } else if ( start_time > start_time_text ) { av_log ( ic , AV_LOG_VERBOSE , "Ignoring outlier non primary stream starttime %f\n" , start_time_text / ( float ) AV_TIME_BASE ) ; } if ( start_time != INT64_MAX ) { ic -> start_time = start_time ; if ( end_time != INT64_MIN ) { if ( ic -> nb_programs ) { for ( i = 0 ; i < ic -> nb_programs ; i ++ ) { p = ic -> programs [ i ] ; if ( p -> start_time != AV_NOPTS_VALUE && p -> end_time > p -> start_time ) { duration = FFMAX ( duration , p -> end_time - p -> start_time ) ; } } } else { duration = FFMAX ( duration , end_time - start_time ) ; } } } if ( duration != INT64_MIN && duration > 0 && ic -> duration == AV_NOPTS_VALUE ) { ic -> duration = duration ; } if ( ic -> pb && ( filesize = avio_size ( ic -> pb ) ) > 0 && ic -> duration != AV_NOPTS_VALUE ) { double bitrate = ( double ) filesize * 8.0 * AV_TIME_BASE / ( double ) ic -> duration ; if ( bitrate >= 0 && ( ! AV_HAVE_INCOMPATIBLE_LIBAV_ABI || bitrate <= INT_MAX ) ) { ic -> bit_rate = bitrate ; } } }##::##0##::##6187
static inline void decode_subblock ( DCTELEM * dst , int code , const int is_block2 , GetBitContext * gb , VLC * vlc , int q ) { int coeffs [ 4 ] ; coeffs [ 0 ] = modulo_three_table [ code ] [ 0 ] ; coeffs [ 1 ] = modulo_three_table [ code ] [ 1 ] ; coeffs [ 2 ] = modulo_three_table [ code ] [ 2 ] ; coeffs [ 3 ] = modulo_three_table [ code ] [ 3 ] ; decode_coeff ( dst , coeffs [ 0 ] , 3 , gb , vlc , q ) ; if ( is_block2 ) { decode_coeff ( dst + 8 , coeffs [ 1 ] , 2 , gb , vlc , q ) ; decode_coeff ( dst + 1 , coeffs [ 2 ] , 2 , gb , vlc , q ) ; } else { decode_coeff ( dst + 1 , coeffs [ 1 ] , 2 , gb , vlc , q ) ; decode_coeff ( dst + 8 , coeffs [ 2 ] , 2 , gb , vlc , q ) ; } decode_coeff ( dst + 9 , coeffs [ 3 ] , 2 , gb , vlc , q ) ; }##::##0##::##8843
static int ppc_hash32_get_physical_address ( CPUPPCState * env , struct mmu_ctx_hash32 * ctx , target_ulong eaddr , int rw , int access_type ) { bool real_mode = ( access_type == ACCESS_CODE && msr_ir == 0 ) || ( access_type != ACCESS_CODE && msr_dr == 0 ) ; if ( real_mode ) { ctx -> raddr = eaddr ; ctx -> prot = PAGE_READ | PAGE_EXEC | PAGE_WRITE ; return 0 ; } else { int ret = - 1 ; if ( env -> nb_BATs != 0 ) { ret = ppc_hash32_get_bat ( env , ctx , eaddr , rw , access_type ) ; } if ( ret < 0 ) { ret = get_segment32 ( env , ctx , eaddr , rw , access_type ) ; } return ret ; } }##::##0##::##7845
