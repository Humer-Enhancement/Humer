s##::##label##::##id
static void pc_numa_cpu ( const void * data ) { char * cli ; QDict * resp ; QList * cpus ; const QObject * e ; cli = make_cli ( data , "-cpu pentium -smp 8,sockets=2,cores=2,threads=2 " "-numa node,nodeid=0 -numa node,nodeid=1 " "-numa cpu,node-id=1,socket-id=0 " "-numa cpu,node-id=0,socket-id=1,core-id=0 " "-numa cpu,node-id=0,socket-id=1,core-id=1,thread-id=0 " "-numa cpu,node-id=1,socket-id=1,core-id=1,thread-id=1" ) ; qtest_start ( cli ) ; cpus = get_cpus ( & resp ) ; g_assert ( cpus ) ; while ( ( e = qlist_pop ( cpus ) ) ) { QDict * cpu , * props ; int64_t socket , core , thread , node ; cpu = qobject_to_qdict ( e ) ; g_assert ( qdict_haskey ( cpu , "props" ) ) ; props = qdict_get_qdict ( cpu , "props" ) ; g_assert ( qdict_haskey ( props , "node-id" ) ) ; node = qdict_get_int ( props , "node-id" ) ; g_assert ( qdict_haskey ( props , "socket-id" ) ) ; socket = qdict_get_int ( props , "socket-id" ) ; g_assert ( qdict_haskey ( props , "core-id" ) ) ; core = qdict_get_int ( props , "core-id" ) ; g_assert ( qdict_haskey ( props , "thread-id" ) ) ; thread = qdict_get_int ( props , "thread-id" ) ; if ( socket == 0 ) { g_assert_cmpint ( node , == , 1 ) ; } else if ( socket == 1 && core == 0 ) { g_assert_cmpint ( node , == , 0 ) ; } else if ( socket == 1 && core == 1 && thread == 0 ) { g_assert_cmpint ( node , == , 0 ) ; } else if ( socket == 1 && core == 1 && thread == 1 ) { g_assert_cmpint ( node , == , 1 ) ; } else { g_assert ( false ) ; } } QDECREF ( resp ) ; qtest_end ( ) ; g_free ( cli ) ; }##::##1##::##9580
static int usb_host_handle_control ( USBHostDevice * s , USBPacket * p ) { struct usbdevfs_urb * urb ; AsyncURB * aurb ; int ret , value , index ; value = le16_to_cpu ( s -> ctrl . req . wValue ) ; index = le16_to_cpu ( s -> ctrl . req . wIndex ) ; dprintf ( "husb: ctrl type 0x%x req 0x%x val 0x%x index %u len %u\n" , s -> ctrl . req . bRequestType , s -> ctrl . req . bRequest , value , index , s -> ctrl . len ) ; if ( s -> ctrl . req . bRequestType == 0 ) { switch ( s -> ctrl . req . bRequest ) { case USB_REQ_SET_ADDRESS : return usb_host_set_address ( s , value ) ; case USB_REQ_SET_CONFIGURATION : return usb_host_set_config ( s , value & 0xff ) ; } } if ( s -> ctrl . req . bRequestType == 1 && s -> ctrl . req . bRequest == USB_REQ_SET_INTERFACE ) { return usb_host_set_interface ( s , index , value ) ; } aurb = async_alloc ( ) ; aurb -> hdev = s ; aurb -> packet = p ; urb = & aurb -> urb ; urb -> type = USBDEVFS_URB_TYPE_CONTROL ; urb -> endpoint = p -> devep ; urb -> buffer = & s -> ctrl . req ; urb -> buffer_length = 8 + s -> ctrl . len ; urb -> usercontext = s ; ret = ioctl ( s -> fd , USBDEVFS_SUBMITURB , urb ) ; dprintf ( "husb: submit ctrl. len %u aurb %p\n" , urb -> buffer_length , aurb ) ; if ( ret < 0 ) { dprintf ( "husb: submit failed. errno %d\n" , errno ) ; async_free ( aurb ) ; switch ( errno ) { case ETIMEDOUT : return USB_RET_NAK ; case EPIPE : default : return USB_RET_STALL ; } } usb_defer_packet ( p , async_cancel , aurb ) ; return USB_RET_ASYNC ; }##::##1##::##8293
static int ram_save_init_globals ( void ) { int64_t ram_bitmap_pages ; dirty_rate_high_cnt = 0 ; bitmap_sync_count = 0 ; migration_bitmap_sync_init ( ) ; qemu_mutex_init ( & migration_bitmap_mutex ) ; if ( migrate_use_xbzrle ( ) ) { XBZRLE_cache_lock ( ) ; ZERO_TARGET_PAGE = g_malloc0 ( TARGET_PAGE_SIZE ) ; XBZRLE . cache = cache_init ( migrate_xbzrle_cache_size ( ) / TARGET_PAGE_SIZE , TARGET_PAGE_SIZE ) ; if ( ! XBZRLE . cache ) { XBZRLE_cache_unlock ( ) ; error_report ( "Error creating cache" ) ; return - 1 ; } XBZRLE_cache_unlock ( ) ; XBZRLE . encoded_buf = g_try_malloc0 ( TARGET_PAGE_SIZE ) ; if ( ! XBZRLE . encoded_buf ) { error_report ( "Error allocating encoded_buf" ) ; return - 1 ; } XBZRLE . current_buf = g_try_malloc ( TARGET_PAGE_SIZE ) ; if ( ! XBZRLE . current_buf ) { error_report ( "Error allocating current_buf" ) ; g_free ( XBZRLE . encoded_buf ) ; XBZRLE . encoded_buf = NULL ; return - 1 ; } acct_clear ( ) ; } qemu_mutex_lock_iothread ( ) ; qemu_mutex_lock_ramlist ( ) ; rcu_read_lock ( ) ; bytes_transferred = 0 ; reset_ram_globals ( ) ; ram_bitmap_pages = last_ram_offset ( ) >> TARGET_PAGE_BITS ; migration_bitmap_rcu = g_new0 ( struct BitmapRcu , 1 ) ; migration_bitmap_rcu -> bmap = bitmap_new ( ram_bitmap_pages ) ; bitmap_set ( migration_bitmap_rcu -> bmap , 0 , ram_bitmap_pages ) ; if ( migrate_postcopy_ram ( ) ) { migration_bitmap_rcu -> unsentmap = bitmap_new ( ram_bitmap_pages ) ; bitmap_set ( migration_bitmap_rcu -> unsentmap , 0 , ram_bitmap_pages ) ; } migration_dirty_pages = ram_bytes_total ( ) >> TARGET_PAGE_BITS ; memory_global_dirty_log_start ( ) ; migration_bitmap_sync ( ) ; qemu_mutex_unlock_ramlist ( ) ; qemu_mutex_unlock_iothread ( ) ; rcu_read_unlock ( ) ; return 0 ; }##::##1##::##571
static int decode_i_frame ( FourXContext * f , const uint8_t * buf , int length ) { int x , y ; const int width = f -> avctx -> width ; const int height = f -> avctx -> height ; uint16_t * dst = ( uint16_t * ) f -> current_picture . data [ 0 ] ; const int stride = f -> current_picture . linesize [ 0 ] >> 1 ; const unsigned int bitstream_size = AV_RL32 ( buf ) ; const int token_count av_unused = AV_RL32 ( buf + bitstream_size + 8 ) ; unsigned int prestream_size = 4 * AV_RL32 ( buf + bitstream_size + 4 ) ; const uint8_t * prestream = buf + bitstream_size + 12 ; if ( prestream_size + bitstream_size + 12 != length || bitstream_size > ( 1 << 26 ) || prestream_size > ( 1 << 26 ) ) { av_log ( f -> avctx , AV_LOG_ERROR , "size mismatch %d %d %d\n" , prestream_size , bitstream_size , length ) ; return - 1 ; } prestream = read_huffman_tables ( f , prestream ) ; init_get_bits ( & f -> gb , buf + 4 , 8 * bitstream_size ) ; prestream_size = length + buf - prestream ; av_fast_malloc ( & f -> bitstream_buffer , & f -> bitstream_buffer_size , prestream_size + FF_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! f -> bitstream_buffer ) { return AVERROR ( ENOMEM ) ; } f -> dsp . bswap_buf ( f -> bitstream_buffer , ( const uint32_t * ) prestream , prestream_size / 4 ) ; memset ( ( uint8_t * ) f -> bitstream_buffer + prestream_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ; init_get_bits ( & f -> pre_gb , f -> bitstream_buffer , 8 * prestream_size ) ; f -> last_dc = 0 * 128 * 8 * 8 ; for ( y = 0 ; y < height ; y += 16 ) { for ( x = 0 ; x < width ; x += 16 ) { if ( decode_i_mb ( f ) < 0 ) { return - 1 ; } idct_put ( f , x , y ) ; } dst += 16 * stride ; } if ( get_vlc2 ( & f -> pre_gb , f -> pre_vlc . table , ACDC_VLC_BITS , 3 ) != 256 ) { av_log ( f -> avctx , AV_LOG_ERROR , "end mismatch\n" ) ; } return 0 ; }##::##1##::##8770
static int protocol_client_auth ( VncState * vs , uint8_t * data , size_t len ) { if ( data [ 0 ] != vs -> auth ) { VNC_DEBUG ( "Reject auth %d because it didn't match advertized\n" , ( int ) data [ 0 ] ) ; vnc_write_u32 ( vs , 1 ) ; if ( vs -> minor >= 8 ) { static const char err [ ] = "Authentication failed" ; vnc_write_u32 ( vs , sizeof ( err ) ) ; vnc_write ( vs , err , sizeof ( err ) ) ; } vnc_client_error ( vs ) ; } else { VNC_DEBUG ( "Client requested auth %d\n" , ( int ) data [ 0 ] ) ; switch ( vs -> auth ) { case VNC_AUTH_NONE : VNC_DEBUG ( "Accept auth none\n" ) ; if ( vs -> minor >= 8 ) { vnc_write_u32 ( vs , 0 ) ; vnc_flush ( vs ) ; } start_client_init ( vs ) ; break ; case VNC_AUTH_VNC : VNC_DEBUG ( "Start VNC auth\n" ) ; start_auth_vnc ( vs ) ; break ; case VNC_AUTH_VENCRYPT : VNC_DEBUG ( "Accept VeNCrypt auth\n" ) ; start_auth_vencrypt ( vs ) ; break ; # ifdef CONFIG_VNC_SASL case VNC_AUTH_SASL : VNC_DEBUG ( "Accept SASL auth\n" ) ; start_auth_sasl ( vs ) ; break ; # endif default : VNC_DEBUG ( "Reject auth %d server code bug\n" , vs -> auth ) ; vnc_write_u8 ( vs , 1 ) ; if ( vs -> minor >= 8 ) { static const char err [ ] = "Authentication failed" ; vnc_write_u32 ( vs , sizeof ( err ) ) ; vnc_write ( vs , err , sizeof ( err ) ) ; } vnc_client_error ( vs ) ; } } return 0 ; }##::##1##::##7616
static int decode_p_picture_primary_header ( VC9Context * v ) { GetBitContext * gb = & v -> s . gb ; int lowquant , pqindex , status = 0 ; pqindex = get_bits ( gb , 5 ) ; if ( v -> quantizer_mode == QUANT_FRAME_IMPLICIT ) { v -> pq = pquant_table [ 0 ] [ pqindex ] ; } else { v -> pq = pquant_table [ v -> quantizer_mode - 1 ] [ pqindex ] ; } if ( pqindex < 9 ) { v -> halfpq = get_bits ( gb , 1 ) ; } if ( v -> quantizer_mode == QUANT_FRAME_EXPLICIT ) { v -> pquantizer = get_bits ( gb , 1 ) ; } av_log ( v -> s . avctx , AV_LOG_DEBUG , "P Frame: QP=%i (+%i/2)\n" , v -> pq , v -> halfpq ) ; if ( v -> extended_mv == 1 ) { v -> mvrange = get_prefix ( gb , 0 , 3 ) ; } # if HAS_ADVANCED_PROFILE if ( v -> profile > PROFILE_MAIN ) { if ( v -> postprocflag ) { v -> postproc = get_bits ( gb , 1 ) ; } } else # endif if ( v -> multires ) { v -> respic = get_bits ( gb , 2 ) ; } lowquant = ( v -> pquantizer > 12 ) ? 0 : 1 ; v -> mv_mode = mv_pmode_table [ lowquant ] [ get_prefix ( gb , 1 , 4 ) ] ; if ( v -> mv_mode == MV_PMODE_INTENSITY_COMP ) { v -> mv_mode2 = mv_pmode_table [ lowquant ] [ get_prefix ( gb , 1 , 3 ) ] ; v -> lumscale = get_bits ( gb , 6 ) ; v -> lumshift = get_bits ( gb , 6 ) ; } return 0 ; }##::##1##::##12200
static void fic_draw_cursor ( AVCodecContext * avctx , int cur_x , int cur_y ) { FICContext * ctx = avctx -> priv_data ; uint8_t * ptr = ctx -> cursor_buf ; uint8_t * dstptr [ 3 ] ; uint8_t planes [ 4 ] [ 1024 ] ; uint8_t chroma [ 3 ] [ 256 ] ; int i , j , p ; for ( i = 0 ; i < 1024 ; i ++ ) { planes [ 0 ] [ i ] = av_clip_uint8 ( ( ( 25 * ptr [ 0 ] + 129 * ptr [ 1 ] + 66 * ptr [ 2 ] ) / 255 ) + 16 ) ; planes [ 1 ] [ i ] = av_clip_uint8 ( ( ( - 38 * ptr [ 0 ] + 112 * ptr [ 1 ] + - 74 * ptr [ 2 ] ) / 255 ) + 128 ) ; planes [ 2 ] [ i ] = av_clip_uint8 ( ( ( - 18 * ptr [ 0 ] + 112 * ptr [ 1 ] + - 94 * ptr [ 2 ] ) / 255 ) + 128 ) ; planes [ 3 ] [ i ] = ptr [ 3 ] ; ptr += 4 ; } for ( i = 0 ; i < 32 ; i += 2 ) for ( j = 0 ; j < 32 ; j += 2 ) for ( p = 0 ; p < 3 ; p ++ ) chroma [ p ] [ 16 * ( i / 2 ) + j / 2 ] = ( planes [ p + 1 ] [ 32 * i + j ] + planes [ p + 1 ] [ 32 * i + j + 1 ] + planes [ p + 1 ] [ 32 * ( i + 1 ) + j ] + planes [ p + 1 ] [ 32 * ( i + 1 ) + j + 1 ] ) / 4 ; for ( i = 0 ; i < 3 ; i ++ ) dstptr [ i ] = ctx -> final_frame -> data [ i ] + ( ctx -> final_frame -> linesize [ i ] * ( cur_y >> ! ! i ) ) + ( cur_x >> ! ! i ) + ! ! i ; for ( i = 0 ; i < FFMIN ( 32 , avctx -> height - cur_y ) - 1 ; i += 2 ) { int lsize = FFMIN ( 32 , avctx -> width - cur_x ) ; int csize = lsize / 2 ; fic_alpha_blend ( dstptr [ 0 ] , planes [ 0 ] + i * 32 , lsize , planes [ 3 ] + i * 32 ) ; fic_alpha_blend ( dstptr [ 0 ] + ctx -> final_frame -> linesize [ 0 ] , planes [ 0 ] + ( i + 1 ) * 32 , lsize , planes [ 3 ] + ( i + 1 ) * 32 ) ; fic_alpha_blend ( dstptr [ 1 ] , chroma [ 0 ] + ( i / 2 ) * 16 , csize , chroma [ 2 ] + ( i / 2 ) * 16 ) ; fic_alpha_blend ( dstptr [ 2 ] , chroma [ 1 ] + ( i / 2 ) * 16 , csize , chroma [ 2 ] + ( i / 2 ) * 16 ) ; dstptr [ 0 ] += ctx -> final_frame -> linesize [ 0 ] * 2 ; dstptr [ 1 ] += ctx -> final_frame -> linesize [ 1 ] ; dstptr [ 2 ] += ctx -> final_frame -> linesize [ 2 ] ; } }##::##1##::##8671
static void spatial_decompose97i ( DWTELEM * buffer , int width , int height , int stride ) { int y ; DWTELEM * b0 = buffer + mirror ( - 4 - 1 , height - 1 ) * stride ; DWTELEM * b1 = buffer + mirror ( - 4 , height - 1 ) * stride ; DWTELEM * b2 = buffer + mirror ( - 4 + 1 , height - 1 ) * stride ; DWTELEM * b3 = buffer + mirror ( - 4 + 2 , height - 1 ) * stride ; for ( y = - 4 ; y < height ; y += 2 ) { DWTELEM * b4 = buffer + mirror ( y + 3 , height - 1 ) * stride ; DWTELEM * b5 = buffer + mirror ( y + 4 , height - 1 ) * stride ; { START_TIMER if ( b3 <= b5 ) { horizontal_decompose97i ( b4 , width ) ; } if ( y + 4 < height ) { horizontal_decompose97i ( b5 , width ) ; } if ( width > 400 ) { STOP_TIMER ( "horizontal_decompose97i" ) } } { START_TIMER if ( b3 <= b5 ) { vertical_decompose97iH0 ( b3 , b4 , b5 , width ) ; } if ( b2 <= b4 ) { vertical_decompose97iL0 ( b2 , b3 , b4 , width ) ; } if ( b1 <= b3 ) { vertical_decompose97iH1 ( b1 , b2 , b3 , width ) ; } if ( b0 <= b2 ) { vertical_decompose97iL1 ( b0 , b1 , b2 , width ) ; } if ( width > 400 ) { STOP_TIMER ( "vertical_decompose97i" ) } } b0 = b2 ; b1 = b3 ; b2 = b4 ; b3 = b5 ; } }##::##1##::##2749
void sm501_init ( MemoryRegion * address_space_mem , uint32_t base , uint32_t local_mem_bytes , qemu_irq irq , CharDriverState * chr ) { SM501State * s ; DeviceState * dev ; MemoryRegion * sm501_system_config = g_new ( MemoryRegion , 1 ) ; MemoryRegion * sm501_disp_ctrl = g_new ( MemoryRegion , 1 ) ; MemoryRegion * sm501_2d_engine = g_new ( MemoryRegion , 1 ) ; s = ( SM501State * ) g_malloc0 ( sizeof ( SM501State ) ) ; s -> base = base ; s -> local_mem_size_index = get_local_mem_size_index ( local_mem_bytes ) ; SM501_DPRINTF ( "local mem size=%x. index=%d\n" , get_local_mem_size ( s ) , s -> local_mem_size_index ) ; s -> system_control = 0x00100000 ; s -> misc_control = 0x00001000 ; s -> dc_panel_control = 0x00010000 ; s -> dc_crt_control = 0x00010000 ; memory_region_init_ram ( & s -> local_mem_region , NULL , "sm501.local" , local_mem_bytes , & error_abort ) ; vmstate_register_ram_global ( & s -> local_mem_region ) ; memory_region_set_log ( & s -> local_mem_region , true , DIRTY_MEMORY_VGA ) ; s -> local_mem = memory_region_get_ram_ptr ( & s -> local_mem_region ) ; memory_region_add_subregion ( address_space_mem , base , & s -> local_mem_region ) ; memory_region_init_io ( sm501_system_config , NULL , & sm501_system_config_ops , s , "sm501-system-config" , 0x6c ) ; memory_region_add_subregion ( address_space_mem , base + MMIO_BASE_OFFSET , sm501_system_config ) ; memory_region_init_io ( sm501_disp_ctrl , NULL , & sm501_disp_ctrl_ops , s , "sm501-disp-ctrl" , 0x1000 ) ; memory_region_add_subregion ( address_space_mem , base + MMIO_BASE_OFFSET + SM501_DC , sm501_disp_ctrl ) ; memory_region_init_io ( sm501_2d_engine , NULL , & sm501_2d_engine_ops , s , "sm501-2d-engine" , 0x54 ) ; memory_region_add_subregion ( address_space_mem , base + MMIO_BASE_OFFSET + SM501_2D_ENGINE , sm501_2d_engine ) ; dev = qdev_create ( NULL , "sysbus-ohci" ) ; qdev_prop_set_uint32 ( dev , "num-ports" , 2 ) ; qdev_prop_set_uint64 ( dev , "dma-offset" , base ) ; qdev_init_nofail ( dev ) ; sysbus_mmio_map ( SYS_BUS_DEVICE ( dev ) , 0 , base + MMIO_BASE_OFFSET + SM501_USB_HOST ) ; sysbus_connect_irq ( SYS_BUS_DEVICE ( dev ) , 0 , irq ) ; if ( chr ) { serial_mm_init ( address_space_mem , base + MMIO_BASE_OFFSET + SM501_UART0 , 2 , NULL , 115200 , chr , DEVICE_NATIVE_ENDIAN ) ; } s -> con = graphic_console_init ( DEVICE ( dev ) , 0 , & sm501_ops , s ) ; }##::##1##::##603
static int asf_read_value ( AVFormatContext * s , uint8_t * name , uint16_t name_len , uint16_t val_len , int type , AVDictionary * * met ) { int ret ; uint8_t * value ; uint16_t buflen = 2 * val_len + 1 ; AVIOContext * pb = s -> pb ; value = av_malloc ( buflen ) ; if ( ! value ) { return AVERROR ( ENOMEM ) ; } if ( type == ASF_UNICODE ) { if ( ( ret = get_asf_string ( pb , val_len , value , buflen ) ) < 0 ) { goto failed ; } if ( av_dict_set ( met , name , value , 0 ) < 0 ) { av_log ( s , AV_LOG_WARNING , "av_dict_set failed.\n" ) ; } } else { char buf [ 256 ] ; if ( val_len > sizeof ( buf ) ) { ret = AVERROR_INVALIDDATA ; goto failed ; } if ( ( ret = avio_read ( pb , value , val_len ) ) < 0 ) { goto failed ; } if ( ret < 2 * val_len ) { value [ ret ] = '\0' ; } else { value [ 2 * val_len - 1 ] = '\0' ; } snprintf ( buf , sizeof ( buf ) , "%s" , value ) ; if ( av_dict_set ( met , name , buf , 0 ) < 0 ) { av_log ( s , AV_LOG_WARNING , "av_dict_set failed.\n" ) ; } } av_freep ( & value ) ; return 0 ; failed : av_freep ( & value ) ; return ret ; }##::##1##::##11231
static int au_read_header ( AVFormatContext * s ) { int size ; unsigned int tag ; AVIOContext * pb = s -> pb ; unsigned int id , channels , rate ; int bps ; enum AVCodecID codec ; AVStream * st ; tag = avio_rl32 ( pb ) ; if ( tag != MKTAG ( '.' , 's' , 'n' , 'd' ) ) { return - 1 ; } size = avio_rb32 ( pb ) ; avio_rb32 ( pb ) ; id = avio_rb32 ( pb ) ; rate = avio_rb32 ( pb ) ; channels = avio_rb32 ( pb ) ; codec = ff_codec_get_id ( codec_au_tags , id ) ; if ( codec == AV_CODEC_ID_NONE ) { av_log_ask_for_sample ( s , "unknown or unsupported codec tag: %d\n" , id ) ; return AVERROR_PATCHWELCOME ; } bps = av_get_bits_per_sample ( codec ) ; if ( ! bps ) { av_log_ask_for_sample ( s , "could not determine bits per sample\n" ) ; return AVERROR_PATCHWELCOME ; } if ( channels == 0 || channels > 64 ) { av_log ( s , AV_LOG_ERROR , "Invalid number of channels %d\n" , channels ) ; return AVERROR_INVALIDDATA ; } if ( size >= 24 ) { avio_skip ( pb , size - 24 ) ; } st = avformat_new_stream ( s , NULL ) ; if ( ! st ) { return - 1 ; } st -> codec -> codec_type = AVMEDIA_TYPE_AUDIO ; st -> codec -> codec_tag = id ; st -> codec -> codec_id = codec ; st -> codec -> channels = channels ; st -> codec -> sample_rate = rate ; st -> codec -> bit_rate = channels * rate * bps ; st -> codec -> block_align = channels * bps >> 3 ; avpriv_set_pts_info ( st , 64 , 1 , rate ) ; return 0 ; }##::##1##::##5893
static int openfile ( char * name , int flags , bool writethrough , bool force_share , QDict * opts ) { Error * local_err = NULL ; BlockDriverState * bs ; if ( qemuio_blk ) { error_report ( "file open already, try 'help close'" ) ; QDECREF ( opts ) ; return 1 ; } if ( force_share ) { if ( ! opts ) { opts = qdict_new ( ) ; } if ( qdict_haskey ( opts , BDRV_OPT_FORCE_SHARE ) && ! qdict_get_bool ( opts , BDRV_OPT_FORCE_SHARE ) ) { error_report ( "-U conflicts with image options" ) ; QDECREF ( opts ) ; return 1 ; } qdict_put_bool ( opts , BDRV_OPT_FORCE_SHARE , true ) ; } qemuio_blk = blk_new_open ( name , NULL , opts , flags , & local_err ) ; if ( ! qemuio_blk ) { error_reportf_err ( local_err , "can't open%s%s: " , name ? " device " : "" , name ? : "" ) ; return 1 ; } bs = blk_bs ( qemuio_blk ) ; if ( bdrv_is_encrypted ( bs ) && bdrv_key_required ( bs ) ) { char password [ 256 ] ; printf ( "Disk image '%s' is encrypted.\n" , name ) ; if ( qemu_read_password ( password , sizeof ( password ) ) < 0 ) { error_report ( "No password given" ) ; goto error ; } if ( bdrv_set_key ( bs , password ) < 0 ) { error_report ( "invalid password" ) ; goto error ; } } blk_set_enable_write_cache ( qemuio_blk , ! writethrough ) ; return 0 ; error : blk_unref ( qemuio_blk ) ; qemuio_blk = NULL ; return 1 ; }##::##1##::##8118
static inline int64_t get_sector_offset ( BlockDriverState * bs , int64_t sector_num , int write ) { BDRVVPCState * s = bs -> opaque ; uint64_t offset = sector_num * 512 ; uint64_t bitmap_offset , block_offset ; uint32_t pagetable_index , pageentry_index ; pagetable_index = offset / s -> block_size ; pageentry_index = ( offset % s -> block_size ) / 512 ; if ( pagetable_index >= s -> max_table_entries || s -> pagetable [ pagetable_index ] == 0xffffffff ) { return - 1 ; } bitmap_offset = 512 * ( uint64_t ) s -> pagetable [ pagetable_index ] ; block_offset = bitmap_offset + s -> bitmap_size + ( 512 * pageentry_index ) ; if ( write && ( s -> last_bitmap_offset != bitmap_offset ) ) { uint8_t bitmap [ s -> bitmap_size ] ; s -> last_bitmap_offset = bitmap_offset ; memset ( bitmap , 0xff , s -> bitmap_size ) ; bdrv_pwrite ( bs -> file , bitmap_offset , bitmap , s -> bitmap_size ) ; } # if 0 # ifdef CACHE if ( bitmap_offset != s -> last_bitmap ) { lseek ( s -> fd , bitmap_offset , SEEK_SET ) ; s -> last_bitmap = bitmap_offset ; read ( s -> fd , s -> pageentry_u8 , 512 ) ; for ( i = 0 ; i < 128 ; i ++ ) { be32_to_cpus ( & s -> pageentry_u32 [ i ] ) ; } } if ( ( s -> pageentry_u8 [ pageentry_index / 8 ] >> ( pageentry_index % 8 ) ) & 1 ) { return - 1 ; } # else lseek ( s -> fd , bitmap_offset + ( pageentry_index / 8 ) , SEEK_SET ) ; read ( s -> fd , & bitmap_entry , 1 ) ; if ( ( bitmap_entry >> ( pageentry_index % 8 ) ) & 1 ) { return - 1 ; } # endif # endif return block_offset ; }##::##1##::##12211
static int mkv_write_chapters ( AVFormatContext * s ) { MatroskaMuxContext * mkv = s -> priv_data ; AVIOContext * pb = s -> pb ; ebml_master chapters , editionentry ; AVRational scale = { 1 , 1E9 } ; int i , ret ; if ( ! s -> nb_chapters || mkv -> wrote_chapters ) { return 0 ; } ret = mkv_add_seekhead_entry ( mkv -> main_seekhead , MATROSKA_ID_CHAPTERS , avio_tell ( pb ) ) ; if ( ret < 0 ) { return ret ; } chapters = start_ebml_master ( pb , MATROSKA_ID_CHAPTERS , 0 ) ; editionentry = start_ebml_master ( pb , MATROSKA_ID_EDITIONENTRY , 0 ) ; put_ebml_uint ( pb , MATROSKA_ID_EDITIONFLAGDEFAULT , 1 ) ; put_ebml_uint ( pb , MATROSKA_ID_EDITIONFLAGHIDDEN , 0 ) ; for ( i = 0 ; i < s -> nb_chapters ; i ++ ) { ebml_master chapteratom , chapterdisplay ; AVChapter * c = s -> chapters [ i ] ; int chapterstart = av_rescale_q ( c -> start , c -> time_base , scale ) ; int chapterend = av_rescale_q ( c -> end , c -> time_base , scale ) ; AVDictionaryEntry * t = NULL ; if ( chapterstart < 0 || chapterstart > chapterend ) { return AVERROR_INVALIDDATA ; } chapteratom = start_ebml_master ( pb , MATROSKA_ID_CHAPTERATOM , 0 ) ; put_ebml_uint ( pb , MATROSKA_ID_CHAPTERUID , c -> id + mkv -> chapter_id_offset ) ; put_ebml_uint ( pb , MATROSKA_ID_CHAPTERTIMESTART , chapterstart ) ; put_ebml_uint ( pb , MATROSKA_ID_CHAPTERTIMEEND , chapterend ) ; put_ebml_uint ( pb , MATROSKA_ID_CHAPTERFLAGHIDDEN , 0 ) ; put_ebml_uint ( pb , MATROSKA_ID_CHAPTERFLAGENABLED , 1 ) ; if ( ( t = av_dict_get ( c -> metadata , "title" , NULL , 0 ) ) ) { chapterdisplay = start_ebml_master ( pb , MATROSKA_ID_CHAPTERDISPLAY , 0 ) ; put_ebml_string ( pb , MATROSKA_ID_CHAPSTRING , t -> value ) ; put_ebml_string ( pb , MATROSKA_ID_CHAPLANG , "und" ) ; end_ebml_master ( pb , chapterdisplay ) ; } end_ebml_master ( pb , chapteratom ) ; } end_ebml_master ( pb , editionentry ) ; end_ebml_master ( pb , chapters ) ; mkv -> wrote_chapters = 1 ; return 0 ; }##::##1##::##9040
static uint32_t rtl8139_io_readl ( void * opaque , uint8_t addr ) { RTL8139State * s = opaque ; uint32_t ret ; switch ( addr ) { case RxMissed : ret = s -> RxMissed ; DPRINTF ( "RxMissed read val=0x%08x\n" , ret ) ; break ; case TxConfig : ret = rtl8139_TxConfig_read ( s ) ; break ; case RxConfig : ret = rtl8139_RxConfig_read ( s ) ; break ; case TxStatus0 ... TxStatus0 + 4 * 4 - 1 : ret = rtl8139_TxStatus_read ( s , addr , 4 ) ; break ; case TxAddr0 ... TxAddr0 + 4 * 4 - 1 : ret = rtl8139_TxAddr_read ( s , addr - TxAddr0 ) ; break ; case RxBuf : ret = rtl8139_RxBuf_read ( s ) ; break ; case RxRingAddrLO : ret = s -> RxRingAddrLO ; DPRINTF ( "C+ RxRing low bits read val=0x%08x\n" , ret ) ; break ; case RxRingAddrHI : ret = s -> RxRingAddrHI ; DPRINTF ( "C+ RxRing high bits read val=0x%08x\n" , ret ) ; break ; case Timer : ret = muldiv64 ( qemu_get_clock_ns ( vm_clock ) - s -> TCTR_base , PCI_FREQUENCY , get_ticks_per_sec ( ) ) ; DPRINTF ( "TCTR Timer read val=0x%08x\n" , ret ) ; break ; case FlashReg : ret = s -> TimerInt ; DPRINTF ( "FlashReg TimerInt read val=0x%08x\n" , ret ) ; break ; default : DPRINTF ( "ioport read(l) addr=0x%x via read(b)\n" , addr ) ; ret = rtl8139_io_readb ( opaque , addr ) ; ret |= rtl8139_io_readb ( opaque , addr + 1 ) << 8 ; ret |= rtl8139_io_readb ( opaque , addr + 2 ) << 16 ; ret |= rtl8139_io_readb ( opaque , addr + 3 ) << 24 ; DPRINTF ( "read(l) addr=0x%x val=%08x\n" , addr , ret ) ; break ; } return ret ; }##::##1##::##703
static void ccid_card_vscard_handle_message ( PassthruState * card , VSCMsgHeader * scr_msg_header ) { uint8_t * data = ( uint8_t * ) & scr_msg_header [ 1 ] ; switch ( scr_msg_header -> type ) { case VSC_ATR : DPRINTF ( card , D_INFO , "VSC_ATR %d\n" , scr_msg_header -> length ) ; if ( scr_msg_header -> length > MAX_ATR_SIZE ) { error_report ( "ATR size exceeds spec, ignoring" ) ; ccid_card_vscard_send_error ( card , scr_msg_header -> reader_id , VSC_GENERAL_ERROR ) ; } memcpy ( card -> atr , data , scr_msg_header -> length ) ; card -> atr_length = scr_msg_header -> length ; ccid_card_card_inserted ( & card -> base ) ; ccid_card_vscard_send_error ( card , scr_msg_header -> reader_id , VSC_SUCCESS ) ; case VSC_APDU : ccid_card_send_apdu_to_guest ( & card -> base , data , scr_msg_header -> length ) ; case VSC_CardRemove : DPRINTF ( card , D_INFO , "VSC_CardRemove\n" ) ; ccid_card_card_removed ( & card -> base ) ; ccid_card_vscard_send_error ( card , scr_msg_header -> reader_id , VSC_SUCCESS ) ; case VSC_Init : ccid_card_vscard_handle_init ( card , scr_msg_header , ( VSCMsgInit * ) data ) ; case VSC_Error : ccid_card_card_error ( & card -> base , * ( uint32_t * ) data ) ; case VSC_ReaderAdd : if ( ccid_card_ccid_attach ( & card -> base ) < 0 ) { ccid_card_vscard_send_error ( card , VSCARD_UNDEFINED_READER_ID , VSC_CANNOT_ADD_MORE_READERS ) ; } else { ccid_card_vscard_send_error ( card , VSCARD_MINIMAL_READER_ID , VSC_SUCCESS ) ; } case VSC_ReaderRemove : ccid_card_ccid_detach ( & card -> base ) ; ccid_card_vscard_send_error ( card , scr_msg_header -> reader_id , VSC_SUCCESS ) ; default : printf ( "usb-ccid: chardev: unexpected message of type %X\n" , scr_msg_header -> type ) ; ccid_card_vscard_send_error ( card , scr_msg_header -> reader_id , VSC_GENERAL_ERROR ) ; } }##::##1##::##5317
static int mjpeg_decode_dht ( MJpegDecodeContext * s ) { int len , index , i , class , n , v , code_max ; uint8_t bits_table [ 17 ] ; uint8_t val_table [ 256 ] ; len = get_bits ( & s -> gb , 16 ) - 2 ; while ( len > 0 ) { if ( len < 17 ) { return - 1 ; } class = get_bits ( & s -> gb , 4 ) ; if ( class >= 2 ) { return - 1 ; } index = get_bits ( & s -> gb , 4 ) ; if ( index >= 4 ) { return - 1 ; } n = 0 ; for ( i = 1 ; i <= 16 ; i ++ ) { bits_table [ i ] = get_bits ( & s -> gb , 8 ) ; n += bits_table [ i ] ; } len -= 17 ; if ( len < n || n > 256 ) { return - 1 ; } code_max = 0 ; for ( i = 0 ; i < n ; i ++ ) { v = get_bits ( & s -> gb , 8 ) ; if ( v > code_max ) { code_max = v ; } val_table [ i ] = v ; } len -= n ; free_vlc ( & s -> vlcs [ class ] [ index ] ) ; dprintf ( "class=%d index=%d nb_codes=%d\n" , class , index , code_max + 1 ) ; if ( build_vlc ( & s -> vlcs [ class ] [ index ] , bits_table , val_table , code_max + 1 ) < 0 ) { return - 1 ; } } return 0 ; }##::##1##::##7654
static void gen_msa_elm_df ( CPUMIPSState * env , DisasContext * ctx , uint32_t df , uint32_t n ) { # define MASK_MSA_ELM ( op ) ( MASK_MSA_MINOR ( op ) | ( op & ( 0xf << 22 ) ) ) uint8_t ws = ( ctx -> opcode >> 11 ) & 0x1f ; uint8_t wd = ( ctx -> opcode >> 6 ) & 0x1f ; TCGv_i32 tws = tcg_const_i32 ( ws ) ; TCGv_i32 twd = tcg_const_i32 ( wd ) ; TCGv_i32 tn = tcg_const_i32 ( n ) ; TCGv_i32 tdf = tcg_const_i32 ( df ) ; switch ( MASK_MSA_ELM ( ctx -> opcode ) ) { case OPC_SLDI_df : gen_helper_msa_sldi_df ( cpu_env , tdf , twd , tws , tn ) ; break ; case OPC_SPLATI_df : gen_helper_msa_splati_df ( cpu_env , tdf , twd , tws , tn ) ; break ; case OPC_INSVE_df : gen_helper_msa_insve_df ( cpu_env , tdf , twd , tws , tn ) ; break ; case OPC_COPY_S_df : case OPC_COPY_U_df : case OPC_INSERT_df : # if ! defined ( TARGET_MIPS64 ) if ( df == DF_DOUBLE ) { generate_exception_end ( ctx , EXCP_RI ) ; break ; } # endif switch ( MASK_MSA_ELM ( ctx -> opcode ) ) { case OPC_COPY_S_df : gen_helper_msa_copy_s_df ( cpu_env , tdf , twd , tws , tn ) ; break ; case OPC_COPY_U_df : gen_helper_msa_copy_u_df ( cpu_env , tdf , twd , tws , tn ) ; break ; case OPC_INSERT_df : gen_helper_msa_insert_df ( cpu_env , tdf , twd , tws , tn ) ; break ; } break ; default : MIPS_INVAL ( "MSA instruction" ) ; generate_exception_end ( ctx , EXCP_RI ) ; } tcg_temp_free_i32 ( twd ) ; tcg_temp_free_i32 ( tws ) ; tcg_temp_free_i32 ( tn ) ; tcg_temp_free_i32 ( tdf ) ; }##::##1##::##1702
static int standard_decode_picture_primary_header ( VC9Context * v ) { GetBitContext * gb = & v -> s . gb ; int status = 0 ; if ( v -> finterpflag ) { v -> interpfrm = get_bits ( gb , 1 ) ; } skip_bits ( gb , 2 ) ; if ( v -> rangered ) { v -> rangeredfrm = get_bits ( gb , 1 ) ; } v -> s . pict_type = get_bits ( gb , 1 ) ; if ( v -> s . avctx -> max_b_frames ) { if ( ! v -> s . pict_type ) { if ( get_bits ( gb , 1 ) ) { v -> s . pict_type = I_TYPE ; } else { v -> s . pict_type = B_TYPE ; } } else { v -> s . pict_type = P_TYPE ; } } else { v -> s . pict_type ++ ; } switch ( v -> s . pict_type ) { case I_TYPE : status = decode_i_picture_header ( v ) ; break ; case P_TYPE : status = decode_p_picture_primary_header ( v ) ; break ; case BI_TYPE : case B_TYPE : status = decode_b_picture_primary_header ( v ) ; break ; } if ( status == FRAME_SKIPED ) { av_log ( v -> s . avctx , AV_LOG_INFO , "Skipping frame...\n" ) ; return status ; } return 0 ; }##::##1##::##5909
void * address_space_map ( AddressSpace * as , hwaddr addr , hwaddr * plen , bool is_write ) { hwaddr len = * plen ; hwaddr done = 0 ; hwaddr l , xlat , base ; MemoryRegion * mr , * this_mr ; ram_addr_t raddr ; if ( len == 0 ) { return NULL ; } l = len ; mr = address_space_translate ( as , addr , & xlat , & l , is_write ) ; if ( ! memory_access_is_direct ( mr , is_write ) ) { if ( bounce . buffer ) { return NULL ; } l = MIN ( l , TARGET_PAGE_SIZE ) ; bounce . buffer = qemu_memalign ( TARGET_PAGE_SIZE , l ) ; bounce . addr = addr ; bounce . len = l ; memory_region_ref ( mr ) ; bounce . mr = mr ; if ( ! is_write ) { address_space_read ( as , addr , bounce . buffer , l ) ; } * plen = l ; return bounce . buffer ; } base = xlat ; raddr = memory_region_get_ram_addr ( mr ) ; for ( ; ; ) { len -= l ; addr += l ; done += l ; if ( len == 0 ) { break ; } l = len ; this_mr = address_space_translate ( as , addr , & xlat , & l , is_write ) ; if ( this_mr != mr || xlat != base + done ) { break ; } } memory_region_ref ( mr ) ; * plen = done ; return qemu_ram_ptr_length ( raddr + base , plen ) ; }##::##1##::##5320
static target_ulong h_register_logical_lan ( CPUPPCState * env , sPAPREnvironment * spapr , target_ulong opcode , target_ulong * args ) { target_ulong reg = args [ 0 ] ; target_ulong buf_list = args [ 1 ] ; target_ulong rec_queue = args [ 2 ] ; target_ulong filter_list = args [ 3 ] ; VIOsPAPRDevice * sdev = spapr_vio_find_by_reg ( spapr -> vio_bus , reg ) ; VIOsPAPRVLANDevice * dev = ( VIOsPAPRVLANDevice * ) sdev ; vlan_bd_t filter_list_bd ; if ( ! dev ) { return H_PARAMETER ; } if ( dev -> isopen ) { hcall_dprintf ( "H_REGISTER_LOGICAL_LAN called twice without " "H_FREE_LOGICAL_LAN\n" ) ; return H_RESOURCE ; } if ( check_bd ( dev , VLAN_VALID_BD ( buf_list , SPAPR_VIO_TCE_PAGE_SIZE ) , SPAPR_VIO_TCE_PAGE_SIZE ) < 0 ) { hcall_dprintf ( "Bad buf_list 0x" TARGET_FMT_lx "\n" , buf_list ) ; return H_PARAMETER ; } filter_list_bd = VLAN_VALID_BD ( filter_list , SPAPR_VIO_TCE_PAGE_SIZE ) ; if ( check_bd ( dev , filter_list_bd , SPAPR_VIO_TCE_PAGE_SIZE ) < 0 ) { hcall_dprintf ( "Bad filter_list 0x" TARGET_FMT_lx "\n" , filter_list ) ; return H_PARAMETER ; } if ( ! ( rec_queue & VLAN_BD_VALID ) || ( check_bd ( dev , rec_queue , VLAN_RQ_ALIGNMENT ) < 0 ) ) { hcall_dprintf ( "Bad receive queue\n" ) ; return H_PARAMETER ; } dev -> buf_list = buf_list ; sdev -> signal_state = 0 ; rec_queue &= ~ VLAN_BD_TOGGLE ; stq_tce ( sdev , buf_list , rec_queue ) ; stq_tce ( sdev , buf_list + 8 , filter_list_bd ) ; spapr_tce_dma_zero ( sdev , buf_list + VLAN_RX_BDS_OFF , SPAPR_VIO_TCE_PAGE_SIZE - VLAN_RX_BDS_OFF ) ; dev -> add_buf_ptr = VLAN_RX_BDS_OFF - 8 ; dev -> use_buf_ptr = VLAN_RX_BDS_OFF - 8 ; dev -> rx_bufs = 0 ; dev -> rxq_ptr = 0 ; spapr_tce_dma_zero ( sdev , VLAN_BD_ADDR ( rec_queue ) , VLAN_BD_LEN ( rec_queue ) ) ; dev -> isopen = 1 ; return H_SUCCESS ; }##::##1##::##8995
int64_t ff_ape_parse_tag ( AVFormatContext * s ) { AVIOContext * pb = s -> pb ; int file_size = avio_size ( pb ) ; uint32_t val , fields , tag_bytes ; uint8_t buf [ 8 ] ; int64_t tag_start ; int i ; if ( file_size < APE_TAG_FOOTER_BYTES ) { return 0 ; } avio_seek ( pb , file_size - APE_TAG_FOOTER_BYTES , SEEK_SET ) ; avio_read ( pb , buf , 8 ) ; if ( strncmp ( buf , "APETAGEX" , 8 ) ) { return 0 ; } val = avio_rl32 ( pb ) ; if ( val > APE_TAG_VERSION ) { av_log ( s , AV_LOG_ERROR , "Unsupported tag version. (>=%d)\n" , APE_TAG_VERSION ) ; return 0 ; } tag_bytes = avio_rl32 ( pb ) ; if ( tag_bytes - APE_TAG_FOOTER_BYTES > ( 1024 * 1024 * 16 ) ) { av_log ( s , AV_LOG_ERROR , "Tag size is way too big\n" ) ; return 0 ; } tag_start = file_size - tag_bytes - APE_TAG_FOOTER_BYTES ; if ( tag_start < 0 ) { av_log ( s , AV_LOG_ERROR , "Invalid tag size %u.\n" , tag_bytes ) ; return 0 ; } fields = avio_rl32 ( pb ) ; if ( fields > 65536 ) { av_log ( s , AV_LOG_ERROR , "Too many tag fields (%d)\n" , fields ) ; return 0 ; } val = avio_rl32 ( pb ) ; if ( val & APE_TAG_FLAG_IS_HEADER ) { av_log ( s , AV_LOG_ERROR , "APE Tag is a header\n" ) ; return 0 ; } avio_seek ( pb , file_size - tag_bytes , SEEK_SET ) ; for ( i = 0 ; i < fields ; i ++ ) if ( ape_tag_read_field ( s ) < 0 ) { break ; } return tag_start ; }##::##1##::##11085
static inline void gen_op_arith_add ( DisasContext * ctx , TCGv ret , TCGv arg1 , TCGv arg2 , int add_ca , int compute_ca , int compute_ov ) { TCGv t0 , t1 ; if ( ( ! compute_ca && ! compute_ov ) || ( ! TCGV_EQUAL ( ret , arg1 ) && ! TCGV_EQUAL ( ret , arg2 ) ) ) { t0 = ret ; } else { t0 = tcg_temp_local_new ( ) ; } if ( add_ca ) { t1 = tcg_temp_local_new ( ) ; tcg_gen_mov_tl ( t1 , cpu_ca ) ; } else { TCGV_UNUSED ( t1 ) ; } if ( compute_ca ) { tcg_gen_movi_tl ( cpu_ca , 0 ) ; } if ( compute_ov ) { tcg_gen_movi_tl ( cpu_ov , 0 ) ; } tcg_gen_add_tl ( t0 , arg1 , arg2 ) ; if ( compute_ca ) { gen_op_arith_compute_ca ( ctx , t0 , arg1 , 0 ) ; } if ( add_ca ) { tcg_gen_add_tl ( t0 , t0 , t1 ) ; gen_op_arith_compute_ca ( ctx , t0 , t1 , 0 ) ; tcg_temp_free ( t1 ) ; } if ( compute_ov ) { gen_op_arith_compute_ov ( ctx , t0 , arg1 , arg2 , 0 ) ; } if ( unlikely ( Rc ( ctx -> opcode ) != 0 ) ) { gen_set_Rc0 ( ctx , t0 ) ; } if ( ! TCGV_EQUAL ( t0 , ret ) ) { tcg_gen_mov_tl ( ret , t0 ) ; tcg_temp_free ( t0 ) ; } }##::##1##::##2289
static int find_vdi_name ( BDRVSheepdogState * s , char * filename , uint32_t snapid , char * tag , uint32_t * vid , int for_snapshot ) { int ret , fd ; SheepdogVdiReq hdr ; SheepdogVdiRsp * rsp = ( SheepdogVdiRsp * ) & hdr ; unsigned int wlen , rlen = 0 ; char buf [ SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN ] ; fd = connect_to_sdog ( s -> addr , s -> port ) ; if ( fd < 0 ) { return fd ; } memset ( buf , 0 , sizeof ( buf ) ) ; strncpy ( buf , filename , SD_MAX_VDI_LEN ) ; strncpy ( buf + SD_MAX_VDI_LEN , tag , SD_MAX_VDI_TAG_LEN ) ; memset ( & hdr , 0 , sizeof ( hdr ) ) ; if ( for_snapshot ) { hdr . opcode = SD_OP_GET_VDI_INFO ; } else { hdr . opcode = SD_OP_LOCK_VDI ; } wlen = SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN ; hdr . proto_ver = SD_PROTO_VER ; hdr . data_length = wlen ; hdr . snapid = snapid ; hdr . flags = SD_FLAG_CMD_WRITE ; ret = do_req ( fd , ( SheepdogReq * ) & hdr , buf , & wlen , & rlen ) ; if ( ret ) { goto out ; } if ( rsp -> result != SD_RES_SUCCESS ) { error_report ( "cannot get vdi info, %s, %s %d %s" , sd_strerror ( rsp -> result ) , filename , snapid , tag ) ; if ( rsp -> result == SD_RES_NO_VDI ) { ret = - ENOENT ; } else { ret = - EIO ; } goto out ; } * vid = rsp -> vdi_id ; ret = 0 ; out : closesocket ( fd ) ; return ret ; }##::##1##::##1108
static void close_connection ( HTTPContext * c ) { HTTPContext * * cp , * c1 ; int i , nb_streams ; AVFormatContext * ctx ; URLContext * h ; AVStream * st ; cp = & first_http_ctx ; while ( ( * cp ) != NULL ) { c1 = * cp ; if ( c1 == c ) { * cp = c -> next ; } else { cp = & c1 -> next ; if ( c -> fd >= 0 ) { close ( c -> fd ) ; } if ( c -> fmt_in ) { for ( i = 0 ; i < c -> fmt_in -> nb_streams ; i ++ ) { st = c -> fmt_in -> streams [ i ] ; if ( st -> codec . codec ) { avcodec_close ( & st -> codec ) ; av_close_input_file ( c -> fmt_in ) ; nb_streams = 0 ; if ( c -> stream ) { nb_streams = c -> stream -> nb_streams ; } for ( i = 0 ; i < nb_streams ; i ++ ) { ctx = c -> rtp_ctx [ i ] ; if ( ctx ) { av_free ( ctx ) ; h = c -> rtp_handles [ i ] ; if ( h ) { url_close ( h ) ; if ( c -> stream ) { current_bandwidth -= c -> stream -> bandwidth ; } av_freep ( & c -> pb_buffer ) ; av_free ( c -> buffer ) ; av_free ( c ) ; nb_connections -- ;##::##1##::##1740
static void ir2_decode_plane ( Ir2Context * ctx , int width , int height , uint8_t * dst , int stride , const uint8_t * table ) { int i ; int j ; int out = 0 ; int c ; int t ; while ( out < width ) { c = ir2_get_code ( & ctx -> gb ) ; if ( c > 0x80 ) { c -= 0x80 ; for ( i = 0 ; i < c * 2 ; i ++ ) { dst [ out ++ ] = 0x80 ; } } else { dst [ out ++ ] = table [ c * 2 ] ; dst [ out ++ ] = table [ ( c * 2 ) + 1 ] ; } } dst += stride ; for ( j = 1 ; j < height ; j ++ ) { out = 0 ; while ( out < width ) { c = ir2_get_code ( & ctx -> gb ) ; if ( c > 0x80 ) { c -= 0x80 ; for ( i = 0 ; i < c * 2 ; i ++ ) { dst [ out ] = dst [ out - stride ] ; out ++ ; } } else { t = dst [ out - stride ] + ( table [ c * 2 ] - 128 ) ; CLAMP_TO_BYTE ( t ) ; dst [ out ] = t ; out ++ ; t = dst [ out - stride ] + ( table [ ( c * 2 ) + 1 ] - 128 ) ; CLAMP_TO_BYTE ( t ) ; dst [ out ] = t ; out ++ ; } } dst += stride ; } }##::##1##::##7444
StrongARMState * sa1110_init ( MemoryRegion * sysmem , unsigned int sdram_size , const char * rev ) { StrongARMState * s ; int i ; s = g_new0 ( StrongARMState , 1 ) ; if ( ! rev ) { rev = "sa1110-b5" ; } if ( strncmp ( rev , "sa1110" , 6 ) ) { error_report ( "Machine requires a SA1110 processor." ) ; exit ( 1 ) ; } s -> cpu = ARM_CPU ( cpu_generic_init ( TYPE_ARM_CPU , rev ) ) ; if ( ! s -> cpu ) { error_report ( "Unable to find CPU definition" ) ; exit ( 1 ) ; } memory_region_allocate_system_memory ( & s -> sdram , NULL , "strongarm.sdram" , sdram_size ) ; memory_region_add_subregion ( sysmem , SA_SDCS0 , & s -> sdram ) ; s -> pic = sysbus_create_varargs ( "strongarm_pic" , 0x90050000 , qdev_get_gpio_in ( DEVICE ( s -> cpu ) , ARM_CPU_IRQ ) , qdev_get_gpio_in ( DEVICE ( s -> cpu ) , ARM_CPU_FIQ ) , NULL ) ; sysbus_create_varargs ( "pxa25x-timer" , 0x90000000 , qdev_get_gpio_in ( s -> pic , SA_PIC_OSTC0 ) , qdev_get_gpio_in ( s -> pic , SA_PIC_OSTC1 ) , qdev_get_gpio_in ( s -> pic , SA_PIC_OSTC2 ) , qdev_get_gpio_in ( s -> pic , SA_PIC_OSTC3 ) , NULL ) ; sysbus_create_simple ( TYPE_STRONGARM_RTC , 0x90010000 , qdev_get_gpio_in ( s -> pic , SA_PIC_RTC_ALARM ) ) ; s -> gpio = strongarm_gpio_init ( 0x90040000 , s -> pic ) ; s -> ppc = sysbus_create_varargs ( TYPE_STRONGARM_PPC , 0x90060000 , NULL ) ; for ( i = 0 ; sa_serial [ i ] . io_base ; i ++ ) { DeviceState * dev = qdev_create ( NULL , TYPE_STRONGARM_UART ) ; qdev_prop_set_chr ( dev , "chardev" , serial_hds [ i ] ) ; qdev_init_nofail ( dev ) ; sysbus_mmio_map ( SYS_BUS_DEVICE ( dev ) , 0 , sa_serial [ i ] . io_base ) ; sysbus_connect_irq ( SYS_BUS_DEVICE ( dev ) , 0 , qdev_get_gpio_in ( s -> pic , sa_serial [ i ] . irq ) ) ; } s -> ssp = sysbus_create_varargs ( TYPE_STRONGARM_SSP , 0x80070000 , qdev_get_gpio_in ( s -> pic , SA_PIC_SSP ) , NULL ) ; s -> ssp_bus = ( SSIBus * ) qdev_get_child_bus ( s -> ssp , "ssi" ) ; return s ; }##::##1##::##8689
QTestState * qtest_init ( const char * extra_args ) { QTestState * s ; int sock , qmpsock , i ; gchar * socket_path ; gchar * qmp_socket_path ; gchar * command ; const char * qemu_binary ; struct sigaction sigact ; qemu_binary = getenv ( "QTEST_QEMU_BINARY" ) ; g_assert ( qemu_binary != NULL ) ; s = g_malloc ( sizeof ( * s ) ) ; socket_path = g_strdup_printf ( "/tmp/qtest-%d.sock" , getpid ( ) ) ; qmp_socket_path = g_strdup_printf ( "/tmp/qtest-%d.qmp" , getpid ( ) ) ; sock = init_socket ( socket_path ) ; qmpsock = init_socket ( qmp_socket_path ) ; sigact = ( struct sigaction ) { . sa_handler = sigabrt_handler , . sa_flags = SA_RESETHAND , } ; sigemptyset ( & sigact . sa_mask ) ; sigaction ( SIGABRT , & sigact , & s -> sigact_old ) ; s -> qemu_pid = fork ( ) ; if ( s -> qemu_pid == 0 ) { command = g_strdup_printf ( "exec %s " "-qtest unix:%s,nowait " "-qtest-log /dev/null " "-qmp unix:%s,nowait " "-machine accel=qtest " "-display none " "%s" , qemu_binary , socket_path , qmp_socket_path , extra_args ? : "" ) ; execlp ( "/bin/sh" , "sh" , "-c" , command , NULL ) ; exit ( 1 ) ; } s -> fd = socket_accept ( sock ) ; s -> qmp_fd = socket_accept ( qmpsock ) ; unlink ( socket_path ) ; unlink ( qmp_socket_path ) ; g_free ( socket_path ) ; g_free ( qmp_socket_path ) ; s -> rx = g_string_new ( "" ) ; for ( i = 0 ; i < MAX_IRQ ; i ++ ) { s -> irq_level [ i ] = false ; } qtest_qmp_discard_response ( s , "" ) ; qtest_qmp_discard_response ( s , "{ 'execute': 'qmp_capabilities' }" ) ; if ( getenv ( "QTEST_STOP" ) ) { kill ( s -> qemu_pid , SIGSTOP ) ; } return s ; }##::##1##::##9104
static int qemu_rdma_unregister_waiting ( RDMAContext * rdma ) { while ( rdma -> unregistrations [ rdma -> unregister_current ] ) { int ret ; uint64_t wr_id = rdma -> unregistrations [ rdma -> unregister_current ] ; uint64_t chunk = ( wr_id & RDMA_WRID_CHUNK_MASK ) >> RDMA_WRID_CHUNK_SHIFT ; uint64_t index = ( wr_id & RDMA_WRID_BLOCK_MASK ) >> RDMA_WRID_BLOCK_SHIFT ; RDMALocalBlock * block = & ( rdma -> local_ram_blocks . block [ index ] ) ; RDMARegister reg = { . current_index = index } ; RDMAControlHeader resp = { . type = RDMA_CONTROL_UNREGISTER_FINISHED , } ; RDMAControlHeader head = { . len = sizeof ( RDMARegister ) , . type = RDMA_CONTROL_UNREGISTER_REQUEST , . repeat = 1 , } ; DDPRINTF ( "Processing unregister for chunk: %" PRIu64 " at position %d\n" , chunk , rdma -> unregister_current ) ; rdma -> unregistrations [ rdma -> unregister_current ] = 0 ; rdma -> unregister_current ++ ; if ( rdma -> unregister_current == RDMA_SIGNALED_SEND_MAX ) { rdma -> unregister_current = 0 ; } clear_bit ( chunk , block -> unregister_bitmap ) ; if ( test_bit ( chunk , block -> transit_bitmap ) ) { DDPRINTF ( "Cannot unregister inflight chunk: %" PRIu64 "\n" , chunk ) ; continue ; } DDPRINTF ( "Sending unregister for chunk: %" PRIu64 "\n" , chunk ) ; ret = ibv_dereg_mr ( block -> pmr [ chunk ] ) ; block -> pmr [ chunk ] = NULL ; block -> remote_keys [ chunk ] = 0 ; if ( ret != 0 ) { perror ( "unregistration chunk failed" ) ; return - ret ; } rdma -> total_registrations -- ; reg . key . chunk = chunk ; register_to_network ( & reg ) ; ret = qemu_rdma_exchange_send ( rdma , & head , ( uint8_t * ) & reg , & resp , NULL , NULL ) ; if ( ret < 0 ) { return ret ; } DDPRINTF ( "Unregister for chunk: %" PRIu64 " complete.\n" , chunk ) ; } return 0 ; }##::##1##::##7752
static void rv34_pred_4x4_block ( RV34DecContext * r , uint8_t * dst , int stride , int itype , int up , int left , int down , int right ) { uint8_t * prev = dst - stride + 4 ; uint32_t topleft ; if ( ! up && ! left ) { itype = DC_128_PRED ; } else if ( ! up ) { if ( itype == VERT_PRED ) { itype = HOR_PRED ; } if ( itype == DC_PRED ) { itype = LEFT_DC_PRED ; } } else if ( ! left ) { if ( itype == HOR_PRED ) { itype = VERT_PRED ; } if ( itype == DC_PRED ) { itype = TOP_DC_PRED ; } if ( itype == DIAG_DOWN_LEFT_PRED ) { itype = DIAG_DOWN_LEFT_PRED_RV40_NODOWN ; } } if ( ! down ) { if ( itype == DIAG_DOWN_LEFT_PRED ) { itype = DIAG_DOWN_LEFT_PRED_RV40_NODOWN ; } if ( itype == HOR_UP_PRED ) { itype = HOR_UP_PRED_RV40_NODOWN ; } if ( itype == VERT_LEFT_PRED ) { itype = VERT_LEFT_PRED_RV40_NODOWN ; } } if ( ! right && up ) { topleft = dst [ - stride + 3 ] * 0x01010101 ; prev = ( uint8_t * ) & topleft ; } r -> h . pred4x4 [ itype ] ( dst , prev , stride ) ; }##::##1##::##9978
int opt_opencl_bench ( void * optctx , const char * opt , const char * arg ) { int i , j , nb_devices = 0 , count = 0 ; int64_t score = 0 ; AVOpenCLDeviceList * device_list ; AVOpenCLDeviceNode * device_node = NULL ; OpenCLDeviceBenchmark * devices = NULL ; cl_platform_id platform ; av_opencl_get_device_list ( & device_list ) ; for ( i = 0 ; i < device_list -> platform_num ; i ++ ) { nb_devices += device_list -> platform_node [ i ] -> device_num ; } if ( ! nb_devices ) { av_log ( NULL , AV_LOG_ERROR , "No OpenCL device detected!\n" ) ; return AVERROR ( EINVAL ) ; } if ( ! ( devices = av_malloc_array ( nb_devices , sizeof ( OpenCLDeviceBenchmark ) ) ) ) { av_log ( NULL , AV_LOG_ERROR , "Could not allocate buffer\n" ) ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < device_list -> platform_num ; i ++ ) { for ( j = 0 ; j < device_list -> platform_node [ i ] -> device_num ; j ++ ) { device_node = device_list -> platform_node [ i ] -> device_node [ j ] ; platform = device_list -> platform_node [ i ] -> platform_id ; score = av_opencl_benchmark ( device_node , platform , run_opencl_bench ) ; if ( score > 0 ) { devices [ count ] . platform_idx = i ; devices [ count ] . device_idx = j ; devices [ count ] . runtime = score ; av_strlcpy ( devices [ count ] . device_name , device_node -> device_name , sizeof ( devices [ count ] . device_name ) ) ; count ++ ; } } } qsort ( devices , count , sizeof ( OpenCLDeviceBenchmark ) , compare_ocl_device_desc ) ; fprintf ( stderr , "platform_idx\tdevice_idx\tdevice_name\truntime\n" ) ; for ( i = 0 ; i < count ; i ++ ) fprintf ( stdout , "%d\t%d\t%s\t%" PRId64 "\n" , devices [ i ] . platform_idx , devices [ i ] . device_idx , devices [ i ] . device_name , devices [ i ] . runtime ) ; av_opencl_free_device_list ( & device_list ) ; av_free ( devices ) ; return 0 ; }##::##1##::##11503
static int ipvideo_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { const uint8_t * buf = avpkt -> data ; int buf_size = avpkt -> size ; IpvideoContext * s = avctx -> priv_data ; AVFrame * frame = data ; int ret ; if ( buf_size < 2 ) { return AVERROR_INVALIDDATA ; } s -> decoding_map_size = AV_RL16 ( avpkt -> data ) ; if ( buf_size < s -> decoding_map_size + 2 ) { return buf_size ; } if ( av_packet_get_side_data ( avpkt , AV_PKT_DATA_PARAM_CHANGE , NULL ) ) { av_frame_unref ( s -> last_frame ) ; av_frame_unref ( s -> second_last_frame ) ; } s -> decoding_map = buf + 2 ; bytestream2_init ( & s -> stream_ptr , buf + 2 + s -> decoding_map_size , buf_size - s -> decoding_map_size ) ; if ( ( ret = ff_get_buffer ( avctx , frame , AV_GET_BUFFER_FLAG_REF ) ) < 0 ) { return ret ; } if ( ! s -> is_16bpp ) { int size ; const uint8_t * pal = av_packet_get_side_data ( avpkt , AV_PKT_DATA_PALETTE , & size ) ; if ( pal && size == AVPALETTE_SIZE ) { frame -> palette_has_changed = 1 ; memcpy ( s -> pal , pal , AVPALETTE_SIZE ) ; } else if ( pal ) { av_log ( avctx , AV_LOG_ERROR , "Palette size %d is wrong\n" , size ) ; } } ipvideo_decode_opcodes ( s , frame ) ; * got_frame = 1 ; av_frame_unref ( s -> second_last_frame ) ; FFSWAP ( AVFrame * , s -> second_last_frame , s -> last_frame ) ; if ( ( ret = av_frame_ref ( s -> last_frame , frame ) ) < 0 ) { return ret ; } return buf_size ; }##::##1##::##7765
static void setup_frame ( int sig , struct target_sigaction * ka , target_sigset_t * set , CPUMBState * env ) { struct target_signal_frame * frame ; abi_ulong frame_addr ; int err = 0 ; int i ; frame_addr = get_sigframe ( ka , env , sizeof * frame ) ; if ( ! lock_user_struct ( VERIFY_WRITE , frame , frame_addr , 0 ) ) { goto badframe ; } __put_user ( set -> sig [ 0 ] , & frame -> uc . tuc_mcontext . oldmask ) ; if ( err ) { goto badframe ; } for ( i = 1 ; i < TARGET_NSIG_WORDS ; i ++ ) { if ( __put_user ( set -> sig [ i ] , & frame -> extramask [ i - 1 ] ) ) { goto badframe ; } } setup_sigcontext ( & frame -> uc . tuc_mcontext , env ) ; if ( ka -> sa_flags & TARGET_SA_RESTORER ) { env -> regs [ 15 ] = ( ( unsigned long ) ka -> sa_restorer ) - 8 ; } else { uint32_t t ; t = 0x31800000UL | TARGET_NR_sigreturn ; __put_user ( t , frame -> tramp + 0 ) ; t = 0xb9cc0008UL ; __put_user ( t , frame -> tramp + 1 ) ; env -> regs [ 15 ] = ( ( unsigned long ) frame -> tramp ) - 8 ; } if ( err ) { goto badframe ; } env -> regs [ 1 ] = frame_addr ; env -> regs [ 5 ] = sig ; env -> regs [ 6 ] = 0 ; env -> regs [ 7 ] = frame_addr += offsetof ( typeof ( * frame ) , uc ) ; env -> sregs [ SR_PC ] = ( unsigned long ) ka -> _sa_handler ; unlock_user_struct ( frame , frame_addr , 1 ) ; return ; badframe : unlock_user_struct ( frame , frame_addr , 1 ) ; force_sig ( TARGET_SIGSEGV ) ; }##::##1##::##664
static int vnc_update_stats ( VncDisplay * vd , struct timeval * tv ) { int width = pixman_image_get_width ( vd -> guest . fb ) ; int height = pixman_image_get_height ( vd -> guest . fb ) ; int x , y ; struct timeval res ; int has_dirty = 0 ; for ( y = 0 ; y < height ; y += VNC_STAT_RECT ) { for ( x = 0 ; x < width ; x += VNC_STAT_RECT ) { VncRectStat * rect = vnc_stat_rect ( vd , x , y ) ; rect -> updated = false ; } } qemu_timersub ( tv , & VNC_REFRESH_STATS , & res ) ; if ( timercmp ( & vd -> guest . last_freq_check , & res , > ) ) { return has_dirty ; } vd -> guest . last_freq_check = * tv ; for ( y = 0 ; y < height ; y += VNC_STAT_RECT ) { for ( x = 0 ; x < width ; x += VNC_STAT_RECT ) { VncRectStat * rect = vnc_stat_rect ( vd , x , y ) ; int count = ARRAY_SIZE ( rect -> times ) ; struct timeval min , max ; if ( ! timerisset ( & rect -> times [ count - 1 ] ) ) { continue ; } max = rect -> times [ ( rect -> idx + count - 1 ) % count ] ; qemu_timersub ( tv , & max , & res ) ; if ( timercmp ( & res , & VNC_REFRESH_LOSSY , > ) ) { rect -> freq = 0 ; has_dirty += vnc_refresh_lossy_rect ( vd , x , y ) ; memset ( rect -> times , 0 , sizeof ( rect -> times ) ) ; continue ; } min = rect -> times [ rect -> idx ] ; max = rect -> times [ ( rect -> idx + count - 1 ) % count ] ; qemu_timersub ( & max , & min , & res ) ; rect -> freq = res . tv_sec + res . tv_usec / 1000000. ; rect -> freq /= count ; rect -> freq = 1. / rect -> freq ; } } return has_dirty ; }##::##1##::##3898
static int fileTest ( uint8_t * ref [ 4 ] , int refStride [ 4 ] , int w , int h , FILE * fp , enum AVPixelFormat srcFormat_in , enum AVPixelFormat dstFormat_in ) { char buf [ 256 ] ; while ( fgets ( buf , sizeof ( buf ) , fp ) ) { struct Results r ; enum AVPixelFormat srcFormat ; char srcStr [ 12 ] ; int srcW , srcH ; enum AVPixelFormat dstFormat ; char dstStr [ 12 ] ; int dstW , dstH ; int flags ; int ret ; ret = sscanf ( buf , " %12s %dx%d -> %12s %dx%d flags=%d CRC=%x" " SSD=%" SCNu64 ", %" SCNu64 ", %" SCNu64 ", %" SCNu64 "\n" , srcStr , & srcW , & srcH , dstStr , & dstW , & dstH , & flags , & r . crc , & r . ssdY , & r . ssdU , & r . ssdV , & r . ssdA ) ; if ( ret != 12 ) { srcStr [ 0 ] = dstStr [ 0 ] = 0 ; ret = sscanf ( buf , "%12s -> %12s\n" , srcStr , dstStr ) ; } srcFormat = av_get_pix_fmt ( srcStr ) ; dstFormat = av_get_pix_fmt ( dstStr ) ; if ( srcFormat == AV_PIX_FMT_NONE || dstFormat == AV_PIX_FMT_NONE || srcW > 8192U || srcH > 8192U || dstW > 8192U || dstH > 8192U ) { fprintf ( stderr , "malformed input file\n" ) ; return - 1 ; } if ( ( srcFormat_in != AV_PIX_FMT_NONE && srcFormat_in != srcFormat ) || ( dstFormat_in != AV_PIX_FMT_NONE && dstFormat_in != dstFormat ) ) { continue ; } if ( ret != 12 ) { printf ( "%s" , buf ) ; continue ; } doTest ( ref , refStride , w , h , srcFormat , dstFormat , srcW , srcH , dstW , dstH , flags , & r ) ; } return 0 ; }##::##1##::##9277
static int decode_b_picture_secondary_header ( VC9Context * v ) { GetBitContext * gb = & v -> s . gb ; int status ; bitplane_decoding ( & v -> skip_mb_plane , v ) ; if ( status < 0 ) { return - 1 ; } # if TRACE if ( v -> mv_mode == MV_PMODE_MIXED_MV ) { status = bitplane_decoding ( & v -> mv_type_mb_plane , v ) ; if ( status < 0 ) { return - 1 ; } # if TRACE av_log ( v -> s . avctx , AV_LOG_DEBUG , "MB MV Type plane encoding: " "Imode: %i, Invert: %i\n" , status >> 1 , status & 1 ) ; # endif } status = bitplane_decoding ( & v -> direct_mb_plane , v ) ; if ( status < 0 ) { return - 1 ; } # if TRACE av_log ( v -> s . avctx , AV_LOG_DEBUG , "MB Direct plane encoding: " "Imode: %i, Invert: %i\n" , status >> 1 , status & 1 ) ; # endif av_log ( v -> s . avctx , AV_LOG_DEBUG , "Skip MB plane encoding: " "Imode: %i, Invert: %i\n" , status >> 1 , status & 1 ) ; # endif v -> s . mv_table_index = get_bits ( gb , 2 ) ; v -> cbpcy_vlc = & vc9_cbpcy_p_vlc [ get_bits ( gb , 2 ) ] ; if ( v -> dquant ) { vop_dquant_decoding ( v ) ; } if ( v -> vstransform ) { v -> ttmbf = get_bits ( gb , 1 ) ; if ( v -> ttmbf ) { v -> ttfrm = get_bits ( gb , 2 ) ; av_log ( v -> s . avctx , AV_LOG_INFO , "Transform used: %ix%i\n" , ( v -> ttfrm & 2 ) ? 4 : 8 , ( v -> ttfrm & 1 ) ? 4 : 8 ) ; } } return 0 ; }##::##1##::##7650
static int mpeg_decode_frame ( AVCodecContext * avctx , void * data , int * got_output , AVPacket * avpkt ) { const uint8_t * buf = avpkt -> data ; int buf_size = avpkt -> size ; Mpeg1Context * s = avctx -> priv_data ; AVFrame * picture = data ; MpegEncContext * s2 = & s -> mpeg_enc_ctx ; av_dlog ( avctx , "fill_buffer\n" ) ; if ( buf_size == 0 || ( buf_size == 4 && AV_RB32 ( buf ) == SEQ_END_CODE ) ) { if ( s2 -> low_delay == 0 && s2 -> next_picture_ptr ) { int ret = av_frame_ref ( picture , & s2 -> next_picture_ptr -> f ) ; if ( ret < 0 ) { return ret ; } s2 -> next_picture_ptr = NULL ; * got_output = 1 ; } return buf_size ; } if ( s2 -> flags & CODEC_FLAG_TRUNCATED ) { int next = ff_mpeg1_find_frame_end ( & s2 -> parse_context , buf , buf_size , NULL ) ; if ( ff_combine_frame ( & s2 -> parse_context , next , ( const uint8_t * * ) & buf , & buf_size ) < 0 ) { return buf_size ; } } if ( s -> mpeg_enc_ctx_allocated == 0 && avctx -> codec_tag == AV_RL32 ( "VCR2" ) ) { vcr2_init_sequence ( avctx ) ; } s -> slice_count = 0 ; if ( avctx -> extradata && ! s -> extradata_decoded ) { int ret = decode_chunks ( avctx , picture , got_output , avctx -> extradata , avctx -> extradata_size ) ; s -> extradata_decoded = 1 ; if ( ret < 0 && ( avctx -> err_recognition & AV_EF_EXPLODE ) ) { return ret ; } } return decode_chunks ( avctx , picture , got_output , buf , buf_size ) ; }##::##1##::##3452
static ExitStatus gen_mtpr ( DisasContext * ctx , TCGv vb , int regno ) { TCGv tmp ; int data ; switch ( regno ) { case 255 : gen_helper_tbia ( cpu_env ) ; break ; case 254 : gen_helper_tbis ( cpu_env , vb ) ; break ; case 253 : tmp = tcg_const_i64 ( 1 ) ; tcg_gen_st32_i64 ( tmp , cpu_env , - offsetof ( AlphaCPU , env ) + offsetof ( CPUState , halted ) ) ; return gen_excp ( ctx , EXCP_HALTED , 0 ) ; case 252 : gen_helper_halt ( vb ) ; return EXIT_PC_STALE ; case 251 : gen_helper_set_alarm ( cpu_env , vb ) ; break ; case 7 : tcg_gen_st_i64 ( vb , cpu_env , offsetof ( CPUAlphaState , palbr ) ) ; gen_helper_tb_flush ( cpu_env ) ; return EXIT_PC_STALE ; case 32 ... 39 : regno = regno == 39 ? 25 : regno - 32 + 8 ; tcg_gen_mov_i64 ( cpu_std_ir [ regno ] , vb ) ; break ; case 0 : st_flag_byte ( vb , ENV_FLAG_PS_SHIFT ) ; break ; case 1 : st_flag_byte ( vb , ENV_FLAG_FEN_SHIFT ) ; break ; default : data = cpu_pr_data ( regno ) ; if ( data != 0 ) { if ( data & PR_LONG ) { tcg_gen_st32_i64 ( vb , cpu_env , data & ~ PR_LONG ) ; } else { tcg_gen_st_i64 ( vb , cpu_env , data ) ; } } break ; } return NO_EXIT ; }##::##1##::##475
static int video_open ( VideoState * is ) { int w , h ; if ( screen_width ) { w = screen_width ; h = screen_height ; } else { w = default_width ; h = default_height ; } if ( ! window ) { int flags = SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE ; if ( ! window_title ) { window_title = input_filename ; } if ( is_full_screen ) { flags |= SDL_WINDOW_FULLSCREEN_DESKTOP ; } window = SDL_CreateWindow ( window_title , SDL_WINDOWPOS_UNDEFINED , SDL_WINDOWPOS_UNDEFINED , w , h , flags ) ; SDL_SetHint ( SDL_HINT_RENDER_SCALE_QUALITY , "linear" ) ; if ( window ) { SDL_RendererInfo info ; renderer = SDL_CreateRenderer ( window , - 1 , SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC ) ; if ( ! renderer ) { av_log ( NULL , AV_LOG_WARNING , "Failed to initialize a hardware accelerated renderer: %s\n" , SDL_GetError ( ) ) ; renderer = SDL_CreateRenderer ( window , - 1 , 0 ) ; } if ( renderer ) { if ( ! SDL_GetRendererInfo ( renderer , & info ) ) { av_log ( NULL , AV_LOG_VERBOSE , "Initialized %s renderer.\n" , info . name ) ; } } } } else { SDL_SetWindowSize ( window , w , h ) ; } if ( ! window || ! renderer ) { av_log ( NULL , AV_LOG_FATAL , "SDL: could not set video mode - exiting\n" ) ; do_exit ( is ) ; } is -> width = w ; is -> height = h ; return 0 ; }##::##1##::##9751
static int update_error_limit ( WavpackFrameContext * ctx ) { int i , br [ 2 ] , sl [ 2 ] ; for ( i = 0 ; i <= ctx -> stereo_in ; i ++ ) { if ( ctx -> ch [ i ] . bitrate_acc > UINT_MAX - ctx -> ch [ i ] . bitrate_delta ) { return AVERROR_INVALIDDATA ; } ctx -> ch [ i ] . bitrate_acc += ctx -> ch [ i ] . bitrate_delta ; br [ i ] = ctx -> ch [ i ] . bitrate_acc >> 16 ; sl [ i ] = LEVEL_DECAY ( ctx -> ch [ i ] . slow_level ) ; } if ( ctx -> stereo_in && ctx -> hybrid_bitrate ) { int balance = ( sl [ 1 ] - sl [ 0 ] + br [ 1 ] + 1 ) >> 1 ; if ( balance > br [ 0 ] ) { br [ 1 ] = br [ 0 ] << 1 ; br [ 0 ] = 0 ; } else if ( - balance > br [ 0 ] ) { br [ 0 ] <<= 1 ; br [ 1 ] = 0 ; } else { br [ 1 ] = br [ 0 ] + balance ; br [ 0 ] = br [ 0 ] - balance ; } } for ( i = 0 ; i <= ctx -> stereo_in ; i ++ ) { if ( ctx -> hybrid_bitrate ) { if ( sl [ i ] - br [ i ] > - 0x100 ) { ctx -> ch [ i ] . error_limit = wp_exp2 ( sl [ i ] - br [ i ] + 0x100 ) ; } else { ctx -> ch [ i ] . error_limit = 0 ; } } else { ctx -> ch [ i ] . error_limit = wp_exp2 ( br [ i ] ) ; } } return 0 ; }##::##1##::##7457
static int decode_frame ( AVCodecContext * avctx , void * data , int * data_size , AVPacket * avpkt ) { const uint8_t * buf = avpkt -> data ; int buf_size = avpkt -> size ; MPADecodeContext * s = avctx -> priv_data ; uint32_t header ; int out_size ; OUT_INT * out_samples = data ; if ( buf_size < HEADER_SIZE ) { return - 1 ; } header = AV_RB32 ( buf ) ; if ( ff_mpa_check_header ( header ) < 0 ) { av_log ( avctx , AV_LOG_ERROR , "Header missing\n" ) ; return - 1 ; } if ( ff_mpegaudio_decode_header ( ( MPADecodeHeader * ) s , header ) == 1 ) { s -> frame_size = - 1 ; return - 1 ; } avctx -> channels = s -> nb_channels ; avctx -> bit_rate = s -> bit_rate ; avctx -> sub_id = s -> layer ; if ( * data_size < 1152 * avctx -> channels * sizeof ( OUT_INT ) ) { return - 1 ; } if ( s -> frame_size <= 0 || s -> frame_size > buf_size ) { av_log ( avctx , AV_LOG_ERROR , "incomplete frame\n" ) ; return - 1 ; } else if ( s -> frame_size < buf_size ) { av_log ( avctx , AV_LOG_ERROR , "incorrect frame size\n" ) ; buf_size = s -> frame_size ; } out_size = mp_decode_frame ( s , out_samples , buf , buf_size ) ; if ( out_size >= 0 ) { * data_size = out_size ; avctx -> sample_rate = s -> sample_rate ; } else { av_log ( avctx , AV_LOG_DEBUG , "Error while decoding MPEG audio frame.\n" ) ; } s -> frame_size = 0 ; return buf_size ; }##::##1##::##7634
static av_cold void compute_alpha_vlcs ( void ) { uint16_t run_code [ 129 ] , level_code [ 256 ] ; uint8_t run_bits [ 129 ] , level_bits [ 256 ] ; int run , level ; for ( run = 0 ; run < 128 ; run ++ ) { if ( ! run ) { run_code [ run ] = 0 ; run_bits [ run ] = 1 ; } else if ( run <= 4 ) { run_code [ run ] = ( ( run - 1 ) << 2 ) | 1 ; run_bits [ run ] = 4 ; } else { run_code [ run ] = ( run << 3 ) | 7 ; run_bits [ run ] = 10 ; } } run_code [ 128 ] = 3 ; run_bits [ 128 ] = 3 ; INIT_LE_VLC_STATIC ( & ff_dc_alpha_run_vlc_le , ALPHA_VLC_BITS , 129 , run_bits , 1 , 1 , run_code , 2 , 2 , 160 ) ; for ( level = 0 ; level < 256 ; level ++ ) { int8_t signed_level = ( int8_t ) level ; int abs_signed_level = abs ( signed_level ) ; int sign = ( signed_level < 0 ) ? 1 : 0 ; if ( abs_signed_level == 1 ) { level_code [ level ] = ( sign << 1 ) | 1 ; level_bits [ level ] = 2 ; } else if ( abs_signed_level >= 2 && abs_signed_level <= 5 ) { level_code [ level ] = ( ( abs_signed_level - 2 ) << 3 ) | ( sign << 2 ) | 2 ; level_bits [ level ] = 5 ; } else { level_code [ level ] = level << 2 ; level_bits [ level ] = 10 ; } } INIT_LE_VLC_STATIC ( & ff_dc_alpha_level_vlc_le , ALPHA_VLC_BITS , 256 , level_bits , 1 , 1 , level_code , 2 , 2 , 288 ) ; }##::##1##::##3055
void init_vlc_rl ( RLTable * rl ) { int i , q ; init_vlc ( & rl -> vlc , 9 , rl -> n + 1 , & rl -> table_vlc [ 0 ] [ 1 ] , 4 , 2 , & rl -> table_vlc [ 0 ] [ 0 ] , 4 , 2 ) ; for ( q = 0 ; q < 32 ; q ++ ) { int qmul = q * 2 ; int qadd = ( q - 1 ) | 1 ; if ( q == 0 ) { qmul = 1 ; qadd = 0 ; } rl -> rl_vlc [ q ] = av_malloc ( rl -> vlc . table_size * sizeof ( RL_VLC_ELEM ) ) ; for ( i = 0 ; i < rl -> vlc . table_size ; i ++ ) { int code = rl -> vlc . table [ i ] [ 0 ] ; int len = rl -> vlc . table [ i ] [ 1 ] ; int level , run ; if ( len == 0 ) { run = 66 ; level = MAX_LEVEL ; } else if ( len < 0 ) { run = 0 ; level = code ; } else { if ( code == rl -> n ) { run = 66 ; level = 0 ; } else { run = rl -> table_run [ code ] + 1 ; level = rl -> table_level [ code ] * qmul + qadd ; if ( code >= rl -> last ) { run += 192 ; } } } rl -> rl_vlc [ q ] [ i ] . len = len ; rl -> rl_vlc [ q ] [ i ] . level = level ; rl -> rl_vlc [ q ] [ i ] . run = run ; } } }##::##1##::##8980
Object * user_creatable_add_type ( const char * type , const char * id , const QDict * qdict , Visitor * v , Error * * errp ) { Object * obj ; ObjectClass * klass ; const QDictEntry * e ; Error * local_err = NULL ; klass = object_class_by_name ( type ) ; if ( ! klass ) { error_setg ( errp , "invalid object type: %s" , type ) ; return NULL ; } if ( ! object_class_dynamic_cast ( klass , TYPE_USER_CREATABLE ) ) { error_setg ( errp , "object type '%s' isn't supported by object-add" , type ) ; return NULL ; } if ( object_class_is_abstract ( klass ) ) { error_setg ( errp , "object type '%s' is abstract" , type ) ; return NULL ; } obj = object_new ( type ) ; if ( qdict ) { for ( e = qdict_first ( qdict ) ; e ; e = qdict_next ( qdict , e ) ) { object_property_set ( obj , v , e -> key , & local_err ) ; if ( local_err ) { goto out ; } } } object_property_add_child ( object_get_objects_root ( ) , id , obj , & local_err ) ; if ( local_err ) { goto out ; } user_creatable_complete ( obj , & local_err ) ; if ( local_err ) { object_property_del ( object_get_objects_root ( ) , id , & error_abort ) ; goto out ; } out : if ( local_err ) { error_propagate ( errp , local_err ) ; object_unref ( obj ) ; return NULL ; } return obj ; }##::##1##::##7107
static int config_input_ref ( AVFilterLink * inlink ) { const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( inlink -> format ) ; AVFilterContext * ctx = inlink -> dst ; PSNRContext * s = ctx -> priv ; unsigned sum ; int j ; s -> nb_components = desc -> nb_components ; if ( ctx -> inputs [ 0 ] -> w != ctx -> inputs [ 1 ] -> w || ctx -> inputs [ 0 ] -> h != ctx -> inputs [ 1 ] -> h ) { av_log ( ctx , AV_LOG_ERROR , "Width and height of input videos must be same.\n" ) ; return AVERROR ( EINVAL ) ; } if ( ctx -> inputs [ 0 ] -> format != ctx -> inputs [ 1 ] -> format ) { av_log ( ctx , AV_LOG_ERROR , "Inputs must be of same pixel format.\n" ) ; return AVERROR ( EINVAL ) ; } s -> max [ 0 ] = ( 1 << ( desc -> comp [ 0 ] . depth_minus1 + 1 ) ) - 1 ; s -> max [ 1 ] = ( 1 << ( desc -> comp [ 1 ] . depth_minus1 + 1 ) ) - 1 ; s -> max [ 2 ] = ( 1 << ( desc -> comp [ 2 ] . depth_minus1 + 1 ) ) - 1 ; s -> max [ 3 ] = ( 1 << ( desc -> comp [ 3 ] . depth_minus1 + 1 ) ) - 1 ; s -> is_rgb = ff_fill_rgba_map ( s -> rgba_map , inlink -> format ) >= 0 ; s -> comps [ 0 ] = s -> is_rgb ? 'r' : 'y' ; s -> comps [ 1 ] = s -> is_rgb ? 'g' : 'u' ; s -> comps [ 2 ] = s -> is_rgb ? 'b' : 'v' ; s -> comps [ 3 ] = 'a' ; s -> planeheight [ 1 ] = s -> planeheight [ 2 ] = FF_CEIL_RSHIFT ( inlink -> h , desc -> log2_chroma_h ) ; s -> planeheight [ 0 ] = s -> planeheight [ 3 ] = inlink -> h ; s -> planewidth [ 1 ] = s -> planewidth [ 2 ] = FF_CEIL_RSHIFT ( inlink -> w , desc -> log2_chroma_w ) ; s -> planewidth [ 0 ] = s -> planewidth [ 3 ] = inlink -> w ; sum = 0 ; for ( j = 0 ; j < s -> nb_components ; j ++ ) { sum += s -> planeheight [ j ] * s -> planewidth [ j ] ; } for ( j = 0 ; j < s -> nb_components ; j ++ ) { s -> planeweight [ j ] = ( double ) s -> planeheight [ j ] * s -> planewidth [ j ] / sum ; s -> average_max += s -> max [ j ] * s -> planeweight [ j ] ; } s -> compute_mse = desc -> comp [ 0 ] . depth_minus1 > 7 ? compute_images_mse_16bit : compute_images_mse ; return 0 ; }##::##1##::##7466
static int con_initialise ( struct XenDevice * xendev ) { struct XenConsole * con = container_of ( xendev , struct XenConsole , xendev ) ; int limit ; if ( xenstore_read_int ( con -> console , "ring-ref" , & con -> ring_ref ) == - 1 ) { return - 1 ; } if ( xenstore_read_int ( con -> console , "port" , & con -> xendev . remote_port ) == - 1 ) { return - 1 ; } if ( xenstore_read_int ( con -> console , "limit" , & limit ) == 0 ) { con -> buffer . max_capacity = limit ; } if ( ! xendev -> dev ) { con -> sring = xc_map_foreign_range ( xen_xc , con -> xendev . dom , XC_PAGE_SIZE , PROT_READ | PROT_WRITE , con -> ring_ref ) ; } else { con -> sring = xengnttab_map_grant_ref ( xendev -> gnttabdev , con -> xendev . dom , con -> ring_ref , PROT_READ | PROT_WRITE ) ; } if ( ! con -> sring ) { return - 1 ; } xen_be_bind_evtchn ( & con -> xendev ) ; if ( con -> chr ) { if ( qemu_chr_fe_claim ( con -> chr ) == 0 ) { qemu_chr_add_handlers ( con -> chr , xencons_can_receive , xencons_receive , NULL , con ) ; } else { xen_be_printf ( xendev , 0 , "xen_console_init error chardev %s already used\n" , con -> chr -> label ) ; con -> chr = NULL ; } } xen_be_printf ( xendev , 1 , "ring mfn %d, remote port %d, local port %d, limit %zd\n" , con -> ring_ref , con -> xendev . remote_port , con -> xendev . local_port , con -> buffer . max_capacity ) ; return 0 ; }##::##1##::##5742
static void vapic_write ( void * opaque , hwaddr addr , uint64_t data , unsigned int size ) { CPUState * cs = current_cpu ; X86CPU * cpu = X86_CPU ( cs ) ; CPUX86State * env = & cpu -> env ; hwaddr rom_paddr ; VAPICROMState * s = opaque ; cpu_synchronize_state ( cs ) ; switch ( size ) { case 2 : if ( s -> state == VAPIC_INACTIVE ) { rom_paddr = ( env -> segs [ R_CS ] . base + env -> eip ) & ROM_BLOCK_MASK ; s -> rom_state_paddr = rom_paddr + data ; s -> state = VAPIC_STANDBY ; } if ( vapic_prepare ( s ) < 0 ) { s -> state = VAPIC_INACTIVE ; s -> rom_state_paddr = 0 ; break ; } break ; case 1 : if ( kvm_enabled ( ) ) { pause_all_vcpus ( ) ; patch_byte ( cpu , env -> eip - 2 , 0x66 ) ; patch_byte ( cpu , env -> eip - 1 , 0x90 ) ; resume_all_vcpus ( ) ; } if ( s -> state == VAPIC_ACTIVE ) { break ; } if ( update_rom_mapping ( s , env , env -> eip ) < 0 ) { break ; } if ( find_real_tpr_addr ( s , env ) < 0 ) { break ; } vapic_enable ( s , cpu ) ; break ; default : case 4 : if ( ! kvm_irqchip_in_kernel ( ) ) { apic_poll_irq ( cpu -> apic_state ) ; } break ; } }##::##1##::##36
static av_always_inline void rv40_weak_loop_filter ( uint8_t * src , const int step , const ptrdiff_t stride , const int filter_p1 , const int filter_q1 , const int alpha , const int beta , const int lim_p0q0 , const int lim_q1 , const int lim_p1 ) { const uint8_t * cm = ff_crop_tab + MAX_NEG_CROP ; int i , t , u , diff ; for ( i = 0 ; i < 4 ; i ++ , src += stride ) { int diff_p1p0 = src [ - 2 * step ] - src [ - 1 * step ] ; int diff_q1q0 = src [ 1 * step ] - src [ 0 * step ] ; int diff_p1p2 = src [ - 2 * step ] - src [ - 3 * step ] ; int diff_q1q2 = src [ 1 * step ] - src [ 2 * step ] ; t = src [ 0 * step ] - src [ - 1 * step ] ; if ( ! t ) { continue ; } u = ( alpha * FFABS ( t ) ) >> 7 ; if ( u > 3 - ( filter_p1 && filter_q1 ) ) { continue ; } t <<= 2 ; if ( filter_p1 && filter_q1 ) { t += src [ - 2 * step ] - src [ 1 * step ] ; } diff = CLIP_SYMM ( ( t + 4 ) >> 3 , lim_p0q0 ) ; src [ - 1 * step ] = cm [ src [ - 1 * step ] + diff ] ; src [ 0 * step ] = cm [ src [ 0 * step ] - diff ] ; if ( filter_p1 && FFABS ( diff_p1p2 ) <= beta ) { t = ( diff_p1p0 + diff_p1p2 - diff ) >> 1 ; src [ - 2 * step ] = cm [ src [ - 2 * step ] - CLIP_SYMM ( t , lim_p1 ) ] ; } if ( filter_q1 && FFABS ( diff_q1q2 ) <= beta ) { t = ( diff_q1q0 + diff_q1q2 + diff ) >> 1 ; src [ 1 * step ] = cm [ src [ 1 * step ] - CLIP_SYMM ( t , lim_q1 ) ] ; } } }##::##1##::##2816
static int decode_frame_png ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { PNGDecContext * const s = avctx -> priv_data ; const uint8_t * buf = avpkt -> data ; int buf_size = avpkt -> size ; AVFrame * p ; int64_t sig ; int ret ; ff_thread_release_buffer ( avctx , & s -> last_picture ) ; FFSWAP ( ThreadFrame , s -> picture , s -> last_picture ) ; p = s -> picture . f ; bytestream2_init ( & s -> gb , buf , buf_size ) ; sig = bytestream2_get_be64 ( & s -> gb ) ; if ( sig != PNGSIG && sig != MNGSIG ) { av_log ( avctx , AV_LOG_ERROR , "Invalid PNG signature 0x%08" PRIX64 ".\n" , sig ) ; return AVERROR_INVALIDDATA ; } s -> y = s -> has_trns = 0 ; s -> hdr_state = 0 ; s -> pic_state = 0 ; s -> zstream . zalloc = ff_png_zalloc ; s -> zstream . zfree = ff_png_zfree ; s -> zstream . opaque = NULL ; ret = inflateInit ( & s -> zstream ) ; if ( ret != Z_OK ) { av_log ( avctx , AV_LOG_ERROR , "inflateInit returned error %d\n" , ret ) ; return AVERROR_EXTERNAL ; } if ( ( ret = decode_frame_common ( avctx , s , p , avpkt ) ) < 0 ) { goto the_end ; } if ( avctx -> skip_frame == AVDISCARD_ALL ) { * got_frame = 0 ; ret = bytestream2_tell ( & s -> gb ) ; goto the_end ; } if ( ( ret = av_frame_ref ( data , s -> picture . f ) ) < 0 ) { return ret ; } * got_frame = 1 ; ret = bytestream2_tell ( & s -> gb ) ; the_end : inflateEnd ( & s -> zstream ) ; s -> crow_buf = NULL ; return ret ; }##::##1##::##6583
uint64_t qcow2_get_cluster_offset ( BlockDriverState * bs , uint64_t offset , int * num ) { BDRVQcowState * s = bs -> opaque ; int l1_index , l2_index ; uint64_t l2_offset , * l2_table , cluster_offset ; int l1_bits , c ; int index_in_cluster , nb_available , nb_needed , nb_clusters ; index_in_cluster = ( offset >> 9 ) & ( s -> cluster_sectors - 1 ) ; nb_needed = * num + index_in_cluster ; l1_bits = s -> l2_bits + s -> cluster_bits ; nb_available = ( 1 << l1_bits ) - ( offset & ( ( 1 << l1_bits ) - 1 ) ) ; nb_available = ( nb_available >> 9 ) + index_in_cluster ; if ( nb_needed > nb_available ) { nb_needed = nb_available ; } cluster_offset = 0 ; l1_index = offset >> l1_bits ; if ( l1_index >= s -> l1_size ) { goto out ; } l2_offset = s -> l1_table [ l1_index ] ; if ( ! l2_offset ) { goto out ; } l2_offset &= ~ QCOW_OFLAG_COPIED ; l2_table = l2_load ( bs , l2_offset ) ; if ( l2_table == NULL ) { return 0 ; } l2_index = ( offset >> s -> cluster_bits ) & ( s -> l2_size - 1 ) ; cluster_offset = be64_to_cpu ( l2_table [ l2_index ] ) ; nb_clusters = size_to_clusters ( s , nb_needed << 9 ) ; if ( ! cluster_offset ) { c = count_contiguous_free_clusters ( nb_clusters , & l2_table [ l2_index ] ) ; } else { c = count_contiguous_clusters ( nb_clusters , s -> cluster_size , & l2_table [ l2_index ] , 0 , QCOW_OFLAG_COPIED ) ; } nb_available = ( c * s -> cluster_sectors ) ; out : if ( nb_available > nb_needed ) { nb_available = nb_needed ; } * num = nb_available - index_in_cluster ; return cluster_offset & ~ QCOW_OFLAG_COPIED ; }##::##1##::##314
static inline void RENAME ( rgb24to15 ) ( const uint8_t * src , uint8_t * dst , long src_size ) { const uint8_t * s = src ; const uint8_t * end ; # ifdef HAVE_MMX const uint8_t * mm_end ; # endif uint16_t * d = ( uint16_t * ) dst ; end = s + src_size ; # ifdef HAVE_MMX __asm __volatile ( PREFETCH "	%0" :: "m" ( * src ) : "memory" ) ; __asm __volatile ( "movq	%0, %%mm7\n\t" "movq	%1, %%mm6\n\t" :: "m" ( red_15mask ) , "m" ( green_15mask ) ) ; mm_end = end - 11 ; while ( s < mm_end ) { __asm __volatile ( PREFETCH " 32%1\n\t" "movd	%1, %%mm0\n\t" "movd	3%1, %%mm3\n\t" "punpckldq 6%1, %%mm0\n\t" "punpckldq 9%1, %%mm3\n\t" "movq	%%mm0, %%mm1\n\t" "movq	%%mm0, %%mm2\n\t" "movq	%%mm3, %%mm4\n\t" "movq	%%mm3, %%mm5\n\t" "psrlq	$3, %%mm0\n\t" "psrlq	$3, %%mm3\n\t" "pand	%2, %%mm0\n\t" "pand	%2, %%mm3\n\t" "psrlq	$6, %%mm1\n\t" "psrlq	$6, %%mm4\n\t" "pand	%%mm6, %%mm1\n\t" "pand	%%mm6, %%mm4\n\t" "psrlq	$9, %%mm2\n\t" "psrlq	$9, %%mm5\n\t" "pand	%%mm7, %%mm2\n\t" "pand	%%mm7, %%mm5\n\t" "por	%%mm1, %%mm0\n\t" "por	%%mm4, %%mm3\n\t" "por	%%mm2, %%mm0\n\t" "por	%%mm5, %%mm3\n\t" "psllq	$16, %%mm3\n\t" "por	%%mm3, %%mm0\n\t" MOVNTQ "	%%mm0, %0\n\t" : "=m" ( * d ) : "m" ( * s ) , "m" ( blue_15mask ) : "memory" ) ; d += 4 ; s += 12 ; } __asm __volatile ( SFENCE :: : "memory" ) ; __asm __volatile ( EMMS :: : "memory" ) ; # endif while ( s < end ) { const int b = * s ++ ; const int g = * s ++ ; const int r = * s ++ ; * d ++ = ( b >> 3 ) | ( ( g & 0xF8 ) << 2 ) | ( ( r & 0xF8 ) << 7 ) ; } }##::##1##::##10884
static inline void RENAME ( rgb24tobgr15 ) ( const uint8_t * src , uint8_t * dst , unsigned src_size ) { const uint8_t * s = src ; const uint8_t * end ; # ifdef HAVE_MMX const uint8_t * mm_end ; # endif uint16_t * d = ( uint16_t * ) dst ; end = s + src_size ; # ifdef HAVE_MMX __asm __volatile ( PREFETCH "	%0" :: "m" ( * src ) : "memory" ) ; __asm __volatile ( "movq	%0, %%mm7\n\t" "movq	%1, %%mm6\n\t" :: "m" ( red_15mask ) , "m" ( green_15mask ) ) ; mm_end = end - 15 ; while ( s < mm_end ) { __asm __volatile ( PREFETCH " 32%1\n\t" "movd	%1, %%mm0\n\t" "movd	3%1, %%mm3\n\t" "punpckldq 6%1, %%mm0\n\t" "punpckldq 9%1, %%mm3\n\t" "movq	%%mm0, %%mm1\n\t" "movq	%%mm0, %%mm2\n\t" "movq	%%mm3, %%mm4\n\t" "movq	%%mm3, %%mm5\n\t" "psllq	$7, %%mm0\n\t" "psllq	$7, %%mm3\n\t" "pand	%%mm7, %%mm0\n\t" "pand	%%mm7, %%mm3\n\t" "psrlq	$6, %%mm1\n\t" "psrlq	$6, %%mm4\n\t" "pand	%%mm6, %%mm1\n\t" "pand	%%mm6, %%mm4\n\t" "psrlq	$19, %%mm2\n\t" "psrlq	$19, %%mm5\n\t" "pand	%2, %%mm2\n\t" "pand	%2, %%mm5\n\t" "por	%%mm1, %%mm0\n\t" "por	%%mm4, %%mm3\n\t" "por	%%mm2, %%mm0\n\t" "por	%%mm5, %%mm3\n\t" "psllq	$16, %%mm3\n\t" "por	%%mm3, %%mm0\n\t" MOVNTQ "	%%mm0, %0\n\t" : "=m" ( * d ) : "m" ( * s ) , "m" ( blue_15mask ) : "memory" ) ; d += 4 ; s += 12 ; } __asm __volatile ( SFENCE :: : "memory" ) ; __asm __volatile ( EMMS :: : "memory" ) ; # endif while ( s < end ) { const int r = * s ++ ; const int g = * s ++ ; const int b = * s ++ ; * d ++ = ( b >> 3 ) | ( ( g & 0xF8 ) << 2 ) | ( ( r & 0xF8 ) << 7 ) ; } }##::##1##::##12205
static inline void RENAME ( rgb24to16 ) ( const uint8_t * src , uint8_t * dst , long src_size ) { const uint8_t * s = src ; const uint8_t * end ; # ifdef HAVE_MMX const uint8_t * mm_end ; # endif uint16_t * d = ( uint16_t * ) dst ; end = s + src_size ; # ifdef HAVE_MMX __asm __volatile ( PREFETCH "	%0" :: "m" ( * src ) : "memory" ) ; __asm __volatile ( "movq	%0, %%mm7\n\t" "movq	%1, %%mm6\n\t" :: "m" ( red_16mask ) , "m" ( green_16mask ) ) ; mm_end = end - 11 ; while ( s < mm_end ) { __asm __volatile ( PREFETCH " 32%1\n\t" "movd	%1, %%mm0\n\t" "movd	3%1, %%mm3\n\t" "punpckldq 6%1, %%mm0\n\t" "punpckldq 9%1, %%mm3\n\t" "movq	%%mm0, %%mm1\n\t" "movq	%%mm0, %%mm2\n\t" "movq	%%mm3, %%mm4\n\t" "movq	%%mm3, %%mm5\n\t" "psrlq	$3, %%mm0\n\t" "psrlq	$3, %%mm3\n\t" "pand	%2, %%mm0\n\t" "pand	%2, %%mm3\n\t" "psrlq	$5, %%mm1\n\t" "psrlq	$5, %%mm4\n\t" "pand	%%mm6, %%mm1\n\t" "pand	%%mm6, %%mm4\n\t" "psrlq	$8, %%mm2\n\t" "psrlq	$8, %%mm5\n\t" "pand	%%mm7, %%mm2\n\t" "pand	%%mm7, %%mm5\n\t" "por	%%mm1, %%mm0\n\t" "por	%%mm4, %%mm3\n\t" "por	%%mm2, %%mm0\n\t" "por	%%mm5, %%mm3\n\t" "psllq	$16, %%mm3\n\t" "por	%%mm3, %%mm0\n\t" MOVNTQ "	%%mm0, %0\n\t" : "=m" ( * d ) : "m" ( * s ) , "m" ( blue_16mask ) : "memory" ) ; d += 4 ; s += 12 ; } __asm __volatile ( SFENCE :: : "memory" ) ; __asm __volatile ( EMMS :: : "memory" ) ; # endif while ( s < end ) { const int b = * s ++ ; const int g = * s ++ ; const int r = * s ++ ; * d ++ = ( b >> 3 ) | ( ( g & 0xFC ) << 3 ) | ( ( r & 0xF8 ) << 8 ) ; } }##::##1##::##26
static inline void RENAME ( rgb24tobgr16 ) ( const uint8_t * src , uint8_t * dst , long src_size ) { const uint8_t * s = src ; const uint8_t * end ; # ifdef HAVE_MMX const uint8_t * mm_end ; # endif uint16_t * d = ( uint16_t * ) dst ; end = s + src_size ; # ifdef HAVE_MMX __asm __volatile ( PREFETCH "	%0" :: "m" ( * src ) : "memory" ) ; __asm __volatile ( "movq	%0, %%mm7\n\t" "movq	%1, %%mm6\n\t" :: "m" ( red_16mask ) , "m" ( green_16mask ) ) ; mm_end = end - 15 ; while ( s < mm_end ) { __asm __volatile ( PREFETCH " 32%1\n\t" "movd	%1, %%mm0\n\t" "movd	3%1, %%mm3\n\t" "punpckldq 6%1, %%mm0\n\t" "punpckldq 9%1, %%mm3\n\t" "movq	%%mm0, %%mm1\n\t" "movq	%%mm0, %%mm2\n\t" "movq	%%mm3, %%mm4\n\t" "movq	%%mm3, %%mm5\n\t" "psllq	$8, %%mm0\n\t" "psllq	$8, %%mm3\n\t" "pand	%%mm7, %%mm0\n\t" "pand	%%mm7, %%mm3\n\t" "psrlq	$5, %%mm1\n\t" "psrlq	$5, %%mm4\n\t" "pand	%%mm6, %%mm1\n\t" "pand	%%mm6, %%mm4\n\t" "psrlq	$19, %%mm2\n\t" "psrlq	$19, %%mm5\n\t" "pand	%2, %%mm2\n\t" "pand	%2, %%mm5\n\t" "por	%%mm1, %%mm0\n\t" "por	%%mm4, %%mm3\n\t" "por	%%mm2, %%mm0\n\t" "por	%%mm5, %%mm3\n\t" "psllq	$16, %%mm3\n\t" "por	%%mm3, %%mm0\n\t" MOVNTQ "	%%mm0, %0\n\t" : "=m" ( * d ) : "m" ( * s ) , "m" ( blue_16mask ) : "memory" ) ; d += 4 ; s += 12 ; } __asm __volatile ( SFENCE :: : "memory" ) ; __asm __volatile ( EMMS :: : "memory" ) ; # endif while ( s < end ) { const int r = * s ++ ; const int g = * s ++ ; const int b = * s ++ ; * d ++ = ( b >> 3 ) | ( ( g & 0xFC ) << 3 ) | ( ( r & 0xF8 ) << 8 ) ; } }##::##1##::##4156
static inline void RENAME ( rgb24to16 ) ( const uint8_t * src , uint8_t * dst , unsigned src_size ) { const uint8_t * s = src ; const uint8_t * end ; # ifdef HAVE_MMX const uint8_t * mm_end ; # endif uint16_t * d = ( uint16_t * ) dst ; end = s + src_size ; # ifdef HAVE_MMX __asm __volatile ( PREFETCH "	%0" :: "m" ( * src ) : "memory" ) ; __asm __volatile ( "movq	%0, %%mm7\n\t" "movq	%1, %%mm6\n\t" :: "m" ( red_16mask ) , "m" ( green_16mask ) ) ; mm_end = end - 11 ; while ( s < mm_end ) { __asm __volatile ( PREFETCH " 32%1\n\t" "movd	%1, %%mm0\n\t" "movd	3%1, %%mm3\n\t" "punpckldq 6%1, %%mm0\n\t" "punpckldq 9%1, %%mm3\n\t" "movq	%%mm0, %%mm1\n\t" "movq	%%mm0, %%mm2\n\t" "movq	%%mm3, %%mm4\n\t" "movq	%%mm3, %%mm5\n\t" "psrlq	$3, %%mm0\n\t" "psrlq	$3, %%mm3\n\t" "pand	%2, %%mm0\n\t" "pand	%2, %%mm3\n\t" "psrlq	$5, %%mm1\n\t" "psrlq	$5, %%mm4\n\t" "pand	%%mm6, %%mm1\n\t" "pand	%%mm6, %%mm4\n\t" "psrlq	$8, %%mm2\n\t" "psrlq	$8, %%mm5\n\t" "pand	%%mm7, %%mm2\n\t" "pand	%%mm7, %%mm5\n\t" "por	%%mm1, %%mm0\n\t" "por	%%mm4, %%mm3\n\t" "por	%%mm2, %%mm0\n\t" "por	%%mm5, %%mm3\n\t" "psllq	$16, %%mm3\n\t" "por	%%mm3, %%mm0\n\t" MOVNTQ "	%%mm0, %0\n\t" : "=m" ( * d ) : "m" ( * s ) , "m" ( blue_16mask ) : "memory" ) ; d += 4 ; s += 12 ; } __asm __volatile ( SFENCE :: : "memory" ) ; __asm __volatile ( EMMS :: : "memory" ) ; # endif while ( s < end ) { const int b = * s ++ ; const int g = * s ++ ; const int r = * s ++ ; * d ++ = ( b >> 3 ) | ( ( g & 0xFC ) << 3 ) | ( ( r & 0xF8 ) << 8 ) ; } }##::##1##::##5196
static inline void RENAME ( rgb24tobgr15 ) ( const uint8_t * src , uint8_t * dst , long src_size ) { const uint8_t * s = src ; const uint8_t * end ; # ifdef HAVE_MMX const uint8_t * mm_end ; # endif uint16_t * d = ( uint16_t * ) dst ; end = s + src_size ; # ifdef HAVE_MMX __asm __volatile ( PREFETCH "	%0" :: "m" ( * src ) : "memory" ) ; __asm __volatile ( "movq	%0, %%mm7\n\t" "movq	%1, %%mm6\n\t" :: "m" ( red_15mask ) , "m" ( green_15mask ) ) ; mm_end = end - 15 ; while ( s < mm_end ) { __asm __volatile ( PREFETCH " 32%1\n\t" "movd	%1, %%mm0\n\t" "movd	3%1, %%mm3\n\t" "punpckldq 6%1, %%mm0\n\t" "punpckldq 9%1, %%mm3\n\t" "movq	%%mm0, %%mm1\n\t" "movq	%%mm0, %%mm2\n\t" "movq	%%mm3, %%mm4\n\t" "movq	%%mm3, %%mm5\n\t" "psllq	$7, %%mm0\n\t" "psllq	$7, %%mm3\n\t" "pand	%%mm7, %%mm0\n\t" "pand	%%mm7, %%mm3\n\t" "psrlq	$6, %%mm1\n\t" "psrlq	$6, %%mm4\n\t" "pand	%%mm6, %%mm1\n\t" "pand	%%mm6, %%mm4\n\t" "psrlq	$19, %%mm2\n\t" "psrlq	$19, %%mm5\n\t" "pand	%2, %%mm2\n\t" "pand	%2, %%mm5\n\t" "por	%%mm1, %%mm0\n\t" "por	%%mm4, %%mm3\n\t" "por	%%mm2, %%mm0\n\t" "por	%%mm5, %%mm3\n\t" "psllq	$16, %%mm3\n\t" "por	%%mm3, %%mm0\n\t" MOVNTQ "	%%mm0, %0\n\t" : "=m" ( * d ) : "m" ( * s ) , "m" ( blue_15mask ) : "memory" ) ; d += 4 ; s += 12 ; } __asm __volatile ( SFENCE :: : "memory" ) ; __asm __volatile ( EMMS :: : "memory" ) ; # endif while ( s < end ) { const int r = * s ++ ; const int g = * s ++ ; const int b = * s ++ ; * d ++ = ( b >> 3 ) | ( ( g & 0xF8 ) << 2 ) | ( ( r & 0xF8 ) << 7 ) ; } }##::##1##::##8197
static void decode_band_structure ( GetBitContext * gbc , int blk , int eac3 , int ecpl , int start_subband , int end_subband , const uint8_t * default_band_struct , int * num_bands , uint8_t * band_sizes ) { int subbnd , bnd , n_subbands , n_bands = 0 ; uint8_t bnd_sz [ 22 ] ; uint8_t coded_band_struct [ 22 ] ; const uint8_t * band_struct ; n_subbands = end_subband - start_subband ; if ( ! eac3 || get_bits1 ( gbc ) ) { for ( subbnd = 0 ; subbnd < n_subbands - 1 ; subbnd ++ ) { coded_band_struct [ subbnd ] = get_bits1 ( gbc ) ; } band_struct = coded_band_struct ; } else if ( ! blk ) { band_struct = & default_band_struct [ start_subband + 1 ] ; } else { return ; } if ( num_bands || band_sizes ) { n_bands = n_subbands ; bnd_sz [ 0 ] = ecpl ? 6 : 12 ; for ( bnd = 0 , subbnd = 1 ; subbnd < n_subbands ; subbnd ++ ) { int subbnd_size = ( ecpl && subbnd < 4 ) ? 6 : 12 ; if ( band_struct [ subbnd - 1 ] ) { n_bands -- ; bnd_sz [ bnd ] += subbnd_size ; } else { bnd_sz [ ++ bnd ] = subbnd_size ; } } } if ( num_bands ) { * num_bands = n_bands ; } if ( band_sizes ) { memcpy ( band_sizes , bnd_sz , n_bands ) ; } }##::##1##::##1399
int ff_wms_parse_sdp_a_line ( AVFormatContext * s , const char * p ) { int ret = 0 ; if ( av_strstart ( p , "pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64," , & p ) ) { AVIOContext pb ; RTSPState * rt = s -> priv_data ; AVDictionary * opts = NULL ; int len = strlen ( p ) * 6 / 8 ; char * buf = av_mallocz ( len ) ; AVInputFormat * iformat ; if ( ! buf ) { return AVERROR ( ENOMEM ) ; } av_base64_decode ( buf , p , len ) ; if ( rtp_asf_fix_header ( buf , len ) < 0 ) av_log ( s , AV_LOG_ERROR , "Failed to fix invalid RTSP-MS/ASF min_pktsize\n" ) ; init_packetizer ( & pb , buf , len ) ; if ( rt -> asf_ctx ) { avformat_close_input ( & rt -> asf_ctx ) ; } if ( ! ( iformat = av_find_input_format ( "asf" ) ) ) { return AVERROR_DEMUXER_NOT_FOUND ; } rt -> asf_ctx = avformat_alloc_context ( ) ; if ( ! rt -> asf_ctx ) { av_free ( buf ) ; return AVERROR ( ENOMEM ) ; } rt -> asf_ctx -> pb = & pb ; av_dict_set ( & opts , "no_resync_search" , "1" , 0 ) ; if ( ( ret = ff_copy_whiteblacklists ( rt -> asf_ctx , s ) ) < 0 ) { av_dict_free ( & opts ) ; return ret ; } ret = avformat_open_input ( & rt -> asf_ctx , "" , iformat , & opts ) ; av_dict_free ( & opts ) ; if ( ret < 0 ) { av_free ( buf ) ; return ret ; } av_dict_copy ( & s -> metadata , rt -> asf_ctx -> metadata , 0 ) ; rt -> asf_pb_pos = avio_tell ( & pb ) ; av_free ( buf ) ; rt -> asf_ctx -> pb = NULL ; } return ret ; }##::##1##::##400
int av_packet_split_side_data ( AVPacket * pkt ) { if ( ! pkt -> side_data_elems && pkt -> size > 12 && AV_RB64 ( pkt -> data + pkt -> size - 8 ) == FF_MERGE_MARKER ) { int i ; unsigned int size ; uint8_t * p ; p = pkt -> data + pkt -> size - 8 - 5 ; for ( i = 1 ; ; i ++ ) { size = AV_RB32 ( p ) ; if ( size > INT_MAX || p - pkt -> data < size ) { return 0 ; } if ( p [ 4 ] & 128 ) { break ; } p -= size + 5 ; } pkt -> side_data = av_malloc_array ( i , sizeof ( * pkt -> side_data ) ) ; if ( ! pkt -> side_data ) { return AVERROR ( ENOMEM ) ; } p = pkt -> data + pkt -> size - 8 - 5 ; for ( i = 0 ; ; i ++ ) { size = AV_RB32 ( p ) ; av_assert0 ( size <= INT_MAX && p - pkt -> data >= size ) ; pkt -> side_data [ i ] . data = av_mallocz ( size + AV_INPUT_BUFFER_PADDING_SIZE ) ; pkt -> side_data [ i ] . size = size ; pkt -> side_data [ i ] . type = p [ 4 ] & 127 ; if ( ! pkt -> side_data [ i ] . data ) { return AVERROR ( ENOMEM ) ; } memcpy ( pkt -> side_data [ i ] . data , p - size , size ) ; pkt -> size -= size + 5 ; if ( p [ 4 ] & 128 ) { break ; } p -= size + 5 ; } pkt -> size -= 8 ; pkt -> side_data_elems = i + 1 ; return 1 ; } return 0 ; }##::##1##::##8163
static void migration_completion ( MigrationState * s , int current_active_state , bool * old_vm_running , int64_t * start_time ) { int ret ; if ( s -> state == MIGRATION_STATUS_ACTIVE ) { qemu_mutex_lock_iothread ( ) ; * start_time = qemu_clock_get_ms ( QEMU_CLOCK_REALTIME ) ; qemu_system_wakeup_request ( QEMU_WAKEUP_REASON_OTHER ) ; * old_vm_running = runstate_is_running ( ) ; ret = global_state_store ( ) ; if ( ! ret ) { ret = vm_stop_force_state ( RUN_STATE_FINISH_MIGRATE ) ; if ( ret >= 0 ) { ret = bdrv_inactivate_all ( ) ; } if ( ret >= 0 ) { qemu_file_set_rate_limit ( s -> to_dst_file , INT64_MAX ) ; qemu_savevm_state_complete_precopy ( s -> to_dst_file , false ) ; } } qemu_mutex_unlock_iothread ( ) ; if ( ret < 0 ) { goto fail ; } } else if ( s -> state == MIGRATION_STATUS_POSTCOPY_ACTIVE ) { trace_migration_completion_postcopy_end ( ) ; qemu_savevm_state_complete_postcopy ( s -> to_dst_file ) ; trace_migration_completion_postcopy_end_after_complete ( ) ; } if ( migrate_postcopy_ram ( ) ) { int rp_error ; trace_migration_completion_postcopy_end_before_rp ( ) ; rp_error = await_return_path_close_on_source ( s ) ; trace_migration_completion_postcopy_end_after_rp ( rp_error ) ; if ( rp_error ) { goto fail ; } } if ( qemu_file_get_error ( s -> to_dst_file ) ) { trace_migration_completion_file_err ( ) ; goto fail ; } migrate_set_state ( & s -> state , current_active_state , MIGRATION_STATUS_COMPLETED ) ; return ; fail : migrate_set_state ( & s -> state , current_active_state , MIGRATION_STATUS_FAILED ) ; }##::##1##::##11481
static int guess_disk_lchs ( IDEState * s , int * pcylinders , int * pheads , int * psectors ) { uint8_t * buf ; int ret , i , heads , sectors , cylinders ; struct partition * p ; uint32_t nr_sects ; buf = qemu_memalign ( 512 , 512 ) ; if ( buf == NULL ) { return - 1 ; } ret = bdrv_read ( s -> bs , 0 , buf , 1 ) ; if ( ret < 0 ) { qemu_free ( buf ) ; return - 1 ; } if ( buf [ 510 ] != 0x55 || buf [ 511 ] != 0xaa ) { qemu_free ( buf ) ; return - 1 ; } for ( i = 0 ; i < 4 ; i ++ ) { p = ( ( struct partition * ) ( buf + 0x1be ) ) + i ; nr_sects = le32_to_cpu ( p -> nr_sects ) ; if ( nr_sects && p -> end_head ) { heads = p -> end_head + 1 ; sectors = p -> end_sector & 63 ; if ( sectors == 0 ) { continue ; } cylinders = s -> nb_sectors / ( heads * sectors ) ; if ( cylinders < 1 || cylinders > 16383 ) { continue ; } * pheads = heads ; * psectors = sectors ; * pcylinders = cylinders ; # if 0 printf ( "guessed geometry: LCHS=%d %d %d\n" , cylinders , heads , sectors ) ; # endif qemu_free ( buf ) ; return 0 ; } } qemu_free ( buf ) ; return - 1 ; }##::##1##::##9080
static inline void RENAME ( rgb24tobgr16 ) ( const uint8_t * src , uint8_t * dst , unsigned int src_size ) { const uint8_t * s = src ; const uint8_t * end ; # ifdef HAVE_MMX const uint8_t * mm_end ; # endif uint16_t * d = ( uint16_t * ) dst ; end = s + src_size ; # ifdef HAVE_MMX __asm __volatile ( PREFETCH "	%0" :: "m" ( * src ) : "memory" ) ; __asm __volatile ( "movq	%0, %%mm7\n\t" "movq	%1, %%mm6\n\t" :: "m" ( red_16mask ) , "m" ( green_16mask ) ) ; mm_end = end - 15 ; while ( s < mm_end ) { __asm __volatile ( PREFETCH " 32%1\n\t" "movd	%1, %%mm0\n\t" "movd	3%1, %%mm3\n\t" "punpckldq 6%1, %%mm0\n\t" "punpckldq 9%1, %%mm3\n\t" "movq	%%mm0, %%mm1\n\t" "movq	%%mm0, %%mm2\n\t" "movq	%%mm3, %%mm4\n\t" "movq	%%mm3, %%mm5\n\t" "psllq	$8, %%mm0\n\t" "psllq	$8, %%mm3\n\t" "pand	%%mm7, %%mm0\n\t" "pand	%%mm7, %%mm3\n\t" "psrlq	$5, %%mm1\n\t" "psrlq	$5, %%mm4\n\t" "pand	%%mm6, %%mm1\n\t" "pand	%%mm6, %%mm4\n\t" "psrlq	$19, %%mm2\n\t" "psrlq	$19, %%mm5\n\t" "pand	%2, %%mm2\n\t" "pand	%2, %%mm5\n\t" "por	%%mm1, %%mm0\n\t" "por	%%mm4, %%mm3\n\t" "por	%%mm2, %%mm0\n\t" "por	%%mm5, %%mm3\n\t" "psllq	$16, %%mm3\n\t" "por	%%mm3, %%mm0\n\t" MOVNTQ "	%%mm0, %0\n\t" : "=m" ( * d ) : "m" ( * s ) , "m" ( blue_16mask ) : "memory" ) ; d += 4 ; s += 12 ; } __asm __volatile ( SFENCE :: : "memory" ) ; __asm __volatile ( EMMS :: : "memory" ) ; # endif while ( s < end ) { const int r = * s ++ ; const int g = * s ++ ; const int b = * s ++ ; * d ++ = ( b >> 3 ) | ( ( g & 0xFC ) << 3 ) | ( ( r & 0xF8 ) << 8 ) ; } }##::##1##::##6308
static int save_xbzrle_page ( QEMUFile * f , uint8_t * * current_data , ram_addr_t current_addr , RAMBlock * block , ram_addr_t offset , int cont , bool last_stage ) { int encoded_len = 0 , bytes_sent = - 1 ; uint8_t * prev_cached_page ; if ( ! cache_is_cached ( XBZRLE . cache , current_addr ) ) { acct_info . xbzrle_cache_miss ++ ; if ( ! last_stage ) { if ( cache_insert ( XBZRLE . cache , current_addr , * current_data ) == - 1 ) { return - 1 ; } else { * current_data = get_cached_data ( XBZRLE . cache , current_addr ) ; } } return - 1 ; } prev_cached_page = get_cached_data ( XBZRLE . cache , current_addr ) ; memcpy ( XBZRLE . current_buf , * current_data , TARGET_PAGE_SIZE ) ; encoded_len = xbzrle_encode_buffer ( prev_cached_page , XBZRLE . current_buf , TARGET_PAGE_SIZE , XBZRLE . encoded_buf , TARGET_PAGE_SIZE ) ; if ( encoded_len == 0 ) { DPRINTF ( "Skipping unmodified page\n" ) ; return 0 ; } else if ( encoded_len == - 1 ) { DPRINTF ( "Overflow\n" ) ; acct_info . xbzrle_overflows ++ ; if ( ! last_stage ) { memcpy ( prev_cached_page , * current_data , TARGET_PAGE_SIZE ) ; * current_data = prev_cached_page ; } return - 1 ; } if ( ! last_stage ) { memcpy ( prev_cached_page , XBZRLE . current_buf , TARGET_PAGE_SIZE ) ; } bytes_sent = save_block_hdr ( f , block , offset , cont , RAM_SAVE_FLAG_XBZRLE ) ; qemu_put_byte ( f , ENCODING_FLAG_XBZRLE ) ; qemu_put_be16 ( f , encoded_len ) ; qemu_put_buffer ( f , XBZRLE . encoded_buf , encoded_len ) ; bytes_sent += encoded_len + 1 + 2 ; acct_info . xbzrle_pages ++ ; acct_info . xbzrle_bytes += bytes_sent ; return bytes_sent ; }##::##1##::##478
static int virtio_serial_load ( QEMUFile * f , void * opaque , int version_id ) { VirtIOSerial * s = opaque ; VirtIOSerialPort * port ; uint32_t max_nr_ports , nr_active_ports , ports_map ; unsigned int i ; if ( version_id > 3 ) { virtio_load ( & s -> vdev , f ) ; if ( version_id < 2 ) { return 0 ; qemu_get_be16s ( f , & s -> config . cols ) ; qemu_get_be16s ( f , & s -> config . rows ) ; qemu_get_be32s ( f , & max_nr_ports ) ; if ( max_nr_ports > s -> config . max_nr_ports ) { for ( i = 0 ; i < ( max_nr_ports + 31 ) / 32 ; i ++ ) { qemu_get_be32s ( f , & ports_map ) ; if ( ports_map != s -> ports_map [ i ] ) { qemu_get_be32s ( f , & nr_active_ports ) ; for ( i = 0 ; i < nr_active_ports ; i ++ ) { uint32_t id ; bool host_connected ; id = qemu_get_be32 ( f ) ; port = find_port_by_id ( s , id ) ; port -> guest_connected = qemu_get_byte ( f ) ; host_connected = qemu_get_byte ( f ) ; if ( host_connected != port -> host_connected ) { send_control_event ( port , VIRTIO_CONSOLE_PORT_OPEN , port -> host_connected ) ; if ( version_id > 2 ) { uint32_t elem_popped ; qemu_get_be32s ( f , & elem_popped ) ; if ( elem_popped ) { qemu_get_be32s ( f , & port -> iov_idx ) ; qemu_get_be64s ( f , & port -> iov_offset ) ; qemu_get_buffer ( f , ( unsigned char * ) & port -> elem , sizeof ( port -> elem ) ) ; virtqueue_map_sg ( port -> elem . in_sg , port -> elem . in_addr , port -> elem . in_num , 1 ) ; virtqueue_map_sg ( port -> elem . out_sg , port -> elem . out_addr , port -> elem . out_num , 1 ) ; virtio_serial_throttle_port ( port , false ) ; return 0 ;##::##1##::##8947
static always_inline void gen_op_arith_add ( DisasContext * ctx , TCGv ret , TCGv arg1 , TCGv arg2 , int add_ca , int compute_ca , int compute_ov ) { TCGv t0 , t1 ; if ( ( ! compute_ca && ! compute_ov ) || ( ! TCGV_EQUAL ( ret , arg1 ) && ! TCGV_EQUAL ( ret , arg2 ) ) ) { t0 = ret ; t0 = tcg_temp_local_new ( ) ; } if ( add_ca ) { t1 = tcg_temp_local_new ( ) ; tcg_gen_andi_tl ( t1 , cpu_xer , ( 1 << XER_CA ) ) ; tcg_gen_shri_tl ( t1 , t1 , XER_CA ) ; } if ( compute_ca && compute_ov ) { tcg_gen_andi_tl ( cpu_xer , cpu_xer , ~ ( ( 1 << XER_CA ) | ( 1 << XER_OV ) ) ) ; } else if ( compute_ca ) { tcg_gen_andi_tl ( cpu_xer , cpu_xer , ~ ( 1 << XER_CA ) ) ; } else if ( compute_ov ) { tcg_gen_andi_tl ( cpu_xer , cpu_xer , ~ ( 1 << XER_OV ) ) ; } tcg_gen_add_tl ( t0 , arg1 , arg2 ) ; if ( compute_ca ) { gen_op_arith_compute_ca ( ctx , t0 , arg1 , 0 ) ; } if ( add_ca ) { tcg_gen_add_tl ( t0 , t0 , t1 ) ; gen_op_arith_compute_ca ( ctx , t0 , t1 , 0 ) ; tcg_temp_free ( t1 ) ; } if ( compute_ov ) { gen_op_arith_compute_ov ( ctx , t0 , arg1 , arg2 , 0 ) ; } if ( unlikely ( Rc ( ctx -> opcode ) != 0 ) ) { gen_set_Rc0 ( ctx , t0 ) ; } if ( ! TCGV_EQUAL ( t0 , ret ) ) { tcg_gen_mov_tl ( ret , t0 ) ; tcg_temp_free ( t0 ) ; } }##::##1##::##11506
static int compute_mask ( int step , uint32_t * mask ) { int i , z , ret = 0 ; int counter_size = sizeof ( uint32_t ) * ( 2 * step + 1 ) ; uint32_t * temp1_counter , * temp2_counter , * * counter ; temp1_counter = av_mallocz ( counter_size ) ; if ( ! temp1_counter ) { ret = AVERROR ( ENOMEM ) ; goto end ; } temp2_counter = av_mallocz ( counter_size ) ; if ( ! temp2_counter ) { ret = AVERROR ( ENOMEM ) ; goto end ; } counter = av_mallocz_array ( 2 * step + 1 , sizeof ( uint32_t * ) ) ; if ( ! counter ) { ret = AVERROR ( ENOMEM ) ; goto end ; } for ( i = 0 ; i < 2 * step + 1 ; i ++ ) { counter [ i ] = av_mallocz ( counter_size ) ; if ( ! counter [ i ] ) { ret = AVERROR ( ENOMEM ) ; goto end ; } } for ( i = 0 ; i < 2 * step + 1 ; i ++ ) { memset ( temp1_counter , 0 , counter_size ) ; temp1_counter [ i ] = 1 ; for ( z = 0 ; z < step * 2 ; z += 2 ) { add_mask_counter ( temp2_counter , counter [ z ] , temp1_counter , step * 2 ) ; memcpy ( counter [ z ] , temp1_counter , counter_size ) ; add_mask_counter ( temp1_counter , counter [ z + 1 ] , temp2_counter , step * 2 ) ; memcpy ( counter [ z + 1 ] , temp2_counter , counter_size ) ; } } memcpy ( mask , temp1_counter , counter_size ) ; end : av_freep ( & temp1_counter ) ; av_freep ( & temp2_counter ) ; for ( i = 0 ; i < 2 * step + 1 ; i ++ ) { av_freep ( & counter [ i ] ) ; } av_freep ( & counter ) ; return ret ; }##::##1##::##6293
pci_e1000_init ( PCIBus * bus , NICInfo * nd , int devfn ) { E1000State * d ; uint8_t * pci_conf ; uint16_t checksum = 0 ; static const char info_str [ ] = "e1000" ; int i ; d = ( E1000State * ) pci_register_device ( bus , "e1000" , sizeof ( E1000State ) , devfn , NULL , NULL ) ; pci_conf = d -> dev . config ; memset ( pci_conf , 0 , 256 ) ; pci_config_set_vendor_id ( pci_conf , PCI_VENDOR_ID_INTEL ) ; pci_config_set_device_id ( pci_conf , E1000_DEVID ) ; * ( uint16_t * ) ( pci_conf + 0x04 ) = cpu_to_le16 ( 0x0407 ) ; * ( uint16_t * ) ( pci_conf + 0x06 ) = cpu_to_le16 ( 0x0010 ) ; pci_conf [ 0x08 ] = 0x03 ; pci_config_set_class ( pci_conf , PCI_CLASS_NETWORK_ETHERNET ) ; pci_conf [ 0x0c ] = 0x10 ; pci_conf [ 0x3d ] = 1 ; d -> mmio_index = cpu_register_io_memory ( 0 , e1000_mmio_read , e1000_mmio_write , d ) ; pci_register_io_region ( ( PCIDevice * ) d , 0 , PNPMMIO_SIZE , PCI_ADDRESS_SPACE_MEM , e1000_mmio_map ) ; pci_register_io_region ( ( PCIDevice * ) d , 1 , IOPORT_SIZE , PCI_ADDRESS_SPACE_IO , ioport_map ) ; memmove ( d -> eeprom_data , e1000_eeprom_template , sizeof e1000_eeprom_template ) ; for ( i = 0 ; i < 3 ; i ++ ) { d -> eeprom_data [ i ] = ( nd -> macaddr [ 2 * i + 1 ] << 8 ) | nd -> macaddr [ 2 * i ] ; } for ( i = 0 ; i < EEPROM_CHECKSUM_REG ; i ++ ) { checksum += d -> eeprom_data [ i ] ; } checksum = ( uint16_t ) EEPROM_SUM - checksum ; d -> eeprom_data [ EEPROM_CHECKSUM_REG ] = checksum ; memset ( d -> phy_reg , 0 , sizeof d -> phy_reg ) ; memmove ( d -> phy_reg , phy_reg_init , sizeof phy_reg_init ) ; memset ( d -> mac_reg , 0 , sizeof d -> mac_reg ) ; memmove ( d -> mac_reg , mac_reg_init , sizeof mac_reg_init ) ; d -> rxbuf_min_shift = 1 ; memset ( & d -> tx , 0 , sizeof d -> tx ) ; d -> vc = qemu_new_vlan_client ( nd -> vlan , nd -> model , nd -> name , e1000_receive , e1000_can_receive , d ) ; d -> vc -> link_status_changed = e1000_set_link_status ; qemu_format_nic_info_str ( d -> vc , nd -> macaddr ) ; register_savevm ( info_str , - 1 , 2 , nic_save , nic_load , d ) ; d -> dev . unregister = pci_e1000_uninit ; return ( PCIDevice * ) d ; }##::##1##::##6627
static void spapr_populate_pa_features ( CPUPPCState * env , void * fdt , int offset ) { uint8_t pa_features_206 [ ] = { 6 , 0 , 0xf6 , 0x1f , 0xc7 , 0x00 , 0x80 , 0xc0 } ; uint8_t pa_features_207 [ ] = { 24 , 0 , 0xf6 , 0x1f , 0xc7 , 0xc0 , 0x80 , 0xf0 , 0x80 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x80 , 0x00 , 0x80 , 0x00 , 0x80 , 0x00 , 0x00 , 0x00 } ; uint8_t pa_features_300 [ ] = { 66 , 0 , 0xf6 , 0x1f , 0xc7 , 0xc0 , 0x80 , 0xf0 , 0x80 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x80 , 0x00 , 0x80 , 0x00 , 0x80 , 0x00 , 0x80 , 0x00 , 0x80 , 0x00 , 0x80 , 0x00 , 0x80 , 0x00 , 0x80 , 0x00 , 0x80 , 0x00 , 0xC0 , 0x00 , 0x80 , 0x00 , 0x80 , 0x00 , 0x80 , 0x00 , 0x80 , 0x00 , 0x80 , 0x00 , 0x80 , 0x00 , 0x80 , 0x00 , 0x80 , 0x00 , 0x80 , 0x00 , 0x80 , 0x00 , 0x80 , 0x00 , 0x80 , 0x00 , 0x80 , 0x00 , 0x80 , 0x00 , 0x00 , 0x00 , } ; uint8_t * pa_features ; size_t pa_size ; switch ( POWERPC_MMU_VER ( env -> mmu_model ) ) { case POWERPC_MMU_VER_2_06 : pa_features = pa_features_206 ; pa_size = sizeof ( pa_features_206 ) ; break ; case POWERPC_MMU_VER_2_07 : pa_features = pa_features_207 ; pa_size = sizeof ( pa_features_207 ) ; break ; case POWERPC_MMU_VER_3_00 : pa_features = pa_features_300 ; pa_size = sizeof ( pa_features_300 ) ; break ; default : return ; } if ( env -> ci_large_pages ) { pa_features [ 3 ] |= 0x20 ; } if ( kvmppc_has_cap_htm ( ) && pa_size > 24 ) { pa_features [ 24 ] |= 0x80 ; } _FDT ( ( fdt_setprop ( fdt , offset , "ibm,pa-features" , pa_features , pa_size ) ) ) ; }##::##1##::##3572
static void lsi_do_command ( LSIState * s ) { SCSIDevice * dev ; uint8_t buf [ 16 ] ; uint32_t id ; int n ; DPRINTF ( "Send command len=%d\n" , s -> dbc ) ; if ( s -> dbc > 16 ) { s -> dbc = 16 ; } pci_dma_read ( PCI_DEVICE ( s ) , s -> dnad , buf , s -> dbc ) ; s -> sfbr = buf [ 0 ] ; s -> command_complete = 0 ; id = ( s -> select_tag >> 8 ) & 0xf ; dev = scsi_device_find ( & s -> bus , 0 , id , s -> current_lun ) ; if ( ! dev ) { lsi_bad_selection ( s , id ) ; return ; } assert ( s -> current == NULL ) ; s -> current = g_malloc0 ( sizeof ( lsi_request ) ) ; s -> current -> tag = s -> select_tag ; s -> current -> req = scsi_req_new ( dev , s -> current -> tag , s -> current_lun , buf , s -> current ) ; n = scsi_req_enqueue ( s -> current -> req ) ; if ( n ) { if ( n > 0 ) { lsi_set_phase ( s , PHASE_DI ) ; } else if ( n < 0 ) { lsi_set_phase ( s , PHASE_DO ) ; } scsi_req_continue ( s -> current -> req ) ; } if ( ! s -> command_complete ) { if ( n ) { lsi_add_msg_byte ( s , 2 ) ; lsi_add_msg_byte ( s , 4 ) ; lsi_set_phase ( s , PHASE_MI ) ; s -> msg_action = 1 ; lsi_queue_command ( s ) ; } else { lsi_set_phase ( s , PHASE_DI ) ; } } }##::##1##::##12157
static int speex_header ( AVFormatContext * s , int idx ) { struct ogg * ogg = s -> priv_data ; struct ogg_stream * os = ogg -> streams + idx ; struct speex_params * spxp = os -> private ; AVStream * st = s -> streams [ idx ] ; uint8_t * p = os -> buf + os -> pstart ; if ( ! spxp ) { spxp = av_mallocz ( sizeof ( * spxp ) ) ; os -> private = spxp ; } if ( spxp -> seq > 1 ) { return 0 ; } if ( spxp -> seq == 0 ) { int frames_per_packet ; st -> codec -> codec_type = AVMEDIA_TYPE_AUDIO ; st -> codec -> codec_id = AV_CODEC_ID_SPEEX ; if ( os -> psize < 68 ) { av_log ( s , AV_LOG_ERROR , "speex packet too small\n" ) ; return AVERROR_INVALIDDATA ; } st -> codec -> sample_rate = AV_RL32 ( p + 36 ) ; st -> codec -> channels = AV_RL32 ( p + 48 ) ; if ( st -> codec -> channels < 1 || st -> codec -> channels > 2 ) { av_log ( s , AV_LOG_ERROR , "invalid channel count. Speex must be mono or stereo.\n" ) ; return AVERROR_INVALIDDATA ; } st -> codec -> channel_layout = st -> codec -> channels == 1 ? AV_CH_LAYOUT_MONO : AV_CH_LAYOUT_STEREO ; spxp -> packet_size = AV_RL32 ( p + 56 ) ; frames_per_packet = AV_RL32 ( p + 64 ) ; if ( frames_per_packet ) { spxp -> packet_size *= frames_per_packet ; } ff_alloc_extradata ( st -> codec , os -> psize ) ; memcpy ( st -> codec -> extradata , p , st -> codec -> extradata_size ) ; avpriv_set_pts_info ( st , 64 , 1 , st -> codec -> sample_rate ) ; } else { ff_vorbis_comment ( s , & st -> metadata , p , os -> psize ) ; } spxp -> seq ++ ; return 1 ; }##::##1##::##996
void rgb24toyv12_c ( const uint8_t * src , uint8_t * ydst , uint8_t * udst , uint8_t * vdst , int width , int height , int lumStride , int chromStride , int srcStride ) { int y ; const int chromWidth = width >> 1 ; for ( y = 0 ; y < height ; y += 2 ) { int i ; for ( i = 0 ; i < chromWidth ; i ++ ) { unsigned int b = src [ 6 * i + 0 ] ; unsigned int g = src [ 6 * i + 1 ] ; unsigned int r = src [ 6 * i + 2 ] ; unsigned int Y = ( ( RY * r + GY * g + BY * b ) >> RGB2YUV_SHIFT ) + 16 ; unsigned int V = ( ( RV * r + GV * g + BV * b ) >> RGB2YUV_SHIFT ) + 128 ; unsigned int U = ( ( RU * r + GU * g + BU * b ) >> RGB2YUV_SHIFT ) + 128 ; udst [ i ] = U ; vdst [ i ] = V ; ydst [ 2 * i ] = Y ; b = src [ 6 * i + 3 ] ; g = src [ 6 * i + 4 ] ; r = src [ 6 * i + 5 ] ; Y = ( ( RY * r + GY * g + BY * b ) >> RGB2YUV_SHIFT ) + 16 ; ydst [ 2 * i + 1 ] = Y ; } ydst += lumStride ; src += srcStride ; if ( y + 1 == height ) { break ; } for ( i = 0 ; i < chromWidth ; i ++ ) { unsigned int b = src [ 6 * i + 0 ] ; unsigned int g = src [ 6 * i + 1 ] ; unsigned int r = src [ 6 * i + 2 ] ; unsigned int Y = ( ( RY * r + GY * g + BY * b ) >> RGB2YUV_SHIFT ) + 16 ; ydst [ 2 * i ] = Y ; b = src [ 6 * i + 3 ] ; g = src [ 6 * i + 4 ] ; r = src [ 6 * i + 5 ] ; Y = ( ( RY * r + GY * g + BY * b ) >> RGB2YUV_SHIFT ) + 16 ; ydst [ 2 * i + 1 ] = Y ; } udst += chromStride ; vdst += chromStride ; ydst += lumStride ; src += srcStride ; } }##::##1##::##4565
static int mov_write_hdlr_tag ( AVIOContext * pb , MOVTrack * track ) { const char * hdlr , * descr = NULL , * hdlr_type = NULL ; int64_t pos = avio_tell ( pb ) ; if ( ! track ) { hdlr = ( track -> mode == MODE_MOV ) ? "mhlr" : "\0\0\0\0" ; if ( track -> enc -> codec_type == AVMEDIA_TYPE_VIDEO ) { hdlr_type = "vide" ; descr = "VideoHandler" ; } else if ( track -> enc -> codec_type == AVMEDIA_TYPE_AUDIO ) { hdlr_type = "soun" ; descr = "SoundHandler" ; } else if ( track -> enc -> codec_type == AVMEDIA_TYPE_SUBTITLE ) { if ( track -> tag == MKTAG ( 't' , 'x' , '3' , 'g' ) ) { hdlr_type = "sbtl" ; } else { hdlr_type = "text" ; } descr = "SubtitleHandler" ; } else if ( track -> enc -> codec_tag == MKTAG ( 'r' , 't' , 'p' , ' ' ) ) { hdlr_type = "hint" ; descr = "HintHandler" ; } } avio_wb32 ( pb , 0 ) ; ffio_wfourcc ( pb , "hdlr" ) ; avio_wb32 ( pb , 0 ) ; avio_write ( pb , hdlr , 4 ) ; ffio_wfourcc ( pb , hdlr_type ) ; avio_wb32 ( pb , 0 ) ; avio_wb32 ( pb , 0 ) ; avio_wb32 ( pb , 0 ) ; if ( ! track || track -> mode == MODE_MOV ) { avio_w8 ( pb , strlen ( descr ) ) ; } avio_write ( pb , descr , strlen ( descr ) ) ; if ( track && track -> mode != MODE_MOV ) { avio_w8 ( pb , 0 ) ; } return update_size ( pb , pos ) ; }##::##1##::##5740
static int mov_read_replaygain ( MOVContext * c , AVIOContext * pb , int size ) { int64_t end = avio_tell ( pb ) + size ; uint8_t * key = NULL , * val = NULL ; int i ; for ( i = 0 ; i < 2 ; i ++ ) { uint8_t * * p ; uint32_t len , tag ; if ( end - avio_tell ( pb ) <= 12 ) { break ; } len = avio_rb32 ( pb ) ; tag = avio_rl32 ( pb ) ; avio_skip ( pb , 4 ) ; if ( len < 12 || len - 12 > end - avio_tell ( pb ) ) { break ; } len -= 12 ; if ( tag == MKTAG ( 'n' , 'a' , 'm' , 'e' ) ) { p = & key ; } else if ( tag == MKTAG ( 'd' , 'a' , 't' , 'a' ) && len > 4 ) { avio_skip ( pb , 4 ) ; len -= 4 ; p = & val ; } else { break ; } * p = av_malloc ( len + 1 ) ; if ( ! * p ) { break ; } avio_read ( pb , * p , len ) ; ( * p ) [ len ] = 0 ; } if ( key && val ) { av_dict_set ( & c -> fc -> metadata , key , val , AV_DICT_DONT_STRDUP_KEY | AV_DICT_DONT_STRDUP_VAL ) ; key = val = NULL ; } avio_seek ( pb , end , SEEK_SET ) ; av_freep ( & key ) ; av_freep ( & val ) ; return 0 ; }##::##1##::##3542
static int mov_write_trak_tag ( AVIOContext * pb , MOVMuxContext * mov , MOVTrack * track , AVStream * st ) { int64_t pos = avio_tell ( pb ) ; avio_wb32 ( pb , 0 ) ; ffio_wfourcc ( pb , "trak" ) ; mov_write_tkhd_tag ( pb , mov , track , st ) ; if ( track -> mode == MODE_PSP || track -> flags & MOV_TRACK_CTTS || ( track -> entry && track -> cluster [ 0 ] . dts ) || is_clcp_track ( track ) ) { if ( mov -> use_editlist ) { mov_write_edts_tag ( pb , mov , track ) ; } else if ( ( track -> entry && track -> cluster [ 0 ] . dts ) || track -> mode == MODE_PSP || is_clcp_track ( track ) ) av_log ( mov -> fc , AV_LOG_WARNING , "Not writing any edit list even though one would have been required\n" ) ; } if ( track -> tref_tag ) { mov_write_tref_tag ( pb , track ) ; } mov_write_mdia_tag ( pb , mov , track ) ; if ( track -> mode == MODE_PSP ) { mov_write_uuid_tag_psp ( pb , track ) ; } if ( track -> tag == MKTAG ( 'r' , 't' , 'p' , ' ' ) ) { mov_write_udta_sdp ( pb , track ) ; } if ( track -> mode == MODE_MOV ) { if ( track -> enc -> codec_type == AVMEDIA_TYPE_VIDEO ) { double sample_aspect_ratio = av_q2d ( st -> sample_aspect_ratio ) ; if ( ( 0.0 != sample_aspect_ratio && 1.0 != sample_aspect_ratio ) ) { mov_write_tapt_tag ( pb , track ) ; } } if ( is_clcp_track ( track ) ) { mov_write_tapt_tag ( pb , track ) ; } } mov_write_track_udta_tag ( pb , mov , st ) ; return update_size ( pb , pos ) ; }##::##1##::##2623
POWERPC_FAMILY ( POWER7 ) ( ObjectClass * oc , void * data ) { DeviceClass * dc = DEVICE_CLASS ( oc ) ; PowerPCCPUClass * pcc = POWERPC_CPU_CLASS ( oc ) ; dc -> fw_name = "PowerPC,POWER7" ; dc -> desc = "POWER7" ; pcc -> pvr = CPU_POWERPC_POWER7_BASE ; pcc -> pvr_mask = CPU_POWERPC_POWER7_MASK ; pcc -> init_proc = init_proc_POWER7 ; pcc -> check_pow = check_pow_nocheck ; pcc -> insns_flags = PPC_INSNS_BASE | PPC_ISEL | PPC_STRING | PPC_MFTB | PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES | PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE | PPC_FLOAT_FRSQRTES | PPC_FLOAT_STFIWX | PPC_FLOAT_EXT | PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ | PPC_MEM_SYNC | PPC_MEM_EIEIO | PPC_MEM_TLBIE | PPC_MEM_TLBSYNC | PPC_64B | PPC_ALTIVEC | PPC_SEGMENT_64B | PPC_SLBI | PPC_POPCNTB | PPC_POPCNTWD ; pcc -> insns_flags2 = PPC2_VSX | PPC2_DFP | PPC2_DBRX | PPC2_ISA205 | PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 | PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206 | PPC2_FP_TST_ISA206 ; pcc -> msr_mask = ( 1ull << MSR_SF ) | ( 1ull << MSR_VR ) | ( 1ull << MSR_VSX ) | ( 1ull << MSR_EE ) | ( 1ull << MSR_PR ) | ( 1ull << MSR_FP ) | ( 1ull << MSR_ME ) | ( 1ull << MSR_FE0 ) | ( 1ull << MSR_SE ) | ( 1ull << MSR_DE ) | ( 1ull << MSR_FE1 ) | ( 1ull << MSR_IR ) | ( 1ull << MSR_DR ) | ( 1ull << MSR_PMM ) | ( 1ull << MSR_RI ) | ( 1ull << MSR_LE ) ; pcc -> mmu_model = POWERPC_MMU_2_06 ; # if defined ( CONFIG_SOFTMMU ) pcc -> handle_mmu_fault = ppc_hash64_handle_mmu_fault ; # endif pcc -> excp_model = POWERPC_EXCP_POWER7 ; pcc -> bus_model = PPC_FLAGS_INPUT_POWER7 ; pcc -> bfd_mach = bfd_mach_ppc64 ; pcc -> flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE | POWERPC_FLAG_BE | POWERPC_FLAG_PMM | POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR | POWERPC_FLAG_VSX ; pcc -> l1_dcache_size = 0x8000 ; pcc -> l1_icache_size = 0x8000 ; pcc -> interrupts_big_endian = ppc_cpu_interrupts_big_endian_lpcr ; }##::##1##::##1574
POWERPC_FAMILY ( POWER7P ) ( ObjectClass * oc , void * data ) { DeviceClass * dc = DEVICE_CLASS ( oc ) ; PowerPCCPUClass * pcc = POWERPC_CPU_CLASS ( oc ) ; dc -> fw_name = "PowerPC,POWER7+" ; dc -> desc = "POWER7+" ; pcc -> pvr = CPU_POWERPC_POWER7P_BASE ; pcc -> pvr_mask = CPU_POWERPC_POWER7P_MASK ; pcc -> init_proc = init_proc_POWER7 ; pcc -> check_pow = check_pow_nocheck ; pcc -> insns_flags = PPC_INSNS_BASE | PPC_ISEL | PPC_STRING | PPC_MFTB | PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES | PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE | PPC_FLOAT_FRSQRTES | PPC_FLOAT_STFIWX | PPC_FLOAT_EXT | PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ | PPC_MEM_SYNC | PPC_MEM_EIEIO | PPC_MEM_TLBIE | PPC_MEM_TLBSYNC | PPC_64B | PPC_ALTIVEC | PPC_SEGMENT_64B | PPC_SLBI | PPC_POPCNTB | PPC_POPCNTWD ; pcc -> insns_flags2 = PPC2_VSX | PPC2_DFP | PPC2_DBRX | PPC2_ISA205 | PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 | PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206 | PPC2_FP_TST_ISA206 ; pcc -> msr_mask = ( 1ull << MSR_SF ) | ( 1ull << MSR_VR ) | ( 1ull << MSR_VSX ) | ( 1ull << MSR_EE ) | ( 1ull << MSR_PR ) | ( 1ull << MSR_FP ) | ( 1ull << MSR_ME ) | ( 1ull << MSR_FE0 ) | ( 1ull << MSR_SE ) | ( 1ull << MSR_DE ) | ( 1ull << MSR_FE1 ) | ( 1ull << MSR_IR ) | ( 1ull << MSR_DR ) | ( 1ull << MSR_PMM ) | ( 1ull << MSR_RI ) | ( 1ull << MSR_LE ) ; pcc -> mmu_model = POWERPC_MMU_2_06 ; # if defined ( CONFIG_SOFTMMU ) pcc -> handle_mmu_fault = ppc_hash64_handle_mmu_fault ; # endif pcc -> excp_model = POWERPC_EXCP_POWER7 ; pcc -> bus_model = PPC_FLAGS_INPUT_POWER7 ; pcc -> bfd_mach = bfd_mach_ppc64 ; pcc -> flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE | POWERPC_FLAG_BE | POWERPC_FLAG_PMM | POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR | POWERPC_FLAG_VSX ; pcc -> l1_dcache_size = 0x8000 ; pcc -> l1_icache_size = 0x8000 ; pcc -> interrupts_big_endian = ppc_cpu_interrupts_big_endian_lpcr ; }##::##1##::##5122
static int mv_read_packet ( AVFormatContext * avctx , AVPacket * pkt ) { MvContext * mv = avctx -> priv_data ; AVIOContext * pb = avctx -> pb ; AVStream * st = avctx -> streams [ mv -> stream_index ] ; const AVIndexEntry * index ; int frame = mv -> frame [ mv -> stream_index ] ; int ret ; uint64_t pos ; if ( frame < st -> nb_index_entries ) { index = & st -> index_entries [ frame ] ; pos = avio_tell ( pb ) ; if ( index -> pos > pos ) { avio_skip ( pb , index -> pos - pos ) ; } else if ( index -> pos < pos ) { if ( ! pb -> seekable ) { return AVERROR ( EIO ) ; } ret = avio_seek ( pb , index -> pos , SEEK_SET ) ; if ( ret < 0 ) { return ret ; } } ret = av_get_packet ( pb , pkt , index -> size ) ; if ( ret < 0 ) { return ret ; } pkt -> stream_index = mv -> stream_index ; pkt -> pts = index -> timestamp ; pkt -> flags |= AV_PKT_FLAG_KEY ; mv -> frame [ mv -> stream_index ] ++ ; mv -> eof_count = 0 ; } else { mv -> eof_count ++ ; if ( mv -> eof_count >= avctx -> nb_streams ) { return AVERROR_EOF ; } return AVERROR ( EAGAIN ) ; } mv -> stream_index ++ ; if ( mv -> stream_index >= avctx -> nb_streams ) { mv -> stream_index = 0 ; } return 0 ; }##::##1##::##4013
static int parse_object_segment ( AVCodecContext * avctx , const uint8_t * buf , int buf_size ) { PGSSubContext * ctx = avctx -> priv_data ; PGSSubObject * object ; uint8_t sequence_desc ; unsigned int rle_bitmap_len , width , height ; int id ; if ( buf_size <= 4 ) { buf_size -= 4 ; } id = bytestream_get_be16 ( & buf ) ; object = find_object ( id , & ctx -> objects ) ; if ( ! object ) { if ( ctx -> objects . count >= MAX_EPOCH_OBJECTS ) { av_log ( avctx , AV_LOG_ERROR , "Too many objects in epoch\n" ) ; object = & ctx -> objects . object [ ctx -> objects . count ++ ] ; object -> id = id ; buf += 1 ; sequence_desc = bytestream_get_byte ( & buf ) ; if ( ! ( sequence_desc & 0x80 ) ) { if ( buf_size > object -> rle_remaining_len ) { memcpy ( object -> rle + object -> rle_data_len , buf , buf_size ) ; } object -> rle_data_len += buf_size ; object -> rle_remaining_len -= buf_size ; return 0 ; if ( buf_size <= 7 ) { buf_size -= 7 ; } rle_bitmap_len = bytestream_get_be24 ( & buf ) - 2 * 2 ; width = bytestream_get_be16 ( & buf ) ; height = bytestream_get_be16 ( & buf ) ; if ( avctx -> width < width || avctx -> height < height ) { av_log ( avctx , AV_LOG_ERROR , "Bitmap dimensions larger than video.\n" ) ; object -> w = width ; object -> h = height ; av_fast_malloc ( & object -> rle , & object -> rle_buffer_size , rle_bitmap_len ) ; if ( ! object -> rle ) { return AVERROR ( ENOMEM ) ; } memcpy ( object -> rle , buf , buf_size ) ; object -> rle_data_len = buf_size ; object -> rle_remaining_len = rle_bitmap_len - buf_size ; return 0 ;##::##1##::##1151
static int vmdk_read ( BlockDriverState * bs , int64_t sector_num , uint8_t * buf , int nb_sectors ) { BDRVVmdkState * s = bs -> opaque ; int ret ; uint64_t n , index_in_cluster ; VmdkExtent * extent = NULL ; uint64_t cluster_offset ; while ( nb_sectors > 0 ) { extent = find_extent ( s , sector_num , extent ) ; if ( ! extent ) { return - EIO ; } ret = get_cluster_offset ( bs , extent , NULL , sector_num << 9 , 0 , & cluster_offset ) ; index_in_cluster = sector_num % extent -> cluster_sectors ; n = extent -> cluster_sectors - index_in_cluster ; if ( n > nb_sectors ) { n = nb_sectors ; } if ( ret ) { if ( bs -> backing_hd ) { if ( ! vmdk_is_cid_valid ( bs ) ) { return - EINVAL ; } ret = bdrv_read ( bs -> backing_hd , sector_num , buf , n ) ; if ( ret < 0 ) { return ret ; } } else { memset ( buf , 0 , 512 * n ) ; } } else { ret = vmdk_read_extent ( extent , cluster_offset , index_in_cluster * 512 , buf , n ) ; if ( ret ) { return ret ; } } nb_sectors -= n ; sector_num += n ; buf += n * 512 ; } return 0 ; }##::##1##::##11274
static int rle_unpack ( const unsigned char * src , int src_len , int src_count , unsigned char * dest , int dest_len ) { const unsigned char * ps ; const unsigned char * ps_end ; unsigned char * pd ; int i , l ; unsigned char * dest_end = dest + dest_len ; ps = src ; ps_end = src + src_len ; pd = dest ; if ( src_count & 1 ) { if ( ps_end - ps < 1 ) { return 0 ; } * pd ++ = * ps ++ ; } src_count >>= 1 ; i = 0 ; do { if ( ps_end - ps < 1 ) { break ; } l = * ps ++ ; if ( l & 0x80 ) { l = ( l & 0x7F ) * 2 ; if ( pd + l > dest_end || ps_end - ps < l ) { return ps - src ; } memcpy ( pd , ps , l ) ; ps += l ; pd += l ; } else { if ( pd + i > dest_end || ps_end - ps < 2 ) { return ps - src ; } for ( i = 0 ; i < l ; i ++ ) { * pd ++ = ps [ 0 ] ; * pd ++ = ps [ 1 ] ; } ps += 2 ; } i += l ; } while ( i < src_count ) ; return ps - src ; }##::##1##::##1292
static int encode_frame ( AVCodecContext * avctx , uint8_t * buf , int buf_size , void * data ) { int tileno , ret ; J2kEncoderContext * s = avctx -> priv_data ; s -> buf = s -> buf_start = buf ; s -> buf_end = buf + buf_size ; s -> picture = data ; s -> lambda = s -> picture -> quality * LAMBDA_SCALE ; copy_frame ( s ) ; reinit ( s ) ; if ( s -> buf_end - s -> buf < 2 ) { return - 1 ; } bytestream_put_be16 ( & s -> buf , J2K_SOC ) ; if ( ret = put_siz ( s ) ) { return ret ; } if ( ret = put_cod ( s ) ) { return ret ; } if ( ret = put_qcd ( s , 0 ) ) { return ret ; } for ( tileno = 0 ; tileno < s -> numXtiles * s -> numYtiles ; tileno ++ ) { uint8_t * psotptr ; if ( ( psotptr = put_sot ( s , tileno ) ) < 0 ) { return psotptr ; } if ( s -> buf_end - s -> buf < 2 ) { return - 1 ; } bytestream_put_be16 ( & s -> buf , J2K_SOD ) ; if ( ret = encode_tile ( s , s -> tile + tileno , tileno ) ) { return ret ; } bytestream_put_be32 ( & psotptr , s -> buf - psotptr + 6 ) ; } if ( s -> buf_end - s -> buf < 2 ) { return - 1 ; } bytestream_put_be16 ( & s -> buf , J2K_EOC ) ; av_log ( s -> avctx , AV_LOG_DEBUG , "end\n" ) ; return s -> buf - s -> buf_start ; }##::##1##::##1118
static int mxf_read_local_tags ( MXFContext * mxf , KLVPacket * klv , int ( * read_child ) ( ) , int ctx_size , enum MXFMetadataSetType type ) { ByteIOContext * pb = mxf -> fc -> pb ; MXFMetadataSet * ctx = ctx_size ? av_mallocz ( ctx_size ) : mxf ; uint64_t klv_end = url_ftell ( pb ) + klv -> length ; if ( ! ctx ) { return - 1 ; } while ( url_ftell ( pb ) + 4 < klv_end ) { int tag = get_be16 ( pb ) ; int size = get_be16 ( pb ) ; uint64_t next = url_ftell ( pb ) + size ; UID uid = { 0 } ; dprintf ( mxf -> fc , "local tag %#04x size %d\n" , tag , size ) ; if ( ! size ) { av_log ( mxf -> fc , AV_LOG_ERROR , "local tag %#04x with 0 size\n" , tag ) ; continue ; } if ( tag > 0x7FFF ) { int i ; for ( i = 0 ; i < mxf -> local_tags_count ; i ++ ) { int local_tag = AV_RB16 ( mxf -> local_tags + i * 18 ) ; if ( local_tag == tag ) { memcpy ( uid , mxf -> local_tags + i * 18 + 2 , 16 ) ; dprintf ( mxf -> fc , "local tag %#04x\n" , local_tag ) ; PRINT_KEY ( mxf -> fc , "uid" , uid ) ; } } } if ( ctx_size && tag == 0x3C0A ) { get_buffer ( pb , ctx -> uid , 16 ) ; } else if ( read_child ( ctx , pb , tag , size , uid ) < 0 ) { return - 1 ; } url_fseek ( pb , next , SEEK_SET ) ; } if ( ctx_size ) { ctx -> type = type ; } return ctx_size ? mxf_add_metadata_set ( mxf , ctx ) : 0 ; }##::##1##::##5433
static void nal_send ( AVFormatContext * ctx , const uint8_t * buf , int len , int last_packet_of_frame ) { RTPMuxContext * rtp_ctx = ctx -> priv_data ; int rtp_payload_size = rtp_ctx -> max_payload_size - RTP_HEVC_HEADERS_SIZE ; int nal_type = ( buf [ 0 ] >> 1 ) & 0x3F ; if ( len <= rtp_ctx -> max_payload_size ) { int buffered_size = rtp_ctx -> buf_ptr - rtp_ctx -> buf ; if ( buffered_size + 2 + len > rtp_ctx -> max_payload_size ) { flush_buffered ( ctx , 0 ) ; buffered_size = 0 ; } if ( buffered_size + 4 + len <= rtp_ctx -> max_payload_size ) { if ( buffered_size == 0 ) { * rtp_ctx -> buf_ptr ++ = 48 << 1 ; * rtp_ctx -> buf_ptr ++ = 1 ; } AV_WB16 ( rtp_ctx -> buf_ptr , len ) ; rtp_ctx -> buf_ptr += 2 ; memcpy ( rtp_ctx -> buf_ptr , buf , len ) ; rtp_ctx -> buf_ptr += len ; rtp_ctx -> buffered_nals ++ ; } else { flush_buffered ( ctx , 0 ) ; ff_rtp_send_data ( ctx , buf , len , last_packet_of_frame ) ; } } else { flush_buffered ( ctx , 0 ) ; rtp_ctx -> buf [ 0 ] = 49 << 1 ; rtp_ctx -> buf [ 1 ] = 1 ; rtp_ctx -> buf [ 2 ] = nal_type ; rtp_ctx -> buf [ 2 ] |= 1 << 7 ; buf += 2 ; len -= 2 ; while ( len > rtp_payload_size ) { memcpy ( & rtp_ctx -> buf [ RTP_HEVC_HEADERS_SIZE ] , buf , rtp_payload_size ) ; ff_rtp_send_data ( ctx , rtp_ctx -> buf , rtp_ctx -> max_payload_size , 0 ) ; buf += rtp_payload_size ; len -= rtp_payload_size ; rtp_ctx -> buf [ 2 ] &= ~ ( 1 << 7 ) ; } rtp_ctx -> buf [ 2 ] |= 1 << 6 ; memcpy ( & rtp_ctx -> buf [ RTP_HEVC_HEADERS_SIZE ] , buf , len ) ; ff_rtp_send_data ( ctx , rtp_ctx -> buf , len + 2 , last_packet_of_frame ) ; } }##::##1##::##8315
static int calculate_refcounts ( BlockDriverState * bs , BdrvCheckResult * res , BdrvCheckMode fix , bool * rebuild , uint16_t * * refcount_table , int64_t * nb_clusters ) { BDRVQcowState * s = bs -> opaque ; int64_t i ; QCowSnapshot * sn ; int ret ; if ( ! * refcount_table ) { int64_t old_size = 0 ; ret = realloc_refcount_array ( s , refcount_table , & old_size , * nb_clusters ) ; if ( ret < 0 ) { res -> check_errors ++ ; return ret ; } } ret = inc_refcounts ( bs , res , refcount_table , nb_clusters , 0 , s -> cluster_size ) ; if ( ret < 0 ) { return ret ; } ret = check_refcounts_l1 ( bs , res , refcount_table , nb_clusters , s -> l1_table_offset , s -> l1_size , CHECK_FRAG_INFO ) ; if ( ret < 0 ) { return ret ; } for ( i = 0 ; i < s -> nb_snapshots ; i ++ ) { sn = s -> snapshots + i ; ret = check_refcounts_l1 ( bs , res , refcount_table , nb_clusters , sn -> l1_table_offset , sn -> l1_size , 0 ) ; if ( ret < 0 ) { return ret ; } } ret = inc_refcounts ( bs , res , refcount_table , nb_clusters , s -> snapshots_offset , s -> snapshots_size ) ; if ( ret < 0 ) { return ret ; } ret = inc_refcounts ( bs , res , refcount_table , nb_clusters , s -> refcount_table_offset , s -> refcount_table_size * sizeof ( uint64_t ) ) ; if ( ret < 0 ) { return ret ; } return check_refblocks ( bs , res , fix , rebuild , refcount_table , nb_clusters ) ; }##::##1##::##564
static inline TranslationBlock * tb_find ( CPUState * cpu , TranslationBlock * last_tb , int tb_exit ) { CPUArchState * env = ( CPUArchState * ) cpu -> env_ptr ; TranslationBlock * tb ; target_ulong cs_base , pc ; uint32_t flags ; bool acquired_tb_lock = false ; cpu_get_tb_cpu_state ( env , & pc , & cs_base , & flags ) ; tb = atomic_rcu_read ( & cpu -> tb_jmp_cache [ tb_jmp_cache_hash_func ( pc ) ] ) ; if ( unlikely ( ! tb || tb -> pc != pc || tb -> cs_base != cs_base || tb -> flags != flags || tb -> trace_vcpu_dstate != * cpu -> trace_dstate ) ) { tb = tb_htable_lookup ( cpu , pc , cs_base , flags ) ; if ( ! tb ) { mmap_lock ( ) ; tb_lock ( ) ; acquired_tb_lock = true ; tb = tb_htable_lookup ( cpu , pc , cs_base , flags ) ; if ( ! tb ) { tb = tb_gen_code ( cpu , pc , cs_base , flags , 0 ) ; } mmap_unlock ( ) ; } atomic_set ( & cpu -> tb_jmp_cache [ tb_jmp_cache_hash_func ( pc ) ] , tb ) ; } # ifndef CONFIG_USER_ONLY if ( tb -> page_addr [ 1 ] != - 1 ) { last_tb = NULL ; } # endif if ( last_tb && ! qemu_loglevel_mask ( CPU_LOG_TB_NOCHAIN ) ) { if ( ! acquired_tb_lock ) { tb_lock ( ) ; acquired_tb_lock = true ; } if ( ! tb -> invalid ) { tb_add_jump ( last_tb , tb_exit , tb ) ; } } if ( acquired_tb_lock ) { tb_unlock ( ) ; } return tb ; }##::##1##::##9985
static int lag_decode_zero_run_line ( LagarithContext * l , uint8_t * dst , const uint8_t * src , const uint8_t * src_end , int width , int esc_count ) { int i = 0 ; int count ; uint8_t zero_run = 0 ; const uint8_t * src_start = src ; uint8_t mask1 = - ( esc_count < 2 ) ; uint8_t mask2 = - ( esc_count < 3 ) ; uint8_t * end = dst + ( width - 2 ) ; output_zeros : if ( l -> zeros_rem ) { count = FFMIN ( l -> zeros_rem , width - i ) ; if ( end - dst < count ) { av_log ( l -> avctx , AV_LOG_ERROR , "Too many zeros remaining.\n" ) ; return AVERROR_INVALIDDATA ; } memset ( dst , 0 , count ) ; l -> zeros_rem -= count ; dst += count ; } while ( dst < end ) { i = 0 ; while ( ! zero_run && dst + i < end ) { i ++ ; if ( i + 2 >= src_end - src ) { return AVERROR_INVALIDDATA ; } zero_run = ! ( src [ i ] | ( src [ i + 1 ] & mask1 ) | ( src [ i + 2 ] & mask2 ) ) ; } if ( zero_run ) { zero_run = 0 ; i += esc_count ; memcpy ( dst , src , i ) ; dst += i ; l -> zeros_rem = lag_calc_zero_run ( src [ i ] ) ; src += i + 1 ; goto output_zeros ; } else { memcpy ( dst , src , i ) ; src += i ; dst += i ; } } return src - src_start ; }##::##1##::##8336
static void decode_band_structure ( GetBitContext * gbc , int blk , int eac3 , int ecpl , int start_subband , int end_subband , const uint8_t * default_band_struct , uint8_t * band_struct , int * num_subbands , int * num_bands , int * band_sizes ) { int subbnd , bnd , n_subbands , n_bands , bnd_sz [ 22 ] ; n_subbands = end_subband - start_subband ; if ( ! eac3 || get_bits1 ( gbc ) ) { for ( subbnd = 0 ; subbnd < n_subbands - 1 ; subbnd ++ ) { band_struct [ subbnd ] = get_bits1 ( gbc ) ; } } else if ( ! blk ) { memcpy ( band_struct , & default_band_struct [ start_subband + 1 ] , n_subbands - 1 ) ; } band_struct [ n_subbands - 1 ] = 0 ; if ( num_bands || band_sizes ) { n_bands = n_subbands ; bnd_sz [ 0 ] = ecpl ? 6 : 12 ; for ( bnd = 0 , subbnd = 1 ; subbnd < n_subbands ; subbnd ++ ) { int subbnd_size = ( ecpl && subbnd < 4 ) ? 6 : 12 ; if ( band_struct [ subbnd - 1 ] ) { n_bands -- ; bnd_sz [ bnd ] += subbnd_size ; } else { bnd_sz [ ++ bnd ] = subbnd_size ; } } } if ( num_subbands ) { * num_subbands = n_subbands ; } if ( num_bands ) { * num_bands = n_bands ; } if ( band_sizes ) { memcpy ( band_sizes , bnd_sz , sizeof ( int ) * n_bands ) ; } }##::##1##::##10025
static int smvjpeg_decode_frame ( AVCodecContext * avctx , void * data , int * data_size , AVPacket * avpkt ) { const AVPixFmtDescriptor * desc ; SMVJpegDecodeContext * s = avctx -> priv_data ; AVFrame * mjpeg_data = s -> picture [ 0 ] ; int i , cur_frame = 0 , ret = 0 ; cur_frame = avpkt -> pts % s -> frames_per_jpeg ; if ( ! cur_frame ) { av_frame_unref ( mjpeg_data ) ; ret = avcodec_decode_video2 ( s -> avctx , mjpeg_data , & s -> mjpeg_data_size , avpkt ) ; if ( ret < 0 ) { s -> mjpeg_data_size = 0 ; return ret ; } } else if ( ! s -> mjpeg_data_size ) { return AVERROR ( EINVAL ) ; } desc = av_pix_fmt_desc_get ( s -> avctx -> pix_fmt ) ; if ( desc && mjpeg_data -> height % ( s -> frames_per_jpeg << desc -> log2_chroma_h ) ) { av_log ( avctx , AV_LOG_ERROR , "Invalid height\n" ) ; return AVERROR_INVALIDDATA ; } * data_size = s -> mjpeg_data_size ; avctx -> pix_fmt = s -> avctx -> pix_fmt ; ret = ff_set_dimensions ( avctx , mjpeg_data -> width , mjpeg_data -> height / s -> frames_per_jpeg ) ; if ( ret < 0 ) { av_log ( s , AV_LOG_ERROR , "Failed to set dimensions\n" ) ; return ret ; } if ( * data_size ) { s -> picture [ 1 ] -> extended_data = NULL ; s -> picture [ 1 ] -> width = avctx -> width ; s -> picture [ 1 ] -> height = avctx -> height ; s -> picture [ 1 ] -> format = avctx -> pix_fmt ; smv_img_pnt ( s -> picture [ 1 ] -> data , mjpeg_data -> data , mjpeg_data -> linesize , avctx -> pix_fmt , avctx -> width , avctx -> height , cur_frame ) ; for ( i = 0 ; i < AV_NUM_DATA_POINTERS ; i ++ ) { s -> picture [ 1 ] -> linesize [ i ] = mjpeg_data -> linesize [ i ] ; } ret = av_frame_ref ( data , s -> picture [ 1 ] ) ; } return ret ; }##::##1##::##6239
static int cin_read_packet ( AVFormatContext * s , AVPacket * pkt ) { CinDemuxContext * cin = s -> priv_data ; ByteIOContext * pb = s -> pb ; CinFrameHeader * hdr = & cin -> frame_header ; int rc , palette_type , pkt_size ; if ( cin -> audio_buffer_size == 0 ) { rc = cin_read_frame_header ( cin , pb ) ; if ( rc ) { return rc ; } if ( ( int16_t ) hdr -> pal_colors_count < 0 ) { hdr -> pal_colors_count = - ( int16_t ) hdr -> pal_colors_count ; palette_type = 1 ; } else { palette_type = 0 ; } pkt_size = ( palette_type + 3 ) * hdr -> pal_colors_count + hdr -> video_frame_size ; if ( av_new_packet ( pkt , 4 + pkt_size ) ) { return AVERROR ( ENOMEM ) ; } pkt -> stream_index = cin -> video_stream_index ; pkt -> pts = cin -> video_stream_pts ++ ; pkt -> data [ 0 ] = palette_type ; pkt -> data [ 1 ] = hdr -> pal_colors_count & 0xFF ; pkt -> data [ 2 ] = hdr -> pal_colors_count >> 8 ; pkt -> data [ 3 ] = hdr -> video_frame_type ; if ( get_buffer ( pb , & pkt -> data [ 4 ] , pkt_size ) != pkt_size ) { return AVERROR ( EIO ) ; } cin -> audio_buffer_size = hdr -> audio_frame_size ; return 0 ; } if ( av_new_packet ( pkt , cin -> audio_buffer_size ) ) { return AVERROR ( ENOMEM ) ; } pkt -> stream_index = cin -> audio_stream_index ; pkt -> pts = cin -> audio_stream_pts ; cin -> audio_stream_pts += cin -> audio_buffer_size * 2 / cin -> file_header . audio_frame_size ; if ( get_buffer ( pb , pkt -> data , cin -> audio_buffer_size ) != cin -> audio_buffer_size ) { return AVERROR ( EIO ) ; } cin -> audio_buffer_size = 0 ; return 0 ; }##::##1##::##6459
static int send_dma_request ( int cmd , uint64_t sector , int nb_sectors , PrdtEntry * prdt , int prdt_entries ) { QPCIDevice * dev ; uint16_t bmdma_base ; uintptr_t guest_prdt ; size_t len ; bool from_dev ; uint8_t status ; int flags ; dev = get_pci_device ( & bmdma_base ) ; flags = cmd & ~ 0xff ; cmd &= 0xff ; switch ( cmd ) { case CMD_READ_DMA : from_dev = true ; break ; case CMD_WRITE_DMA : from_dev = false ; break ; default : g_assert_not_reached ( ) ; outb ( IDE_BASE + reg_device , 0 | LBA ) ; outb ( bmdma_base + bmreg_cmd , 0 ) ; outb ( bmdma_base + bmreg_status , BM_STS_INTR ) ; len = sizeof ( * prdt ) * prdt_entries ; guest_prdt = guest_alloc ( guest_malloc , len ) ; memwrite ( guest_prdt , prdt , len ) ; outl ( bmdma_base + bmreg_prdt , guest_prdt ) ; outb ( IDE_BASE + reg_nsectors , nb_sectors ) ; outb ( IDE_BASE + reg_lba_low , sector & 0xff ) ; outb ( IDE_BASE + reg_lba_middle , ( sector >> 8 ) & 0xff ) ; outb ( IDE_BASE + reg_lba_high , ( sector >> 16 ) & 0xff ) ; outb ( IDE_BASE + reg_command , cmd ) ; outb ( bmdma_base + bmreg_cmd , BM_CMD_START | ( from_dev ? BM_CMD_WRITE : 0 ) ) ; if ( flags & CMDF_ABORT ) { outb ( bmdma_base + bmreg_cmd , 0 ) ; do { status = inb ( bmdma_base + bmreg_status ) ; } while ( ( status & ( BM_STS_ACTIVE | BM_STS_INTR ) ) == BM_STS_ACTIVE ) ; g_assert_cmpint ( get_irq ( IDE_PRIMARY_IRQ ) , == , ! ! ( status & BM_STS_INTR ) ) ; assert_bit_set ( inb ( IDE_BASE + reg_status ) , DRDY ) ; assert_bit_clear ( inb ( IDE_BASE + reg_status ) , BSY | DRQ ) ; g_assert ( ! get_irq ( IDE_PRIMARY_IRQ ) ) ; if ( status & BM_STS_ACTIVE ) { outb ( bmdma_base + bmreg_cmd , 0 ) ; free_pci_device ( dev ) ; return status ;##::##1##::##3025
static void vc1_inv_trans_4x8_c ( uint8_t * dest , int linesize , DCTELEM * block ) { int i ; register int t1 , t2 , t3 , t4 , t5 , t6 , t7 , t8 ; DCTELEM * src , * dst ; const uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; src = block ; dst = block ; for ( i = 0 ; i < 8 ; i ++ ) { t1 = 17 * ( src [ 0 ] + src [ 2 ] ) + 4 ; t2 = 17 * ( src [ 0 ] - src [ 2 ] ) + 4 ; t3 = 22 * src [ 1 ] + 10 * src [ 3 ] ; t4 = 22 * src [ 3 ] - 10 * src [ 1 ] ; dst [ 0 ] = ( t1 + t3 ) >> 3 ; dst [ 1 ] = ( t2 - t4 ) >> 3 ; dst [ 2 ] = ( t2 + t4 ) >> 3 ; dst [ 3 ] = ( t1 - t3 ) >> 3 ; src += 8 ; dst += 8 ; } src = block ; for ( i = 0 ; i < 4 ; i ++ ) { t1 = 12 * ( src [ 0 ] + src [ 32 ] ) + 64 ; t2 = 12 * ( src [ 0 ] - src [ 32 ] ) + 64 ; t3 = 16 * src [ 16 ] + 6 * src [ 48 ] ; t4 = 6 * src [ 16 ] - 16 * src [ 48 ] ; t5 = t1 + t3 ; t6 = t2 + t4 ; t7 = t2 - t4 ; t8 = t1 - t3 ; t1 = 16 * src [ 8 ] + 15 * src [ 24 ] + 9 * src [ 40 ] + 4 * src [ 56 ] ; t2 = 15 * src [ 8 ] - 4 * src [ 24 ] - 16 * src [ 40 ] - 9 * src [ 56 ] ; t3 = 9 * src [ 8 ] - 16 * src [ 24 ] + 4 * src [ 40 ] + 15 * src [ 56 ] ; t4 = 4 * src [ 8 ] - 9 * src [ 24 ] + 15 * src [ 40 ] - 16 * src [ 56 ] ; dest [ 0 * linesize ] = cm [ dest [ 0 * linesize ] + ( ( t5 + t1 ) >> 7 ) ] ; dest [ 1 * linesize ] = cm [ dest [ 1 * linesize ] + ( ( t6 + t2 ) >> 7 ) ] ; dest [ 2 * linesize ] = cm [ dest [ 2 * linesize ] + ( ( t7 + t3 ) >> 7 ) ] ; dest [ 3 * linesize ] = cm [ dest [ 3 * linesize ] + ( ( t8 + t4 ) >> 7 ) ] ; dest [ 4 * linesize ] = cm [ dest [ 4 * linesize ] + ( ( t8 - t4 + 1 ) >> 7 ) ] ; dest [ 5 * linesize ] = cm [ dest [ 5 * linesize ] + ( ( t7 - t3 + 1 ) >> 7 ) ] ; dest [ 6 * linesize ] = cm [ dest [ 6 * linesize ] + ( ( t6 - t2 + 1 ) >> 7 ) ] ; dest [ 7 * linesize ] = cm [ dest [ 7 * linesize ] + ( ( t5 - t1 + 1 ) >> 7 ) ] ; src ++ ; dest ++ ; } }##::##1##::##4082
static void nvme_process_db ( NvmeCtrl * n , hwaddr addr , int val ) { uint32_t qid ; if ( addr & ( ( 1 << 2 ) - 1 ) ) { return ; } if ( ( ( addr - 0x1000 ) >> 2 ) & 1 ) { uint16_t new_head = val & 0xffff ; int start_sqs ; NvmeCQueue * cq ; qid = ( addr - ( 0x1000 + ( 1 << 2 ) ) ) >> 3 ; if ( nvme_check_cqid ( n , qid ) ) { return ; } cq = n -> cq [ qid ] ; if ( new_head >= cq -> size ) { return ; } start_sqs = nvme_cq_full ( cq ) ? 1 : 0 ; cq -> head = new_head ; if ( start_sqs ) { NvmeSQueue * sq ; QTAILQ_FOREACH ( sq , & cq -> sq_list , entry ) { timer_mod ( sq -> timer , qemu_clock_get_ns ( QEMU_CLOCK_VIRTUAL ) + 500 ) ; } timer_mod ( cq -> timer , qemu_clock_get_ns ( QEMU_CLOCK_VIRTUAL ) + 500 ) ; } if ( cq -> tail != cq -> head ) { nvme_isr_notify ( n , cq ) ; } } else { uint16_t new_tail = val & 0xffff ; NvmeSQueue * sq ; qid = ( addr - 0x1000 ) >> 3 ; if ( nvme_check_sqid ( n , qid ) ) { return ; } sq = n -> sq [ qid ] ; if ( new_tail >= sq -> size ) { return ; } sq -> tail = new_tail ; timer_mod ( sq -> timer , qemu_clock_get_ns ( QEMU_CLOCK_VIRTUAL ) + 500 ) ; } }##::##1##::##8896
static AVStream * add_stream ( AVFormatContext * oc , AVCodec * * codec , enum AVCodecID codec_id ) { AVCodecContext * c ; AVStream * st ; * codec = avcodec_find_encoder ( codec_id ) ; if ( ! ( * codec ) ) { fprintf ( stderr , "Could not find encoder for '%s'\n" , avcodec_get_name ( codec_id ) ) ; exit ( 1 ) ; } st = avformat_new_stream ( oc , * codec ) ; if ( ! st ) { fprintf ( stderr , "Could not allocate stream\n" ) ; exit ( 1 ) ; } st -> id = oc -> nb_streams - 1 ; c = st -> codec ; switch ( ( * codec ) -> type ) { case AVMEDIA_TYPE_AUDIO : st -> id = 1 ; c -> sample_fmt = AV_SAMPLE_FMT_S16 ; c -> bit_rate = 64000 ; c -> sample_rate = 44100 ; c -> channels = 2 ; break ; case AVMEDIA_TYPE_VIDEO : avcodec_get_context_defaults3 ( c , * codec ) ; c -> codec_id = codec_id ; c -> bit_rate = 400000 ; c -> width = 352 ; c -> height = 288 ; c -> time_base . den = STREAM_FRAME_RATE ; c -> time_base . num = 1 ; c -> gop_size = 12 ; c -> pix_fmt = STREAM_PIX_FMT ; if ( c -> codec_id == AV_CODEC_ID_MPEG2VIDEO ) { c -> max_b_frames = 2 ; } if ( c -> codec_id == AV_CODEC_ID_MPEG1VIDEO ) { c -> mb_decision = 2 ; } break ; default : break ; } if ( oc -> oformat -> flags & AVFMT_GLOBALHEADER ) { c -> flags |= CODEC_FLAG_GLOBAL_HEADER ; } return st ; }##::##1##::##3808
static int ram_save_setup ( QEMUFile * f , void * opaque ) { RAMBlock * block ; int64_t ram_pages = last_ram_offset ( ) >> TARGET_PAGE_BITS ; migration_bitmap = bitmap_new ( ram_pages ) ; bitmap_set ( migration_bitmap , 0 , ram_pages ) ; migration_dirty_pages = ram_pages ; mig_throttle_on = false ; dirty_rate_high_cnt = 0 ; if ( migrate_use_xbzrle ( ) ) { qemu_mutex_lock_iothread ( ) ; XBZRLE . cache = cache_init ( migrate_xbzrle_cache_size ( ) / TARGET_PAGE_SIZE , TARGET_PAGE_SIZE ) ; if ( ! XBZRLE . cache ) { qemu_mutex_unlock_iothread ( ) ; DPRINTF ( "Error creating cache\n" ) ; return - 1 ; } qemu_mutex_init ( & XBZRLE . lock ) ; qemu_mutex_unlock_iothread ( ) ; XBZRLE . encoded_buf = g_try_malloc0 ( TARGET_PAGE_SIZE ) ; if ( ! XBZRLE . encoded_buf ) { DPRINTF ( "Error allocating encoded_buf\n" ) ; return - 1 ; } XBZRLE . current_buf = g_try_malloc ( TARGET_PAGE_SIZE ) ; if ( ! XBZRLE . current_buf ) { DPRINTF ( "Error allocating current_buf\n" ) ; g_free ( XBZRLE . encoded_buf ) ; XBZRLE . encoded_buf = NULL ; return - 1 ; } acct_clear ( ) ; } qemu_mutex_lock_iothread ( ) ; qemu_mutex_lock_ramlist ( ) ; bytes_transferred = 0 ; reset_ram_globals ( ) ; memory_global_dirty_log_start ( ) ; migration_bitmap_sync ( ) ; qemu_mutex_unlock_iothread ( ) ; qemu_put_be64 ( f , ram_bytes_total ( ) | RAM_SAVE_FLAG_MEM_SIZE ) ; QTAILQ_FOREACH ( block , & ram_list . blocks , next ) { qemu_put_byte ( f , strlen ( block -> idstr ) ) ; qemu_put_buffer ( f , ( uint8_t * ) block -> idstr , strlen ( block -> idstr ) ) ; qemu_put_be64 ( f , block -> length ) ; } qemu_mutex_unlock_ramlist ( ) ; ram_control_before_iterate ( f , RAM_CONTROL_SETUP ) ; ram_control_after_iterate ( f , RAM_CONTROL_SETUP ) ; qemu_put_be64 ( f , RAM_SAVE_FLAG_EOS ) ; return 0 ; }##::##1##::##11165
static int get_qcx ( Jpeg2000DecoderContext * s , int n , Jpeg2000QuantStyle * q ) { int i , x ; if ( s -> buf_end - s -> buf < 1 ) { return AVERROR_INVALIDDATA ; } x = bytestream_get_byte ( & s -> buf ) ; q -> nguardbits = x >> 5 ; q -> quantsty = x & 0x1f ; if ( q -> quantsty == JPEG2000_QSTY_NONE ) { n -= 3 ; if ( s -> buf_end - s -> buf < n ) { return AVERROR_INVALIDDATA ; } for ( i = 0 ; i < n ; i ++ ) { q -> expn [ i ] = bytestream_get_byte ( & s -> buf ) >> 3 ; } } else if ( q -> quantsty == JPEG2000_QSTY_SI ) { if ( s -> buf_end - s -> buf < 2 ) { return AVERROR_INVALIDDATA ; } x = bytestream_get_be16 ( & s -> buf ) ; q -> expn [ 0 ] = x >> 11 ; q -> mant [ 0 ] = x & 0x7ff ; for ( i = 1 ; i < JPEG2000_MAX_DECLEVELS * 3 ; i ++ ) { int curexpn = FFMAX ( 0 , q -> expn [ 0 ] - ( i - 1 ) / 3 ) ; q -> expn [ i ] = curexpn ; q -> mant [ i ] = q -> mant [ 0 ] ; } } else { n = ( n - 3 ) >> 1 ; if ( s -> buf_end - s -> buf < n ) { return AVERROR_INVALIDDATA ; } for ( i = 0 ; i < n ; i ++ ) { x = bytestream_get_be16 ( & s -> buf ) ; q -> expn [ i ] = x >> 11 ; q -> mant [ i ] = x & 0x7ff ; } } return 0 ; }##::##1##::##9680
static int mov_write_avid_tag ( AVIOContext * pb , MOVTrack * track ) { int i ; avio_wb32 ( pb , 24 ) ; ffio_wfourcc ( pb , "ACLR" ) ; ffio_wfourcc ( pb , "ACLR" ) ; ffio_wfourcc ( pb , "0001" ) ; if ( track -> enc -> color_range == AVCOL_RANGE_MPEG || track -> enc -> color_range == AVCOL_RANGE_UNSPECIFIED ) { avio_wb32 ( pb , 1 ) ; } else { avio_wb32 ( pb , 2 ) ; } avio_wb32 ( pb , 0 ) ; avio_wb32 ( pb , 24 ) ; ffio_wfourcc ( pb , "APRG" ) ; ffio_wfourcc ( pb , "APRG" ) ; ffio_wfourcc ( pb , "0001" ) ; avio_wb32 ( pb , 1 ) ; avio_wb32 ( pb , 0 ) ; avio_wb32 ( pb , 120 ) ; ffio_wfourcc ( pb , "ARES" ) ; ffio_wfourcc ( pb , "ARES" ) ; ffio_wfourcc ( pb , "0001" ) ; avio_wb32 ( pb , AV_RB32 ( track -> vos_data + 0x28 ) ) ; avio_wb32 ( pb , track -> enc -> width ) ; if ( track -> vos_data [ 5 ] & 2 ) { avio_wb32 ( pb , track -> enc -> height / 2 ) ; avio_wb32 ( pb , 2 ) ; avio_wb32 ( pb , 0 ) ; avio_wb32 ( pb , 4 ) ; } else { avio_wb32 ( pb , track -> enc -> height ) ; avio_wb32 ( pb , 1 ) ; avio_wb32 ( pb , 0 ) ; if ( track -> enc -> height == 1080 ) { avio_wb32 ( pb , 5 ) ; } else { avio_wb32 ( pb , 6 ) ; } } for ( i = 0 ; i < 10 ; i ++ ) { avio_wb64 ( pb , 0 ) ; } avio_wb32 ( pb , 0 ) ; return 0 ; }##::##1##::##11224
static int subtitle_thread ( void * arg ) { VideoState * is = arg ; Frame * sp ; int got_subtitle ; double pts ; int i , j ; int r , g , b , y , u , v , a ; for ( ; ; ) { while ( is -> paused && ! is -> subtitleq . abort_request ) { SDL_Delay ( 10 ) ; } if ( ! ( sp = frame_queue_peek_writable ( & is -> subpq ) ) ) { return 0 ; } if ( ( got_subtitle = decoder_decode_frame ( & is -> subdec , & sp -> sub ) ) < 0 ) { break ; } pts = 0 ; if ( got_subtitle && sp -> sub . format == 0 ) { if ( sp -> sub . pts != AV_NOPTS_VALUE ) { pts = sp -> sub . pts / ( double ) AV_TIME_BASE ; } sp -> pts = pts ; sp -> serial = is -> subdec . pkt_serial ; for ( i = 0 ; i < sp -> sub . num_rects ; i ++ ) { for ( j = 0 ; j < sp -> sub . rects [ i ] -> nb_colors ; j ++ ) { RGBA_IN ( r , g , b , a , ( uint32_t * ) sp -> sub . rects [ i ] -> pict . data [ 1 ] + j ) ; y = RGB_TO_Y_CCIR ( r , g , b ) ; u = RGB_TO_U_CCIR ( r , g , b , 0 ) ; v = RGB_TO_V_CCIR ( r , g , b , 0 ) ; YUVA_OUT ( ( uint32_t * ) sp -> sub . rects [ i ] -> pict . data [ 1 ] + j , y , u , v , a ) ; } } frame_queue_push ( & is -> subpq ) ; } else if ( got_subtitle ) { avsubtitle_free ( & sp -> sub ) ; } } return 0 ; }##::##1##::##3429
static int av_buffersrc_add_frame_internal ( AVFilterContext * ctx , AVFrame * frame , int flags ) { BufferSourceContext * s = ctx -> priv ; AVFrame * copy ; int ret ; if ( ! frame ) { s -> eof = 1 ; return 0 ; } else if ( s -> eof ) { return AVERROR ( EINVAL ) ; } if ( ! ( flags & AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT ) ) { switch ( ctx -> outputs [ 0 ] -> type ) { case AVMEDIA_TYPE_VIDEO : CHECK_VIDEO_PARAM_CHANGE ( ctx , s , frame -> width , frame -> height , frame -> format ) ; break ; case AVMEDIA_TYPE_AUDIO : CHECK_AUDIO_PARAM_CHANGE ( ctx , s , frame -> sample_rate , frame -> channel_layout , frame -> format ) ; break ; default : return AVERROR ( EINVAL ) ; } } if ( ! av_fifo_space ( s -> fifo ) && ( ret = av_fifo_realloc2 ( s -> fifo , av_fifo_size ( s -> fifo ) + sizeof ( copy ) ) ) < 0 ) { return ret ; } if ( ! ( copy = av_frame_alloc ( ) ) ) { return AVERROR ( ENOMEM ) ; } av_frame_move_ref ( copy , frame ) ; if ( ( ret = av_fifo_generic_write ( s -> fifo , & copy , sizeof ( copy ) , NULL ) ) < 0 ) { av_frame_move_ref ( frame , copy ) ; av_frame_free ( & copy ) ; return ret ; } if ( ( flags & AV_BUFFERSRC_FLAG_PUSH ) ) if ( ( ret = ctx -> output_pads [ 0 ] . request_frame ( ctx -> outputs [ 0 ] ) ) < 0 ) { return ret ; } return 0 ; }##::##1##::##12021
static bool scsi_target_emulate_inquiry ( SCSITargetReq * r ) { assert ( r -> req . dev -> lun != r -> req . lun ) ; if ( r -> req . cmd . buf [ 1 ] & 0x2 ) { return false ; } if ( r -> req . cmd . buf [ 1 ] & 0x1 ) { uint8_t page_code = r -> req . cmd . buf [ 2 ] ; r -> buf [ r -> len ++ ] = page_code ; r -> buf [ r -> len ++ ] = 0x00 ; switch ( page_code ) { case 0x00 : { int pages ; pages = r -> len ++ ; r -> buf [ r -> len ++ ] = 0x00 ; r -> buf [ pages ] = r -> len - pages - 1 ; break ; } default : return false ; } assert ( r -> len < sizeof ( r -> buf ) ) ; r -> len = MIN ( r -> req . cmd . xfer , r -> len ) ; return true ; } if ( r -> req . cmd . buf [ 2 ] != 0 ) { return false ; } r -> len = MIN ( r -> req . cmd . xfer , 36 ) ; memset ( r -> buf , 0 , r -> len ) ; if ( r -> req . lun != 0 ) { r -> buf [ 0 ] = TYPE_NO_LUN ; } else { r -> buf [ 0 ] = TYPE_NOT_PRESENT | TYPE_INACTIVE ; r -> buf [ 2 ] = 5 ; r -> buf [ 3 ] = 2 | 0x10 ; r -> buf [ 4 ] = r -> len - 5 ; r -> buf [ 7 ] = 0x10 | ( r -> req . bus -> info -> tcq ? 0x02 : 0 ) ; memcpy ( & r -> buf [ 8 ] , "QEMU    " , 8 ) ; memcpy ( & r -> buf [ 16 ] , "QEMU TARGET     " , 16 ) ; pstrcpy ( ( char * ) & r -> buf [ 32 ] , 4 , qemu_get_version ( ) ) ; } return true ; }##::##1##::##8895
static AVFrame * do_psnr ( AVFilterContext * ctx , AVFrame * main , const AVFrame * ref ) { PSNRContext * s = ctx -> priv ; double comp_mse [ 4 ] , mse = 0 ; int j , c ; AVDictionary * * metadata = avpriv_frame_get_metadatap ( main ) ; s -> compute_mse ( s , ( const uint8_t * * ) main -> data , main -> linesize , ( const uint8_t * * ) ref -> data , ref -> linesize , main -> width , main -> height , comp_mse ) ; for ( j = 0 ; j < s -> nb_components ; j ++ ) { mse += comp_mse [ j ] * s -> planeweight [ j ] ; } s -> min_mse = FFMIN ( s -> min_mse , mse ) ; s -> max_mse = FFMAX ( s -> max_mse , mse ) ; s -> mse += mse ; for ( j = 0 ; j < s -> nb_components ; j ++ ) { s -> mse_comp [ j ] += comp_mse [ j ] ; } s -> nb_frames ++ ; for ( j = 0 ; j < s -> nb_components ; j ++ ) { c = s -> is_rgb ? s -> rgba_map [ j ] : j ; set_meta ( metadata , "lavfi.psnr.mse." , s -> comps [ j ] , comp_mse [ c ] ) ; set_meta ( metadata , "lavfi.psnr.psnr." , s -> comps [ j ] , get_psnr ( comp_mse [ c ] , 1 , s -> max [ c ] ) ) ; } set_meta ( metadata , "lavfi.psnr.mse_avg" , 0 , mse ) ; set_meta ( metadata , "lavfi.psnr.psnr_avg" , 0 , get_psnr ( mse , 1 , s -> average_max ) ) ; if ( s -> stats_file ) { fprintf ( s -> stats_file , "n:%" PRId64 " mse_avg:%0.2f " , s -> nb_frames , mse ) ; for ( j = 0 ; j < s -> nb_components ; j ++ ) { c = s -> is_rgb ? s -> rgba_map [ j ] : j ; fprintf ( s -> stats_file , "mse_%c:%0.2f " , s -> comps [ j ] , comp_mse [ c ] ) ; } for ( j = 0 ; j < s -> nb_components ; j ++ ) { c = s -> is_rgb ? s -> rgba_map [ j ] : j ; fprintf ( s -> stats_file , "psnr_%c:%0.2f " , s -> comps [ j ] , get_psnr ( comp_mse [ c ] , 1 , s -> max [ c ] ) ) ; } fprintf ( s -> stats_file , "\n" ) ; } return main ; }##::##1##::##7219
static int celt_header ( AVFormatContext * s , int idx ) { struct ogg * ogg = s -> priv_data ; struct ogg_stream * os = ogg -> streams + idx ; AVStream * st = s -> streams [ idx ] ; struct oggcelt_private * priv = os -> private ; uint8_t * p = os -> buf + os -> pstart ; if ( os -> psize == 60 && ! memcmp ( p , ff_celt_codec . magic , ff_celt_codec . magicsize ) ) { uint32_t version , sample_rate , nb_channels ; uint32_t overlap , extra_headers ; priv = av_malloc ( sizeof ( struct oggcelt_private ) ) ; if ( ! priv ) { return AVERROR ( ENOMEM ) ; } if ( ff_alloc_extradata ( st -> codecpar , 2 * sizeof ( uint32_t ) ) < 0 ) { av_free ( priv ) ; return AVERROR ( ENOMEM ) ; } version = AV_RL32 ( p + 28 ) ; sample_rate = AV_RL32 ( p + 36 ) ; nb_channels = AV_RL32 ( p + 40 ) ; overlap = AV_RL32 ( p + 48 ) ; extra_headers = AV_RL32 ( p + 56 ) ; st -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; st -> codecpar -> codec_id = AV_CODEC_ID_CELT ; st -> codecpar -> sample_rate = sample_rate ; st -> codecpar -> channels = nb_channels ; if ( sample_rate ) { avpriv_set_pts_info ( st , 64 , 1 , sample_rate ) ; } priv -> extra_headers_left = 1 + extra_headers ; av_free ( os -> private ) ; os -> private = priv ; AV_WL32 ( st -> codecpar -> extradata + 0 , overlap ) ; AV_WL32 ( st -> codecpar -> extradata + 4 , version ) ; return 1 ; } else if ( priv && priv -> extra_headers_left ) { ff_vorbis_stream_comment ( s , st , p , os -> psize ) ; priv -> extra_headers_left -- ; return 1 ; } else { return 0 ; } }##::##1##::##12413
static void convert_matrix ( DSPContext * dsp , int ( * qmat ) [ 64 ] , uint16_t ( * qmat16 ) [ 2 ] [ 64 ] , const uint16_t * quant_matrix , int bias , int qmin , int qmax ) { int qscale ; for ( qscale = qmin ; qscale <= qmax ; qscale ++ ) { int i ; if ( dsp -> fdct == ff_jpeg_fdct_islow # ifdef FAAN_POSTSCALE || dsp -> fdct == ff_faandct # endif ) { for ( i = 0 ; i < 64 ; i ++ ) { const int j = dsp -> idct_permutation [ i ] ; qmat [ qscale ] [ i ] = ( int ) ( ( uint64_t_C ( 1 ) << QMAT_SHIFT ) / ( qscale * quant_matrix [ j ] ) ) ; } } else if ( dsp -> fdct == fdct_ifast # ifndef FAAN_POSTSCALE || dsp -> fdct == ff_faandct # endif ) { for ( i = 0 ; i < 64 ; i ++ ) { const int j = dsp -> idct_permutation [ i ] ; qmat [ qscale ] [ i ] = ( int ) ( ( uint64_t_C ( 1 ) << ( QMAT_SHIFT + 14 ) ) / ( aanscales [ i ] * qscale * quant_matrix [ j ] ) ) ; } } else { for ( i = 0 ; i < 64 ; i ++ ) { const int j = dsp -> idct_permutation [ i ] ; qmat [ qscale ] [ i ] = ( int ) ( ( uint64_t_C ( 1 ) << QMAT_SHIFT ) / ( qscale * quant_matrix [ j ] ) ) ; qmat16 [ qscale ] [ 0 ] [ i ] = ( 1 << QMAT_SHIFT_MMX ) / ( qscale * quant_matrix [ j ] ) ; if ( qmat16 [ qscale ] [ 0 ] [ i ] == 0 || qmat16 [ qscale ] [ 0 ] [ i ] == 128 * 256 ) { qmat16 [ qscale ] [ 0 ] [ i ] = 128 * 256 - 1 ; } qmat16 [ qscale ] [ 1 ] [ i ] = ROUNDED_DIV ( bias << ( 16 - QUANT_BIAS_SHIFT ) , qmat16 [ qscale ] [ 0 ] [ i ] ) ; } } } }##::##1##::##453
static inline void RENAME ( hcscale_fast ) ( SwsContext * c , int16_t * dst1 , int16_t * dst2 , long dstWidth , const uint8_t * src1 , const uint8_t * src2 , int srcW , int xInc ) { int32_t * filterPos = c -> hChrFilterPos ; int16_t * filter = c -> hChrFilter ; int canMMX2BeUsed = c -> canMMX2BeUsed ; void * mmx2FilterCode = c -> chrMmx2FilterCode ; int i ; # if defined ( PIC ) DECLARE_ALIGNED ( 8 , uint64_t , ebxsave ) ; # endif __asm__ volatile ( # if defined ( PIC ) "mov          %%" REG_b ", %7         \n\t" # endif "pxor             %%mm7, %%mm7      \n\t" "mov                 %0, %%" REG_c "  \n\t" "mov                 %1, %%" REG_D "  \n\t" "mov                 %2, %%" REG_d "  \n\t" "mov                 %3, %%" REG_b "  \n\t" "xor          %%" REG_a ", %%" REG_a "  \n\t" PREFETCH "   (%%" REG_c ")             \n\t" PREFETCH " 32(%%" REG_c ")             \n\t" PREFETCH " 64(%%" REG_c ")             \n\t" CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE "xor          %%" REG_a ", %%" REG_a "  \n\t" "mov                 %5, %%" REG_c "  \n\t" "mov                 %6, %%" REG_D "  \n\t" PREFETCH "   (%%" REG_c ")             \n\t" PREFETCH " 32(%%" REG_c ")             \n\t" PREFETCH " 64(%%" REG_c ")             \n\t" CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE CALL_MMX2_FILTER_CODE # if defined ( PIC ) "mov %7, %%" REG_b "    \n\t" # endif :: "m" ( src1 ) , "m" ( dst1 ) , "m" ( filter ) , "m" ( filterPos ) , "m" ( mmx2FilterCode ) , "m" ( src2 ) , "m" ( dst2 ) # if defined ( PIC ) , "m" ( ebxsave ) # endif : "%" REG_a , "%" REG_c , "%" REG_d , "%" REG_S , "%" REG_D # if ! defined ( PIC ) , "%" REG_b # endif ) ; for ( i = dstWidth - 1 ; ( i * xInc ) >> 16 >= srcW - 1 ; i -- ) { dst1 [ i ] = src1 [ srcW - 1 ] * 128 ; dst2 [ i ] = src2 [ srcW - 1 ] * 128 ; } }##::##1##::##10805
static int decode_bdlt ( uint8_t * frame , int width , int height , const uint8_t * src , const uint8_t * src_end ) { const uint8_t * frame_end = frame + width * height ; uint8_t * line_ptr ; int count , lines , segments ; count = bytestream_get_le16 ( & src ) ; if ( count >= height || width * count < 0 ) { return - 1 ; } frame += width * count ; lines = bytestream_get_le16 ( & src ) ; if ( frame + lines * width > frame_end || src >= src_end ) { return - 1 ; } while ( lines -- ) { line_ptr = frame ; frame += width ; segments = * src ++ ; while ( segments -- ) { if ( src_end - src < 3 ) { return - 1 ; } line_ptr += * src ++ ; if ( line_ptr >= frame ) { return - 1 ; } count = ( int8_t ) * src ++ ; if ( count >= 0 ) { if ( line_ptr + count > frame || src_end - src < count ) { return - 1 ; } bytestream_get_buffer ( & src , line_ptr , count ) ; } else { count = - count ; if ( line_ptr + count > frame || src >= src_end ) { return - 1 ; } memset ( line_ptr , * src ++ , count ) ; } line_ptr += count ; } } return 0 ; }##::##1##::##7198
static int vdi_check ( BlockDriverState * bs , BdrvCheckResult * res , BdrvCheckMode fix ) { BDRVVdiState * s = ( BDRVVdiState * ) bs -> opaque ; uint32_t blocks_allocated = 0 ; uint32_t block ; uint32_t * bmap ; logout ( "\n" ) ; if ( fix ) { return - ENOTSUP ; } bmap = g_try_malloc ( s -> header . blocks_in_image * sizeof ( uint32_t ) ) ; if ( s -> header . blocks_in_image && bmap == NULL ) { res -> check_errors ++ ; return - ENOMEM ; } memset ( bmap , 0xff , s -> header . blocks_in_image * sizeof ( uint32_t ) ) ; for ( block = 0 ; block < s -> header . blocks_in_image ; block ++ ) { uint32_t bmap_entry = le32_to_cpu ( s -> bmap [ block ] ) ; if ( VDI_IS_ALLOCATED ( bmap_entry ) ) { if ( bmap_entry < s -> header . blocks_in_image ) { blocks_allocated ++ ; if ( ! VDI_IS_ALLOCATED ( bmap [ bmap_entry ] ) ) { bmap [ bmap_entry ] = bmap_entry ; } else { fprintf ( stderr , "ERROR: block index %" PRIu32 " also used by %" PRIu32 "\n" , bmap [ bmap_entry ] , bmap_entry ) ; res -> corruptions ++ ; } } else { fprintf ( stderr , "ERROR: block index %" PRIu32 " too large, is %" PRIu32 "\n" , block , bmap_entry ) ; res -> corruptions ++ ; } } } if ( blocks_allocated != s -> header . blocks_allocated ) { fprintf ( stderr , "ERROR: allocated blocks mismatch, is %" PRIu32 ", should be %" PRIu32 "\n" , blocks_allocated , s -> header . blocks_allocated ) ; res -> corruptions ++ ; } g_free ( bmap ) ; return 0 ; }##::##1##::##5052
static int net_socket_connect_init ( NetClientState * peer , const char * model , const char * name , const char * host_str ) { NetSocketState * s ; int fd , connected , ret ; struct sockaddr_in saddr ; if ( parse_host_port ( & saddr , host_str ) < 0 ) { return - 1 ; } fd = qemu_socket ( PF_INET , SOCK_STREAM , 0 ) ; if ( fd < 0 ) { perror ( "socket" ) ; return - 1 ; } qemu_set_nonblock ( fd ) ; connected = 0 ; for ( ; ; ) { ret = connect ( fd , ( struct sockaddr * ) & saddr , sizeof ( saddr ) ) ; if ( ret < 0 ) { if ( errno == EINTR || errno == EWOULDBLOCK ) { } else if ( errno == EINPROGRESS || errno == EALREADY || errno == EINVAL ) { break ; } else { perror ( "connect" ) ; closesocket ( fd ) ; return - 1 ; } } else { connected = 1 ; break ; } } s = net_socket_fd_init ( peer , model , name , fd , connected ) ; if ( ! s ) { return - 1 ; } snprintf ( s -> nc . info_str , sizeof ( s -> nc . info_str ) , "socket: connect to %s:%d" , inet_ntoa ( saddr . sin_addr ) , ntohs ( saddr . sin_port ) ) ; return 0 ; }##::##1##::##327
static int aio_write_f ( int argc , char * * argv ) { int nr_iov , c ; int pattern = 0xcd ; struct aio_ctx * ctx = calloc ( 1 , sizeof ( struct aio_ctx ) ) ; BlockDriverAIOCB * acb ; while ( ( c = getopt ( argc , argv , "CqP:" ) ) != EOF ) { switch ( c ) { case 'C' : ctx -> Cflag = 1 ; break ; case 'q' : ctx -> qflag = 1 ; break ; case 'P' : pattern = parse_pattern ( optarg ) ; if ( pattern < 0 ) { return 0 ; } break ; default : return command_usage ( & aio_write_cmd ) ; } } if ( optind > argc - 2 ) { return command_usage ( & aio_write_cmd ) ; } ctx -> offset = cvtnum ( argv [ optind ] ) ; if ( ctx -> offset < 0 ) { printf ( "non-numeric length argument -- %s\n" , argv [ optind ] ) ; return 0 ; } optind ++ ; if ( ctx -> offset & 0x1ff ) { printf ( "offset %" PRId64 " is not sector aligned\n" , ctx -> offset ) ; return 0 ; } nr_iov = argc - optind ; ctx -> buf = create_iovec ( & ctx -> qiov , & argv [ optind ] , nr_iov , pattern ) ; gettimeofday ( & ctx -> t1 , NULL ) ; acb = bdrv_aio_writev ( bs , ctx -> offset >> 9 , & ctx -> qiov , ctx -> qiov . size >> 9 , aio_write_done , ctx ) ; if ( ! acb ) { free ( ctx -> buf ) ; return - EIO ; } return 0 ; }##::##1##::##4603
void virtio_save ( VirtIODevice * vdev , QEMUFile * f ) { BusState * qbus = qdev_get_parent_bus ( DEVICE ( vdev ) ) ; VirtioBusClass * k = VIRTIO_BUS_GET_CLASS ( qbus ) ; VirtioDeviceClass * vdc = VIRTIO_DEVICE_GET_CLASS ( vdev ) ; uint32_t guest_features_lo = ( vdev -> guest_features & 0xffffffff ) ; int i ; if ( k -> save_config ) { k -> save_config ( qbus -> parent , f ) ; } qemu_put_8s ( f , & vdev -> status ) ; qemu_put_8s ( f , & vdev -> isr ) ; qemu_put_be16s ( f , & vdev -> queue_sel ) ; qemu_put_be32s ( f , & guest_features_lo ) ; qemu_put_be32 ( f , vdev -> config_len ) ; qemu_put_buffer ( f , vdev -> config , vdev -> config_len ) ; for ( i = 0 ; i < VIRTIO_QUEUE_MAX ; i ++ ) { if ( vdev -> vq [ i ] . vring . num == 0 ) { break ; } } qemu_put_be32 ( f , i ) ; for ( i = 0 ; i < VIRTIO_QUEUE_MAX ; i ++ ) { if ( vdev -> vq [ i ] . vring . num == 0 ) { break ; } qemu_put_be32 ( f , vdev -> vq [ i ] . vring . num ) ; if ( k -> has_variable_vring_alignment ) { qemu_put_be32 ( f , vdev -> vq [ i ] . vring . align ) ; } qemu_put_be64 ( f , vdev -> vq [ i ] . vring . desc ) ; qemu_put_be16s ( f , & vdev -> vq [ i ] . last_avail_idx ) ; if ( k -> save_queue ) { k -> save_queue ( qbus -> parent , i , f ) ; } } if ( vdc -> save != NULL ) { vdc -> save ( vdev , f ) ; } if ( vdc -> vmsd ) { vmstate_save_state ( f , vdc -> vmsd , vdev , NULL ) ; } vmstate_save_state ( f , & vmstate_virtio , vdev , NULL ) ; }##::##1##::##2919
static inline void RENAME ( rgb24tobgr24 ) ( const uint8_t * src , uint8_t * dst , unsigned int src_size ) { unsigned i ; # ifdef HAVE_MMX long mmx_size = 23 - src_size ; asm volatile ( "movq " MANGLE ( mask24r ) ", %%mm5	\n\t" "movq " MANGLE ( mask24g ) ", %%mm6	\n\t" "movq " MANGLE ( mask24b ) ", %%mm7	\n\t" ".balign 16			\n\t" "1:				\n\t" PREFETCH " 32(%1, %%" REG_a ")	\n\t" "movq   (%1, %%" REG_a "), %%mm0	\n\t" "movq   (%1, %%" REG_a "), %%mm1	\n\t" "movq  2(%1, %%" REG_a "), %%mm2	\n\t" "psllq $16, %%mm0		\n\t" "pand %%mm5, %%mm0		\n\t" "pand %%mm6, %%mm1		\n\t" "pand %%mm7, %%mm2		\n\t" "por %%mm0, %%mm1		\n\t" "por %%mm2, %%mm1		\n\t" "movq  6(%1, %%" REG_a "), %%mm0	\n\t" MOVNTQ " %%mm1,   (%2, %%" REG_a ")\n\t" "movq  8(%1, %%" REG_a "), %%mm1	\n\t" "movq 10(%1, %%" REG_a "), %%mm2	\n\t" "pand %%mm7, %%mm0		\n\t" "pand %%mm5, %%mm1		\n\t" "pand %%mm6, %%mm2		\n\t" "por %%mm0, %%mm1		\n\t" "por %%mm2, %%mm1		\n\t" "movq 14(%1, %%" REG_a "), %%mm0	\n\t" MOVNTQ " %%mm1,  8(%2, %%" REG_a ")\n\t" "movq 16(%1, %%" REG_a "), %%mm1	\n\t" "movq 18(%1, %%" REG_a "), %%mm2	\n\t" "pand %%mm6, %%mm0		\n\t" "pand %%mm7, %%mm1		\n\t" "pand %%mm5, %%mm2		\n\t" "por %%mm0, %%mm1		\n\t" "por %%mm2, %%mm1		\n\t" MOVNTQ " %%mm1, 16(%2, %%" REG_a ")\n\t" "add $24, %%" REG_a "		\n\t" " js 1b				\n\t" : "+a" ( mmx_size ) : "r" ( src - mmx_size ) , "r" ( dst - mmx_size ) ) ; __asm __volatile ( SFENCE :: : "memory" ) ; __asm __volatile ( EMMS :: : "memory" ) ; if ( mmx_size == 23 ) { return ; } src += src_size ; dst += src_size ; src_size = 23 - mmx_size ; src -= src_size ; dst -= src_size ; # endif for ( i = 0 ; i < src_size ; i += 3 ) { register uint8_t x ; x = src [ i + 2 ] ; dst [ i + 1 ] = src [ i + 1 ] ; dst [ i + 2 ] = src [ i + 0 ] ; dst [ i + 0 ] = x ; } }##::##1##::##4115
void ff_check_pixfmt_descriptors ( void ) { int i , j ; for ( i = 0 ; i < FF_ARRAY_ELEMS ( av_pix_fmt_descriptors ) ; i ++ ) { const AVPixFmtDescriptor * d = & av_pix_fmt_descriptors [ i ] ; uint8_t fill [ 4 ] [ 8 + 6 + 3 ] = { { 0 } } ; uint8_t * data [ 4 ] = { fill [ 0 ] , fill [ 1 ] , fill [ 2 ] , fill [ 3 ] } ; int linesize [ 4 ] = { 0 , 0 , 0 , 0 } ; uint16_t tmp [ 2 ] ; if ( ! d -> name && ! d -> nb_components && ! d -> log2_chroma_w && ! d -> log2_chroma_h && ! d -> flags ) { continue ; } av_assert0 ( d -> log2_chroma_w <= 3 ) ; av_assert0 ( d -> log2_chroma_h <= 3 ) ; av_assert0 ( d -> nb_components <= 4 ) ; av_assert0 ( d -> name && d -> name [ 0 ] ) ; av_assert0 ( ( d -> nb_components == 4 || d -> nb_components == 2 ) == ! ! ( d -> flags & AV_PIX_FMT_FLAG_ALPHA ) ) ; av_assert2 ( av_get_pix_fmt ( d -> name ) == i ) ; for ( j = 0 ; j < FF_ARRAY_ELEMS ( d -> comp ) ; j ++ ) { const AVComponentDescriptor * c = & d -> comp [ j ] ; if ( j >= d -> nb_components ) { av_assert0 ( ! c -> plane && ! c -> step_minus1 && ! c -> offset_plus1 && ! c -> shift && ! c -> depth_minus1 ) ; continue ; } if ( d -> flags & AV_PIX_FMT_FLAG_BITSTREAM ) { av_assert0 ( c -> step_minus1 >= c -> depth_minus1 ) ; } else { av_assert0 ( 8 * ( c -> step_minus1 + 1 ) >= c -> depth_minus1 + 1 ) ; } av_read_image_line ( tmp , ( void * ) data , linesize , d , 0 , 0 , j , 2 , 0 ) ; if ( ! strncmp ( d -> name , "bayer_" , 6 ) ) { continue ; } av_assert0 ( tmp [ 0 ] == 0 && tmp [ 1 ] == 0 ) ; tmp [ 0 ] = tmp [ 1 ] = ( 1 << ( c -> depth_minus1 + 1 ) ) - 1 ; av_write_image_line ( tmp , data , linesize , d , 0 , 0 , j , 2 ) ; } } }##::##1##::##4694
static void dwt_encode97_float ( DWTContext * s , float * t ) { int lev , w = s -> linelen [ s -> ndeclevels - 1 ] [ 0 ] ; float * line = s -> f_linebuf ; line += 5 ; for ( lev = s -> ndeclevels - 1 ; lev >= 0 ; lev -- ) { int lh = s -> linelen [ lev ] [ 0 ] , lv = s -> linelen [ lev ] [ 1 ] , mh = s -> mod [ lev ] [ 0 ] , mv = s -> mod [ lev ] [ 1 ] , lp ; float * l ; l = line + mh ; for ( lp = 0 ; lp < lv ; lp ++ ) { int i , j = 0 ; for ( i = 0 ; i < lh ; i ++ ) { l [ i ] = t [ w * lp + i ] ; } sd_1d97_float ( line , mh , mh + lh ) ; for ( i = mh ; i < lh ; i += 2 , j ++ ) { t [ w * lp + j ] = F_LFTG_X * l [ i ] / 2 ; } for ( i = 1 - mh ; i < lh ; i += 2 , j ++ ) { t [ w * lp + j ] = F_LFTG_K * l [ i ] / 2 ; } } l = line + mv ; for ( lp = 0 ; lp < lh ; lp ++ ) { int i , j = 0 ; for ( i = 0 ; i < lv ; i ++ ) { l [ i ] = t [ w * i + lp ] ; } sd_1d97_float ( line , mv , mv + lv ) ; for ( i = mv ; i < lv ; i += 2 , j ++ ) { t [ w * j + lp ] = F_LFTG_X * l [ i ] / 2 ; } for ( i = 1 - mv ; i < lv ; i += 2 , j ++ ) { t [ w * j + lp ] = F_LFTG_K * l [ i ] / 2 ; } } } }##::##1##::##6127
static void readline_hist_add ( ReadLineState * rs , const char * cmdline ) { char * hist_entry , * new_entry ; int idx ; if ( cmdline [ 0 ] == '\0' ) { return ; } new_entry = NULL ; if ( rs -> hist_entry != - 1 ) { hist_entry = rs -> history [ rs -> hist_entry ] ; idx = rs -> hist_entry ; if ( strcmp ( hist_entry , cmdline ) == 0 ) { goto same_entry ; } } for ( idx = 0 ; idx < READLINE_MAX_CMDS ; idx ++ ) { hist_entry = rs -> history [ idx ] ; if ( hist_entry == NULL ) { break ; } if ( strcmp ( hist_entry , cmdline ) == 0 ) { same_entry : new_entry = hist_entry ; memmove ( & rs -> history [ idx ] , & rs -> history [ idx + 1 ] , ( READLINE_MAX_CMDS - idx + 1 ) * sizeof ( char * ) ) ; rs -> history [ READLINE_MAX_CMDS - 1 ] = NULL ; for ( ; idx < READLINE_MAX_CMDS ; idx ++ ) { if ( rs -> history [ idx ] == NULL ) { break ; } } break ; } } if ( idx == READLINE_MAX_CMDS ) { free ( rs -> history [ 0 ] ) ; memcpy ( rs -> history , & rs -> history [ 1 ] , ( READLINE_MAX_CMDS - 1 ) * sizeof ( char * ) ) ; rs -> history [ READLINE_MAX_CMDS - 1 ] = NULL ; idx = READLINE_MAX_CMDS - 1 ; } if ( new_entry == NULL ) { new_entry = strdup ( cmdline ) ; } rs -> history [ idx ] = new_entry ; rs -> hist_entry = - 1 ; }##::##1##::##11769
AVInputFormat * av_probe_input_format3 ( AVProbeData * pd , int is_opened , int * score_ret ) { AVProbeData lpd = * pd ; AVInputFormat * fmt1 = NULL , * fmt ; int score , nodat = 0 , score_max = 0 ; if ( lpd . buf_size > 10 && ff_id3v2_match ( lpd . buf , ID3v2_DEFAULT_MAGIC ) ) { int id3len = ff_id3v2_tag_len ( lpd . buf ) ; if ( lpd . buf_size > id3len + 16 ) { lpd . buf += id3len ; lpd . buf_size -= id3len ; } else { nodat = 1 ; } } fmt = NULL ; while ( ( fmt1 = av_iformat_next ( fmt1 ) ) ) { if ( ! is_opened == ! ( fmt1 -> flags & AVFMT_NOFILE ) ) { continue ; } score = 0 ; if ( fmt1 -> read_probe ) { score = fmt1 -> read_probe ( & lpd ) ; if ( fmt1 -> extensions && av_match_ext ( lpd . filename , fmt1 -> extensions ) ) { score = FFMAX ( score , nodat ? AVPROBE_SCORE_MAX / 4 - 1 : 1 ) ; } } else if ( fmt1 -> extensions ) { if ( av_match_ext ( lpd . filename , fmt1 -> extensions ) ) { score = 50 ; } } if ( score > score_max ) { score_max = score ; fmt = fmt1 ; } else if ( score == score_max ) { fmt = NULL ; } } * score_ret = score_max ; return fmt ; }##::##1##::##5146
static int open_f ( BlockDriverState * bs , int argc , char * * argv ) { int flags = 0 ; int readonly = 0 ; int growable = 0 ; int c ; QemuOpts * qopts ; QDict * opts ; while ( ( c = getopt ( argc , argv , "snrgo:" ) ) != EOF ) { switch ( c ) { case 's' : flags |= BDRV_O_SNAPSHOT ; break ; case 'n' : flags |= BDRV_O_NOCACHE | BDRV_O_CACHE_WB ; break ; case 'r' : readonly = 1 ; break ; case 'g' : growable = 1 ; break ; case 'o' : if ( ! qemu_opts_parse ( & empty_opts , optarg , 0 ) ) { printf ( "could not parse option list -- %s\n" , optarg ) ; qemu_opts_reset ( & empty_opts ) ; return 0 ; } break ; default : qemu_opts_reset ( & empty_opts ) ; return qemuio_command_usage ( & open_cmd ) ; } } if ( ! readonly ) { flags |= BDRV_O_RDWR ; } qopts = qemu_opts_find ( & empty_opts , NULL ) ; opts = qopts ? qemu_opts_to_qdict ( qopts , NULL ) : NULL ; qemu_opts_reset ( & empty_opts ) ; if ( optind == argc - 1 ) { return openfile ( argv [ optind ] , flags , growable , opts ) ; } else if ( optind == argc ) { return openfile ( NULL , flags , growable , opts ) ; } else { return qemuio_command_usage ( & open_cmd ) ; } }##::##1##::##9091
static int rdma_add_block ( RDMAContext * rdma , const char * block_name , void * host_addr , ram_addr_t block_offset , uint64_t length ) { RDMALocalBlocks * local = & rdma -> local_ram_blocks ; RDMALocalBlock * block ; RDMALocalBlock * old = local -> block ; local -> block = g_malloc0 ( sizeof ( RDMALocalBlock ) * ( local -> nb_blocks + 1 ) ) ; if ( local -> nb_blocks ) { int x ; if ( rdma -> blockmap ) { for ( x = 0 ; x < local -> nb_blocks ; x ++ ) { g_hash_table_remove ( rdma -> blockmap , ( void * ) ( uintptr_t ) old [ x ] . offset ) ; g_hash_table_insert ( rdma -> blockmap , ( void * ) ( uintptr_t ) old [ x ] . offset , & local -> block [ x ] ) ; } } memcpy ( local -> block , old , sizeof ( RDMALocalBlock ) * local -> nb_blocks ) ; g_free ( old ) ; } block = & local -> block [ local -> nb_blocks ] ; block -> block_name = g_strdup ( block_name ) ; block -> local_host_addr = host_addr ; block -> offset = block_offset ; block -> length = length ; block -> index = local -> nb_blocks ; block -> src_index = ~ 0U ; block -> nb_chunks = ram_chunk_index ( host_addr , host_addr + length ) + 1UL ; block -> transit_bitmap = bitmap_new ( block -> nb_chunks ) ; bitmap_clear ( block -> transit_bitmap , 0 , block -> nb_chunks ) ; block -> unregister_bitmap = bitmap_new ( block -> nb_chunks ) ; bitmap_clear ( block -> unregister_bitmap , 0 , block -> nb_chunks ) ; block -> remote_keys = g_malloc0 ( block -> nb_chunks * sizeof ( uint32_t ) ) ; block -> is_ram_block = local -> init ? false : true ; if ( rdma -> blockmap ) { g_hash_table_insert ( rdma -> blockmap , ( void * ) block_offset , block ) ; } trace_rdma_add_block ( block_name , local -> nb_blocks , ( uintptr_t ) block -> local_host_addr , block -> offset , block -> length , ( uintptr_t ) ( block -> local_host_addr + block -> length ) , BITS_TO_LONGS ( block -> nb_chunks ) * sizeof ( unsigned long ) * 8 , block -> nb_chunks ) ; local -> nb_blocks ++ ; return 0 ; }##::##1##::##1786
static int convert_sub_to_old_ass_form ( AVSubtitle * sub , const AVPacket * pkt , AVRational tb ) { int i ; AVBPrint buf ; av_bprint_init ( & buf , 0 , AV_BPRINT_SIZE_UNLIMITED ) ; for ( i = 0 ; i < sub -> num_rects ; i ++ ) { char * final_dialog ; const char * dialog ; AVSubtitleRect * rect = sub -> rects [ i ] ; int ts_start , ts_duration = - 1 ; long int layer ; if ( rect -> type != SUBTITLE_ASS || ! strncmp ( rect -> ass , "Dialogue " , 10 ) ) { continue ; } av_bprint_clear ( & buf ) ; dialog = strchr ( rect -> ass , ',' ) ; if ( ! dialog ) { continue ; } dialog ++ ; layer = strtol ( dialog , ( char * * ) & dialog , 10 ) ; if ( * dialog != ',' ) { continue ; } dialog ++ ; ts_start = av_rescale_q ( pkt -> pts , tb , av_make_q ( 1 , 100 ) ) ; if ( pkt -> duration != - 1 ) { ts_duration = av_rescale_q ( pkt -> duration , tb , av_make_q ( 1 , 100 ) ) ; } sub -> end_display_time = FFMAX ( sub -> end_display_time , 10 * ts_duration ) ; av_bprintf ( & buf , "Dialogue: %ld," , layer ) ; insert_ts ( & buf , ts_start ) ; insert_ts ( & buf , ts_duration == - 1 ? - 1 : ts_start + ts_duration ) ; av_bprintf ( & buf , "%s\r\n" , dialog ) ; final_dialog = av_strdup ( buf . str ) ; if ( ! av_bprint_is_complete ( & buf ) || ! final_dialog ) { av_freep ( & final_dialog ) ; av_bprint_finalize ( & buf , NULL ) ; return AVERROR ( ENOMEM ) ; } av_freep ( & rect -> ass ) ; rect -> ass = final_dialog ; } av_bprint_finalize ( & buf , NULL ) ; return 0 ; }##::##1##::##7919
static void cpu_ioreq_move ( ioreq_t * req ) { int i , sign ; sign = req -> df ? - 1 : 1 ; if ( ! req -> data_is_ptr ) { if ( req -> dir == IOREQ_READ ) { for ( i = 0 ; i < req -> count ; i ++ ) { cpu_physical_memory_read ( req -> addr + ( sign * i * ( int64_t ) req -> size ) , ( uint8_t * ) & req -> data , req -> size ) ; } } else if ( req -> dir == IOREQ_WRITE ) { for ( i = 0 ; i < req -> count ; i ++ ) { cpu_physical_memory_write ( req -> addr + ( sign * i * ( int64_t ) req -> size ) , ( uint8_t * ) & req -> data , req -> size ) ; } } } else { uint64_t tmp ; if ( req -> dir == IOREQ_READ ) { for ( i = 0 ; i < req -> count ; i ++ ) { cpu_physical_memory_read ( req -> addr + ( sign * i * ( int64_t ) req -> size ) , ( uint8_t * ) & tmp , req -> size ) ; cpu_physical_memory_write ( req -> data + ( sign * i * ( int64_t ) req -> size ) , ( uint8_t * ) & tmp , req -> size ) ; } } else if ( req -> dir == IOREQ_WRITE ) { for ( i = 0 ; i < req -> count ; i ++ ) { cpu_physical_memory_read ( req -> data + ( sign * i * ( int64_t ) req -> size ) , ( uint8_t * ) & tmp , req -> size ) ; cpu_physical_memory_write ( req -> addr + ( sign * i * ( int64_t ) req -> size ) , ( uint8_t * ) & tmp , req -> size ) ; } } } }##::##1##::##10542
static void kvm_cpu_fill_host ( x86_def_t * x86_cpu_def ) { # ifdef CONFIG_KVM KVMState * s = kvm_state ; uint32_t eax = 0 , ebx = 0 , ecx = 0 , edx = 0 ; assert ( kvm_enabled ( ) ) ; x86_cpu_def -> name = "host" ; host_cpuid ( 0x0 , 0 , & eax , & ebx , & ecx , & edx ) ; x86_cpu_vendor_words2str ( x86_cpu_def -> vendor , ebx , edx , ecx ) ; host_cpuid ( 0x1 , 0 , & eax , & ebx , & ecx , & edx ) ; x86_cpu_def -> family = ( ( eax >> 8 ) & 0x0F ) + ( ( eax >> 20 ) & 0xFF ) ; x86_cpu_def -> model = ( ( eax >> 4 ) & 0x0F ) | ( ( eax & 0xF0000 ) >> 12 ) ; x86_cpu_def -> stepping = eax & 0x0F ; x86_cpu_def -> level = kvm_arch_get_supported_cpuid ( s , 0x0 , 0 , R_EAX ) ; x86_cpu_def -> features [ FEAT_1_EDX ] = kvm_arch_get_supported_cpuid ( s , 0x1 , 0 , R_EDX ) ; x86_cpu_def -> features [ FEAT_1_ECX ] = kvm_arch_get_supported_cpuid ( s , 0x1 , 0 , R_ECX ) ; if ( x86_cpu_def -> level >= 7 ) { x86_cpu_def -> features [ FEAT_7_0_EBX ] = kvm_arch_get_supported_cpuid ( s , 0x7 , 0 , R_EBX ) ; } else { x86_cpu_def -> features [ FEAT_7_0_EBX ] = 0 ; } x86_cpu_def -> xlevel = kvm_arch_get_supported_cpuid ( s , 0x80000000 , 0 , R_EAX ) ; x86_cpu_def -> features [ FEAT_8000_0001_EDX ] = kvm_arch_get_supported_cpuid ( s , 0x80000001 , 0 , R_EDX ) ; x86_cpu_def -> features [ FEAT_8000_0001_ECX ] = kvm_arch_get_supported_cpuid ( s , 0x80000001 , 0 , R_ECX ) ; cpu_x86_fill_model_id ( x86_cpu_def -> model_id ) ; if ( ! strcmp ( x86_cpu_def -> vendor , CPUID_VENDOR_VIA ) ) { host_cpuid ( 0xC0000000 , 0 , & eax , & ebx , & ecx , & edx ) ; eax = kvm_arch_get_supported_cpuid ( s , 0xC0000000 , 0 , R_EAX ) ; if ( eax >= 0xC0000001 ) { x86_cpu_def -> xlevel2 = eax ; host_cpuid ( 0xC0000001 , 0 , & eax , & ebx , & ecx , & edx ) ; x86_cpu_def -> features [ FEAT_C000_0001_EDX ] = kvm_arch_get_supported_cpuid ( s , 0xC0000001 , 0 , R_EDX ) ; } } x86_cpu_def -> features [ FEAT_SVM ] = kvm_arch_get_supported_cpuid ( s , 0x8000000A , 0 , R_EDX ) ; x86_cpu_def -> features [ FEAT_KVM ] = kvm_arch_get_supported_cpuid ( s , KVM_CPUID_FEATURES , 0 , R_EAX ) ; # endif }##::##1##::##12135
static int pcm_dvd_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) { AVFrame * frame = data ; const uint8_t * src = avpkt -> data ; int buf_size = avpkt -> size ; PCMDVDContext * s = avctx -> priv_data ; int retval ; int blocks ; void * dst ; if ( buf_size < 3 ) { av_log ( avctx , AV_LOG_ERROR , "PCM packet too small\n" ) ; return AVERROR_INVALIDDATA ; if ( ( retval = pcm_dvd_parse_header ( avctx , src ) ) ) { return retval ; } src += 3 ; buf_size -= 3 ; blocks = ( buf_size + s -> extra_sample_count ) / s -> block_size ; frame -> nb_samples = blocks * s -> samples_per_block ; if ( ( retval = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) { av_log ( avctx , AV_LOG_ERROR , "get_buffer() failed\n" ) ; return retval ; dst = frame -> data [ 0 ] ; if ( s -> extra_sample_count ) { int missing_samples = s -> block_size - s -> extra_sample_count ; if ( buf_size >= missing_samples ) { memcpy ( s -> extra_samples + s -> extra_sample_count , src , missing_samples ) ; dst = pcm_dvd_decode_samples ( avctx , s -> extra_samples , dst , 1 ) ; src += missing_samples ; buf_size -= missing_samples ; blocks -- ; } else { memcpy ( s -> extra_samples + s -> extra_sample_count , src , buf_size ) ; s -> extra_sample_count += buf_size ; return avpkt -> size ; if ( blocks ) { pcm_dvd_decode_samples ( avctx , src , dst , blocks ) ; buf_size -= blocks * s -> block_size ; if ( buf_size ) { src += blocks * s -> block_size ; memcpy ( s -> extra_samples , src , buf_size ) ; s -> extra_sample_count = buf_size ; * got_frame_ptr = 1 ; return avpkt -> size ;##::##1##::##3038
void av_log_default_callback ( void * ptr , int level , const char * fmt , va_list vl ) { static int print_prefix = 1 ; static int count ; static char line [ 1024 ] , prev [ 1024 ] ; static int is_atty ; AVClass * avc = ptr ? * ( AVClass * * ) ptr : NULL ; if ( level > av_log_level ) { return ; } line [ 0 ] = 0 ; # undef fprintf if ( print_prefix && avc ) { if ( avc -> parent_log_context_offset ) { AVClass * * parent = * ( AVClass * * * ) ( ( ( uint8_t * ) ptr ) + avc -> parent_log_context_offset ) ; if ( parent && * parent ) { snprintf ( line , sizeof ( line ) , "[%s @ %p] " , ( * parent ) -> item_name ( parent ) , parent ) ; } } snprintf ( line + strlen ( line ) , sizeof ( line ) - strlen ( line ) , "[%s @ %p] " , avc -> item_name ( ptr ) , ptr ) ; } vsnprintf ( line + strlen ( line ) , sizeof ( line ) - strlen ( line ) , fmt , vl ) ; print_prefix = line [ strlen ( line ) - 1 ] == '\n' ; # if HAVE_ISATTY if ( ! is_atty ) { is_atty = isatty ( 2 ) ? 1 : - 1 ; } # endif if ( print_prefix && ( flags & AV_LOG_SKIP_REPEATED ) && ! strcmp ( line , prev ) ) { count ++ ; if ( is_atty == 1 ) { fprintf ( stderr , "    Last message repeated %d times\r" , count ) ; } return ; } if ( count > 0 ) { fprintf ( stderr , "    Last message repeated %d times\n" , count ) ; count = 0 ; } colored_fputs ( av_clip ( level >> 3 , 0 , 6 ) , line ) ; strcpy ( prev , line ) ; }##::##1##::##11058
static void do_audio_out ( AVFormatContext * s , AVOutputStream * ost , AVInputStream * ist , unsigned char * buf , int size ) { uint8_t * buftmp ; uint8_t audio_buf [ 2 * MAX_AUDIO_PACKET_SIZE ] ; uint8_t audio_out [ 4 * MAX_AUDIO_PACKET_SIZE ] ; int size_out , frame_bytes , ret ; AVCodecContext * enc ; enc = & ost -> st -> codec ; if ( ost -> audio_resample ) { buftmp = audio_buf ; size_out = audio_resample ( ost -> resample , ( short * ) buftmp , ( short * ) buf , size / ( ist -> st -> codec . channels * 2 ) ) ; size_out = size_out * enc -> channels * 2 ; } else { buftmp = buf ; size_out = size ; } if ( enc -> frame_size > 1 ) { fifo_write ( & ost -> fifo , buftmp , size_out , & ost -> fifo . wptr ) ; frame_bytes = enc -> frame_size * 2 * enc -> channels ; while ( fifo_read ( & ost -> fifo , audio_buf , frame_bytes , & ost -> fifo . rptr ) == 0 ) { ret = avcodec_encode_audio ( enc , audio_out , sizeof ( audio_out ) , ( short * ) audio_buf ) ; av_write_frame ( s , ost -> index , audio_out , ret ) ; } } else { switch ( enc -> codec -> id ) { case CODEC_ID_PCM_S16LE : case CODEC_ID_PCM_S16BE : case CODEC_ID_PCM_U16LE : case CODEC_ID_PCM_U16BE : break ; default : size_out = size_out >> 1 ; break ; } ret = avcodec_encode_audio ( enc , audio_out , size_out , ( short * ) buftmp ) ; av_write_frame ( s , ost -> index , audio_out , ret ) ; } }##::##1##::##9331
static void * handle_apdu_thread ( void * arg ) { EmulatedState * card = arg ; uint8_t recv_data [ APDU_BUF_SIZE ] ; int recv_len ; VReaderStatus reader_status ; EmulEvent * event ; while ( 1 ) { qemu_mutex_lock ( & card -> handle_apdu_mutex ) ; qemu_cond_wait ( & card -> handle_apdu_cond , & card -> handle_apdu_mutex ) ; qemu_mutex_unlock ( & card -> handle_apdu_mutex ) ; if ( card -> quit_apdu_thread ) { card -> quit_apdu_thread = 0 ; break ; } qemu_mutex_lock ( & card -> vreader_mutex ) ; while ( ! QSIMPLEQ_EMPTY ( & card -> guest_apdu_list ) ) { event = QSIMPLEQ_FIRST ( & card -> guest_apdu_list ) ; assert ( ( unsigned long ) event > 1000 ) ; QSIMPLEQ_REMOVE_HEAD ( & card -> guest_apdu_list , entry ) ; if ( event -> p . data . type != EMUL_GUEST_APDU ) { DPRINTF ( card , 1 , "unexpected message in handle_apdu_thread\n" ) ; g_free ( event ) ; continue ; } if ( card -> reader == NULL ) { DPRINTF ( card , 1 , "reader is NULL\n" ) ; g_free ( event ) ; continue ; } recv_len = sizeof ( recv_data ) ; reader_status = vreader_xfr_bytes ( card -> reader , event -> p . data . data , event -> p . data . len , recv_data , & recv_len ) ; DPRINTF ( card , 2 , "got back apdu of length %d\n" , recv_len ) ; if ( reader_status == VREADER_OK ) { emulated_push_response_apdu ( card , recv_data , recv_len ) ; } else { emulated_push_error ( card , reader_status ) ; } g_free ( event ) ; } qemu_mutex_unlock ( & card -> vreader_mutex ) ; } qemu_mutex_lock ( & card -> apdu_thread_quit_mutex ) ; qemu_cond_signal ( & card -> apdu_thread_quit_cond ) ; qemu_mutex_unlock ( & card -> apdu_thread_quit_mutex ) ; return NULL ; }##::##1##::##5565
static CURLState * curl_init_state ( BDRVCURLState * s ) { CURLState * state = NULL ; int i , j ; do { for ( i = 0 ; i < CURL_NUM_STATES ; i ++ ) { for ( j = 0 ; j < CURL_NUM_ACB ; j ++ ) if ( s -> states [ i ] . acb [ j ] ) { continue ; } if ( s -> states [ i ] . in_use ) { continue ; } state = & s -> states [ i ] ; state -> in_use = 1 ; break ; } if ( ! state ) { g_usleep ( 100 ) ; curl_multi_do ( s ) ; } } while ( ! state ) ; if ( state -> curl ) { goto has_curl ; } state -> curl = curl_easy_init ( ) ; if ( ! state -> curl ) { return NULL ; } curl_easy_setopt ( state -> curl , CURLOPT_URL , s -> url ) ; curl_easy_setopt ( state -> curl , CURLOPT_TIMEOUT , 5 ) ; curl_easy_setopt ( state -> curl , CURLOPT_WRITEFUNCTION , ( void * ) curl_read_cb ) ; curl_easy_setopt ( state -> curl , CURLOPT_WRITEDATA , ( void * ) state ) ; curl_easy_setopt ( state -> curl , CURLOPT_PRIVATE , ( void * ) state ) ; curl_easy_setopt ( state -> curl , CURLOPT_AUTOREFERER , 1 ) ; curl_easy_setopt ( state -> curl , CURLOPT_FOLLOWLOCATION , 1 ) ; curl_easy_setopt ( state -> curl , CURLOPT_NOSIGNAL , 1 ) ; curl_easy_setopt ( state -> curl , CURLOPT_ERRORBUFFER , state -> errmsg ) ; curl_easy_setopt ( state -> curl , CURLOPT_FAILONERROR , 1 ) ; curl_easy_setopt ( state -> curl , CURLOPT_PROTOCOLS , PROTOCOLS ) ; curl_easy_setopt ( state -> curl , CURLOPT_REDIR_PROTOCOLS , PROTOCOLS ) ; # ifdef DEBUG_VERBOSE curl_easy_setopt ( state -> curl , CURLOPT_VERBOSE , 1 ) ; has_curl : state -> s = s ; return state ; }##::##1##::##4143
static void dwt_decode97_float ( DWTContext * s , float * t ) { int lev ; int w = s -> linelen [ s -> ndeclevels - 1 ] [ 0 ] ; float * line = s -> f_linebuf ; float * data = t ; line += 5 ; for ( lev = 0 ; lev < s -> ndeclevels ; lev ++ ) { int lh = s -> linelen [ lev ] [ 0 ] , lv = s -> linelen [ lev ] [ 1 ] , mh = s -> mod [ lev ] [ 0 ] , mv = s -> mod [ lev ] [ 1 ] , lp ; float * l ; l = line + mh ; for ( lp = 0 ; lp < lv ; lp ++ ) { int i , j = 0 ; for ( i = mh ; i < lh ; i += 2 , j ++ ) { l [ i ] = data [ w * lp + j ] * F_LFTG_K ; } for ( i = 1 - mh ; i < lh ; i += 2 , j ++ ) { l [ i ] = data [ w * lp + j ] ; } sr_1d97_float ( line , mh , mh + lh ) ; for ( i = 0 ; i < lh ; i ++ ) { data [ w * lp + i ] = l [ i ] ; } } l = line + mv ; for ( lp = 0 ; lp < lh ; lp ++ ) { int i , j = 0 ; for ( i = mv ; i < lv ; i += 2 , j ++ ) { l [ i ] = data [ w * j + lp ] * F_LFTG_K ; } for ( i = 1 - mv ; i < lv ; i += 2 , j ++ ) { l [ i ] = data [ w * j + lp ] ; } sr_1d97_float ( line , mv , mv + lv ) ; for ( i = 0 ; i < lv ; i ++ ) { data [ w * i + lp ] = l [ i ] ; } } } }##::##1##::##8803
static int compand_delay ( AVFilterContext * ctx , AVFrame * frame ) { CompandContext * s = ctx -> priv ; AVFilterLink * inlink = ctx -> inputs [ 0 ] ; const int channels = inlink -> channels ; const int nb_samples = frame -> nb_samples ; int chan , i , av_uninit ( dindex ) , oindex , av_uninit ( count ) ; AVFrame * out_frame = NULL ; av_assert1 ( channels > 0 ) ; for ( chan = 0 ; chan < channels ; chan ++ ) { const double * src = ( double * ) frame -> extended_data [ chan ] ; double * dbuf = ( double * ) s -> delayptrs [ chan ] ; ChanParam * cp = & s -> channels [ chan ] ; double * dst ; count = s -> delay_count ; dindex = s -> delay_index ; for ( i = 0 , oindex = 0 ; i < nb_samples ; i ++ ) { const double in = src [ i ] ; update_volume ( cp , fabs ( in ) ) ; if ( count >= s -> delay_samples ) { if ( ! out_frame ) { out_frame = ff_get_audio_buffer ( inlink , nb_samples - i ) ; if ( ! out_frame ) { return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out_frame , frame ) ; out_frame -> pts = s -> pts ; s -> pts += av_rescale_q ( nb_samples - i , ( AVRational ) { 1 , inlink -> sample_rate } , inlink -> time_base ) ; } dst = ( double * ) out_frame -> extended_data [ chan ] ; dst [ oindex ++ ] = av_clipd ( dbuf [ dindex ] * get_volume ( s , cp -> volume ) , - 1 , 1 ) ; } else { count ++ ; } dbuf [ dindex ] = in ; dindex = MOD ( dindex + 1 , s -> delay_samples ) ; } } s -> delay_count = count ; s -> delay_index = dindex ; av_frame_free ( & frame ) ; return out_frame ? ff_filter_frame ( ctx -> outputs [ 0 ] , out_frame ) : 0 ; }##::##1##::##39
qemu_irq * mpic_init ( target_phys_addr_t base , int nb_cpus , qemu_irq * * irqs , qemu_irq irq_out ) { openpic_t * mpp ; int i ; struct { CPUReadMemoryFunc * const * read ; CPUWriteMemoryFunc * const * write ; target_phys_addr_t start_addr ; ram_addr_t size ; } const list [ ] = { { mpic_glb_read , mpic_glb_write , MPIC_GLB_REG_START , MPIC_GLB_REG_SIZE } , { mpic_tmr_read , mpic_tmr_write , MPIC_TMR_REG_START , MPIC_TMR_REG_SIZE } , { mpic_ext_read , mpic_ext_write , MPIC_EXT_REG_START , MPIC_EXT_REG_SIZE } , { mpic_int_read , mpic_int_write , MPIC_INT_REG_START , MPIC_INT_REG_SIZE } , { mpic_msg_read , mpic_msg_write , MPIC_MSG_REG_START , MPIC_MSG_REG_SIZE } , { mpic_msi_read , mpic_msi_write , MPIC_MSI_REG_START , MPIC_MSI_REG_SIZE } , { mpic_cpu_read , mpic_cpu_write , MPIC_CPU_REG_START , MPIC_CPU_REG_SIZE } , } ; if ( nb_cpus != 1 ) { return NULL ; } mpp = g_malloc0 ( sizeof ( openpic_t ) ) ; for ( i = 0 ; i < sizeof ( list ) / sizeof ( list [ 0 ] ) ; i ++ ) { int mem_index ; mem_index = cpu_register_io_memory ( list [ i ] . read , list [ i ] . write , mpp , DEVICE_BIG_ENDIAN ) ; if ( mem_index < 0 ) { goto free ; } cpu_register_physical_memory ( base + list [ i ] . start_addr , list [ i ] . size , mem_index ) ; } mpp -> nb_cpus = nb_cpus ; mpp -> max_irq = MPIC_MAX_IRQ ; mpp -> irq_ipi0 = MPIC_IPI_IRQ ; mpp -> irq_tim0 = MPIC_TMR_IRQ ; for ( i = 0 ; i < nb_cpus ; i ++ ) { mpp -> dst [ i ] . irqs = irqs [ i ] ; } mpp -> irq_out = irq_out ; mpp -> irq_raise = mpic_irq_raise ; mpp -> reset = mpic_reset ; register_savevm ( NULL , "mpic" , 0 , 2 , openpic_save , openpic_load , mpp ) ; qemu_register_reset ( mpic_reset , mpp ) ; return qemu_allocate_irqs ( openpic_set_irq , mpp , mpp -> max_irq ) ; free : g_free ( mpp ) ; return NULL ; }##::##1##::##5940
static int net_socket_mcast_create ( struct sockaddr_in * mcastaddr ) { struct ip_mreq imr ; int fd ; int val , ret ; if ( ! IN_MULTICAST ( ntohl ( mcastaddr -> sin_addr . s_addr ) ) ) { fprintf ( stderr , "qemu: error: specified mcastaddr \"%s\" (0x%08x) does not contain a multicast address\n" , inet_ntoa ( mcastaddr -> sin_addr ) , ( int ) ntohl ( mcastaddr -> sin_addr . s_addr ) ) ; return - 1 ; } fd = socket ( PF_INET , SOCK_DGRAM , 0 ) ; if ( fd < 0 ) { perror ( "socket(PF_INET, SOCK_DGRAM)" ) ; return - 1 ; } val = 1 ; ret = setsockopt ( fd , SOL_SOCKET , SO_REUSEADDR , ( const char * ) & val , sizeof ( val ) ) ; if ( ret < 0 ) { perror ( "setsockopt(SOL_SOCKET, SO_REUSEADDR)" ) ; goto fail ; } ret = bind ( fd , ( struct sockaddr * ) mcastaddr , sizeof ( * mcastaddr ) ) ; if ( ret < 0 ) { perror ( "bind" ) ; goto fail ; } imr . imr_multiaddr = mcastaddr -> sin_addr ; imr . imr_interface . s_addr = htonl ( INADDR_ANY ) ; ret = setsockopt ( fd , IPPROTO_IP , IP_ADD_MEMBERSHIP , ( const char * ) & imr , sizeof ( struct ip_mreq ) ) ; if ( ret < 0 ) { perror ( "setsockopt(IP_ADD_MEMBERSHIP)" ) ; goto fail ; } val = 1 ; ret = setsockopt ( fd , IPPROTO_IP , IP_MULTICAST_LOOP , ( const char * ) & val , sizeof ( val ) ) ; if ( ret < 0 ) { perror ( "setsockopt(SOL_IP, IP_MULTICAST_LOOP)" ) ; goto fail ; } socket_set_nonblock ( fd ) ; return fd ; fail : if ( fd >= 0 ) { closesocket ( fd ) ; } return - 1 ; }##::##1##::##5551
static int tee_write_header ( AVFormatContext * avf ) { TeeContext * tee = avf -> priv_data ; unsigned nb_slaves = 0 , i ; const char * filename = avf -> filename ; char * slaves [ MAX_SLAVES ] ; int ret ; while ( * filename ) { if ( nb_slaves == MAX_SLAVES ) { av_log ( avf , AV_LOG_ERROR , "Maximum %d slave muxers reached.\n" , MAX_SLAVES ) ; ret = AVERROR_PATCHWELCOME ; goto fail ; } if ( ! ( slaves [ nb_slaves ++ ] = av_get_token ( & filename , slave_delim ) ) ) { ret = AVERROR ( ENOMEM ) ; goto fail ; } if ( strspn ( filename , slave_delim ) ) { filename ++ ; } } for ( i = 0 ; i < nb_slaves ; i ++ ) { if ( ( ret = open_slave ( avf , slaves [ i ] , & tee -> slaves [ i ] ) ) < 0 ) { goto fail ; } log_slave ( & tee -> slaves [ i ] , avf , AV_LOG_VERBOSE ) ; av_freep ( & slaves [ i ] ) ; } tee -> nb_slaves = nb_slaves ; for ( i = 0 ; i < avf -> nb_streams ; i ++ ) { int j , mapped = 0 ; for ( j = 0 ; j < tee -> nb_slaves ; j ++ ) { mapped += tee -> slaves [ j ] . stream_map [ i ] >= 0 ; } if ( ! mapped ) av_log ( avf , AV_LOG_WARNING , "Input stream #%d is not mapped " "to any slave.\n" , i ) ; } return 0 ; fail : for ( i = 0 ; i < nb_slaves ; i ++ ) { av_freep ( & slaves [ i ] ) ; } close_slaves ( avf ) ; return ret ; }##::##1##::##1963
void xen_invalidate_map_cache_entry ( uint8_t * buffer ) { MapCacheEntry * entry = NULL , * pentry = NULL ; MapCacheRev * reventry ; target_phys_addr_t paddr_index ; target_phys_addr_t size ; int found = 0 ; if ( mapcache -> last_address_vaddr == buffer ) { mapcache -> last_address_index = - 1 ; } QTAILQ_FOREACH ( reventry , & mapcache -> locked_entries , next ) { if ( reventry -> vaddr_req == buffer ) { paddr_index = reventry -> paddr_index ; size = reventry -> size ; found = 1 ; break ; } } if ( ! found ) { DPRINTF ( "%s, could not find %p\n" , __func__ , buffer ) ; QTAILQ_FOREACH ( reventry , & mapcache -> locked_entries , next ) { DPRINTF ( "   " TARGET_FMT_plx " -> %p is present\n" , reventry -> paddr_index , reventry -> vaddr_req ) ; } return ; } QTAILQ_REMOVE ( & mapcache -> locked_entries , reventry , next ) ; g_free ( reventry ) ; entry = & mapcache -> entry [ paddr_index % mapcache -> nr_buckets ] ; while ( entry && ( entry -> paddr_index != paddr_index || entry -> size != size ) ) { pentry = entry ; entry = entry -> next ; } if ( ! entry ) { DPRINTF ( "Trying to unmap address %p that is not in the mapcache!\n" , buffer ) ; return ; } entry -> lock -- ; if ( entry -> lock > 0 || pentry == NULL ) { return ; } pentry -> next = entry -> next ; if ( munmap ( entry -> vaddr_base , entry -> size ) != 0 ) { perror ( "unmap fails" ) ; exit ( - 1 ) ; } g_free ( entry -> valid_mapping ) ; g_free ( entry ) ; }##::##1##::##11345
static int yop_read_packet ( AVFormatContext * s , AVPacket * pkt ) { YopDecContext * yop = s -> priv_data ; AVIOContext * pb = s -> pb ; int ret ; int actual_video_data_size = yop -> frame_size - yop -> audio_block_length - yop -> palette_size ; yop -> video_packet . stream_index = 1 ; if ( yop -> video_packet . data ) { * pkt = yop -> video_packet ; yop -> video_packet . data = NULL ; yop -> video_packet . size = 0 ; pkt -> data [ 0 ] = yop -> odd_frame ; pkt -> flags |= AV_PKT_FLAG_KEY ; yop -> odd_frame ^= 1 ; return pkt -> size ; } ret = av_new_packet ( & yop -> video_packet , yop -> frame_size - yop -> audio_block_length ) ; if ( ret < 0 ) { return ret ; } yop -> video_packet . pos = avio_tell ( pb ) ; ret = avio_read ( pb , yop -> video_packet . data , yop -> palette_size ) ; if ( ret < 0 ) { goto err_out ; } else if ( ret < yop -> palette_size ) { ret = AVERROR_EOF ; goto err_out ; } ret = av_get_packet ( pb , pkt , 920 ) ; if ( ret < 0 ) { goto err_out ; } pkt -> pos = yop -> video_packet . pos ; avio_skip ( pb , yop -> audio_block_length - ret ) ; ret = avio_read ( pb , yop -> video_packet . data + yop -> palette_size , actual_video_data_size ) ; if ( ret < 0 ) { goto err_out ; } else if ( ret < actual_video_data_size ) { av_shrink_packet ( & yop -> video_packet , yop -> palette_size + ret ) ; } return yop -> audio_block_length ; err_out : av_free_packet ( & yop -> video_packet ) ; return ret ; }##::##1##::##305
void qmp_dump_guest_memory ( bool paging , const char * file , bool has_begin , int64_t begin , bool has_length , int64_t length , Error * * errp ) { const char * p ; int fd = - 1 ; DumpState * s ; int ret ; if ( has_begin && ! has_length ) { error_set ( errp , QERR_MISSING_PARAMETER , "length" ) ; return ; } if ( ! has_begin && has_length ) { error_set ( errp , QERR_MISSING_PARAMETER , "begin" ) ; return ; } # if ! defined ( WIN32 ) if ( strstart ( file , "fd:" , & p ) ) { fd = monitor_get_fd ( cur_mon , p , errp ) ; if ( fd == - 1 ) { return ; } } # endif if ( strstart ( file , "file:" , & p ) ) { fd = qemu_open ( p , O_WRONLY | O_CREAT | O_TRUNC | O_BINARY , S_IRUSR ) ; if ( fd < 0 ) { error_setg_file_open ( errp , errno , p ) ; return ; } } if ( fd == - 1 ) { error_set ( errp , QERR_INVALID_PARAMETER , "protocol" ) ; return ; } s = g_malloc0 ( sizeof ( DumpState ) ) ; ret = dump_init ( s , fd , paging , has_begin , begin , length , errp ) ; if ( ret < 0 ) { g_free ( s ) ; return ; } if ( create_vmcore ( s ) < 0 && ! error_is_set ( s -> errp ) ) { error_set ( errp , QERR_IO_ERROR ) ; } g_free ( s ) ; }##::##1##::##9157
static int check_refcounts_l2 ( BlockDriverState * bs , uint16_t * refcount_table , int refcount_table_size , int64_t l2_offset , int check_copied ) { BDRVQcowState * s = bs -> opaque ; uint64_t * l2_table , offset ; int i , l2_size , nb_csectors , refcount ; int errors = 0 ; l2_size = s -> l2_size * sizeof ( uint64_t ) ; l2_table = qemu_malloc ( l2_size ) ; if ( bdrv_pread ( s -> hd , l2_offset , l2_table , l2_size ) != l2_size ) { goto fail ; } for ( i = 0 ; i < s -> l2_size ; i ++ ) { offset = be64_to_cpu ( l2_table [ i ] ) ; if ( offset != 0 ) { if ( offset & QCOW_OFLAG_COMPRESSED ) { if ( offset & QCOW_OFLAG_COPIED ) { fprintf ( stderr , "ERROR: cluster %" PRId64 ": " "copied flag must never be set for compressed " "clusters\n" , offset >> s -> cluster_bits ) ; offset &= ~ QCOW_OFLAG_COPIED ; nb_csectors = ( ( offset >> s -> csize_shift ) & s -> csize_mask ) + 1 ; offset &= s -> cluster_offset_mask ; errors += inc_refcounts ( bs , refcount_table , refcount_table_size , offset & ~ 511 , nb_csectors * 512 ) ; } else { if ( check_copied ) { uint64_t entry = offset ; offset &= ~ QCOW_OFLAG_COPIED ; refcount = get_refcount ( bs , offset >> s -> cluster_bits ) ; if ( ( refcount == 1 ) != ( ( entry & QCOW_OFLAG_COPIED ) != 0 ) ) { fprintf ( stderr , "ERROR OFLAG_COPIED: offset=%" PRIx64 " refcount=%d\n" , entry , refcount ) ; offset &= ~ QCOW_OFLAG_COPIED ; errors += inc_refcounts ( bs , refcount_table , refcount_table_size , offset , s -> cluster_size ) ; qemu_free ( l2_table ) ; return errors ; fail : fprintf ( stderr , "ERROR: I/O error in check_refcounts_l1\n" ) ; qemu_free ( l2_table ) ; return - EIO ;##::##1##::##6965
static av_always_inline void autocorrelate ( const int x [ 40 ] [ 2 ] , SoftFloat phi [ 3 ] [ 2 ] [ 2 ] , int lag ) { int i ; int64_t real_sum , imag_sum ; int64_t accu_re = 0 , accu_im = 0 ; if ( lag ) { for ( i = 1 ; i < 38 ; i ++ ) { accu_re += ( int64_t ) x [ i ] [ 0 ] * x [ i + lag ] [ 0 ] ; accu_re += ( int64_t ) x [ i ] [ 1 ] * x [ i + lag ] [ 1 ] ; accu_im += ( int64_t ) x [ i ] [ 0 ] * x [ i + lag ] [ 1 ] ; accu_im -= ( int64_t ) x [ i ] [ 1 ] * x [ i + lag ] [ 0 ] ; } real_sum = accu_re ; imag_sum = accu_im ; accu_re += ( int64_t ) x [ 0 ] [ 0 ] * x [ lag ] [ 0 ] ; accu_re += ( int64_t ) x [ 0 ] [ 1 ] * x [ lag ] [ 1 ] ; accu_im += ( int64_t ) x [ 0 ] [ 0 ] * x [ lag ] [ 1 ] ; accu_im -= ( int64_t ) x [ 0 ] [ 1 ] * x [ lag ] [ 0 ] ; phi [ 2 - lag ] [ 1 ] [ 0 ] = autocorr_calc ( accu_re ) ; phi [ 2 - lag ] [ 1 ] [ 1 ] = autocorr_calc ( accu_im ) ; if ( lag == 1 ) { accu_re = real_sum ; accu_im = imag_sum ; accu_re += ( int64_t ) x [ 38 ] [ 0 ] * x [ 39 ] [ 0 ] ; accu_re += ( int64_t ) x [ 38 ] [ 1 ] * x [ 39 ] [ 1 ] ; accu_im += ( int64_t ) x [ 38 ] [ 0 ] * x [ 39 ] [ 1 ] ; accu_im -= ( int64_t ) x [ 38 ] [ 1 ] * x [ 39 ] [ 0 ] ; phi [ 0 ] [ 0 ] [ 0 ] = autocorr_calc ( accu_re ) ; phi [ 0 ] [ 0 ] [ 1 ] = autocorr_calc ( accu_im ) ; } } else { for ( i = 1 ; i < 38 ; i ++ ) { accu_re += ( int64_t ) x [ i ] [ 0 ] * x [ i ] [ 0 ] ; accu_re += ( int64_t ) x [ i ] [ 1 ] * x [ i ] [ 1 ] ; } real_sum = accu_re ; accu_re += ( int64_t ) x [ 0 ] [ 0 ] * x [ 0 ] [ 0 ] ; accu_re += ( int64_t ) x [ 0 ] [ 1 ] * x [ 0 ] [ 1 ] ; phi [ 2 ] [ 1 ] [ 0 ] = autocorr_calc ( accu_re ) ; accu_re = real_sum ; accu_re += ( int64_t ) x [ 38 ] [ 0 ] * x [ 38 ] [ 0 ] ; accu_re += ( int64_t ) x [ 38 ] [ 1 ] * x [ 38 ] [ 1 ] ; phi [ 1 ] [ 0 ] [ 0 ] = autocorr_calc ( accu_re ) ; } }##::##1##::##6334
print_operand_value ( char * buf , size_t bufsize , int hex , bfd_vma disp ) { if ( address_mode == mode_64bit ) { if ( hex ) { char tmp [ 30 ] ; int i ; buf [ 0 ] = '0' ; buf [ 1 ] = 'x' ; snprintf_vma ( tmp , sizeof ( tmp ) , disp ) ; for ( i = 0 ; tmp [ i ] == '0' && tmp [ i + 1 ] ; i ++ ) ; pstrcpy ( buf + 2 , bufsize - 2 , tmp + i ) ; } else { bfd_signed_vma v = disp ; char tmp [ 30 ] ; int i ; if ( v < 0 ) { * ( buf ++ ) = '-' ; v = - disp ; if ( v < 0 ) { pstrcpy ( buf , bufsize , "9223372036854775808" ) ; return ; } } if ( ! v ) { pstrcpy ( buf , bufsize , "0" ) ; return ; } i = 0 ; tmp [ 29 ] = 0 ; while ( v ) { tmp [ 28 - i ] = ( v % 10 ) + '0' ; v /= 10 ; i ++ ; } pstrcpy ( buf , bufsize , tmp + 29 - i ) ; } } else { if ( hex ) { snprintf ( buf , bufsize , "0x%x" , ( unsigned int ) disp ) ; } else { snprintf ( buf , bufsize , "%d" , ( int ) disp ) ; } } }##::##1##::##2035
static void decode_array_0000 ( APEContext * ctx , GetBitContext * gb , int32_t * out , APERice * rice , int blockstodecode ) { int i ; int ksummax , ksummin ; rice -> ksum = 0 ; for ( i = 0 ; i < 5 ; i ++ ) { out [ i ] = get_rice_ook ( & ctx -> gb , 10 ) ; rice -> ksum += out [ i ] ; } rice -> k = av_log2 ( rice -> ksum / 10 ) + 1 ; for ( ; i < 64 ; i ++ ) { out [ i ] = get_rice_ook ( & ctx -> gb , rice -> k ) ; rice -> ksum += out [ i ] ; rice -> k = av_log2 ( rice -> ksum / ( ( i + 1 ) * 2 ) ) + 1 ; } ksummax = 1 << rice -> k + 7 ; ksummin = rice -> k ? ( 1 << rice -> k + 6 ) : 0 ; for ( ; i < blockstodecode ; i ++ ) { out [ i ] = get_rice_ook ( & ctx -> gb , rice -> k ) ; rice -> ksum += out [ i ] - out [ i - 64 ] ; while ( rice -> ksum < ksummin ) { rice -> k -- ; ksummin = rice -> k ? ksummin >> 1 : 0 ; ksummax >>= 1 ; } while ( rice -> ksum >= ksummax ) { rice -> k ++ ; if ( rice -> k > 24 ) { ksummax <<= 1 ; } ksummin = ksummin ? ksummin << 1 : 128 ; } } for ( i = 0 ; i < blockstodecode ; i ++ ) { if ( out [ i ] & 1 ) { out [ i ] = ( out [ i ] >> 1 ) + 1 ; } else { out [ i ] = - ( out [ i ] >> 1 ) ; } } }##::##1##::##1768
static uint64_t alloc_cluster_offset ( BlockDriverState * bs , uint64_t offset , int n_start , int n_end , int * num , QCowL2Meta * m ) { BDRVQcowState * s = bs -> opaque ; int l2_index , ret ; uint64_t l2_offset , * l2_table , cluster_offset ; int nb_clusters , i = 0 ; ret = get_cluster_table ( bs , offset , & l2_table , & l2_offset , & l2_index ) ; if ( ret == 0 ) { return 0 ; } nb_clusters = size_to_clusters ( s , n_end << 9 ) ; nb_clusters = MIN ( nb_clusters , s -> l2_size - l2_index ) ; cluster_offset = be64_to_cpu ( l2_table [ l2_index ] ) ; if ( cluster_offset & QCOW_OFLAG_COPIED ) { nb_clusters = count_contiguous_clusters ( nb_clusters , s -> cluster_size , & l2_table [ l2_index ] , 0 ) ; cluster_offset &= ~ QCOW_OFLAG_COPIED ; m -> nb_clusters = 0 ; goto out ; } if ( cluster_offset & QCOW_OFLAG_COMPRESSED ) { nb_clusters = 1 ; } while ( i < nb_clusters ) { i += count_contiguous_clusters ( nb_clusters - i , s -> cluster_size , & l2_table [ l2_index + i ] , 0 ) ; if ( be64_to_cpu ( l2_table [ l2_index + i ] ) ) { break ; } i += count_contiguous_free_clusters ( nb_clusters - i , & l2_table [ l2_index + i ] ) ; cluster_offset = be64_to_cpu ( l2_table [ l2_index + i ] ) ; if ( ( cluster_offset & QCOW_OFLAG_COPIED ) || ( cluster_offset & QCOW_OFLAG_COMPRESSED ) ) { break ; } } nb_clusters = i ; cluster_offset = alloc_clusters ( bs , nb_clusters * s -> cluster_size ) ; m -> offset = offset ; m -> n_start = n_start ; m -> nb_clusters = nb_clusters ; out : m -> nb_available = MIN ( nb_clusters << ( s -> cluster_bits - 9 ) , n_end ) ; * num = m -> nb_available - n_start ; return cluster_offset ; }##::##1##::##3336
static void virtser_port_device_realize ( DeviceState * dev , Error * * errp ) { VirtIOSerialPort * port = VIRTIO_SERIAL_PORT ( dev ) ; VirtIOSerialPortClass * vsc = VIRTIO_SERIAL_PORT_GET_CLASS ( port ) ; VirtIOSerialBus * bus = VIRTIO_SERIAL_BUS ( qdev_get_parent_bus ( dev ) ) ; VirtIODevice * vdev = VIRTIO_DEVICE ( bus -> vser ) ; int max_nr_ports ; bool plugging_port0 ; Error * err = NULL ; port -> vser = bus -> vser ; port -> bh = qemu_bh_new ( flush_queued_data_bh , port ) ; assert ( vsc -> have_data ) ; plugging_port0 = vsc -> is_console && ! find_port_by_id ( port -> vser , 0 ) ; if ( find_port_by_id ( port -> vser , port -> id ) ) { error_setg ( errp , "virtio-serial-bus: A port already exists at id %u" , port -> id ) ; return ; } if ( find_port_by_name ( port -> name ) ) { error_setg ( errp , "virtio-serial-bus: A port already exists by name %s" , port -> name ) ; return ; } if ( port -> id == VIRTIO_CONSOLE_BAD_ID ) { if ( plugging_port0 ) { port -> id = 0 ; } else { port -> id = find_free_port_id ( port -> vser ) ; if ( port -> id == VIRTIO_CONSOLE_BAD_ID ) { error_setg ( errp , "virtio-serial-bus: Maximum port limit for " "this device reached" ) ; return ; } } } max_nr_ports = virtio_tswap32 ( vdev , port -> vser -> config . max_nr_ports ) ; if ( port -> id >= max_nr_ports ) { error_setg ( errp , "virtio-serial-bus: Out-of-range port id specified, " "max. allowed: %u" , max_nr_ports - 1 ) ; return ; } vsc -> realize ( dev , & err ) ; if ( err != NULL ) { error_propagate ( errp , err ) ; return ; } port -> elem . out_num = 0 ; }##::##1##::##7915
static void type_initialize ( TypeImpl * ti ) { TypeImpl * parent ; if ( ti -> class ) { return ; } ti -> class_size = type_class_get_size ( ti ) ; ti -> instance_size = type_object_get_size ( ti ) ; ti -> class = g_malloc0 ( ti -> class_size ) ; parent = type_get_parent ( ti ) ; if ( parent ) { type_initialize ( parent ) ; GSList * e ; int i ; g_assert ( parent -> class_size <= ti -> class_size ) ; memcpy ( ti -> class , parent -> class , parent -> class_size ) ; ti -> class -> interfaces = NULL ; for ( e = parent -> class -> interfaces ; e ; e = e -> next ) { ObjectClass * iface = e -> data ; type_initialize_interface ( ti , object_class_get_name ( iface ) ) ; } for ( i = 0 ; i < ti -> num_interfaces ; i ++ ) { TypeImpl * t = type_get_by_name ( ti -> interfaces [ i ] . typename ) ; for ( e = ti -> class -> interfaces ; e ; e = e -> next ) { TypeImpl * target_type = OBJECT_CLASS ( e -> data ) -> type ; if ( type_is_ancestor ( target_type , t ) ) { break ; } } if ( e ) { continue ; } type_initialize_interface ( ti , ti -> interfaces [ i ] . typename ) ; } } ti -> class -> type = ti ; while ( parent ) { if ( parent -> class_base_init ) { parent -> class_base_init ( ti -> class , ti -> class_data ) ; } parent = type_get_parent ( parent ) ; } if ( ti -> class_init ) { ti -> class_init ( ti -> class , ti -> class_data ) ; } }##::##1##::##7847
static int encode_hq_slice ( AVCodecContext * avctx , void * arg ) { SliceArgs * slice_dat = arg ; VC2EncContext * s = slice_dat -> ctx ; PutBitContext * pb = & slice_dat -> pb ; const int slice_x = slice_dat -> x ; const int slice_y = slice_dat -> y ; const int quant_idx = slice_dat -> quant_idx ; const int slice_bytes_max = slice_dat -> bytes ; uint8_t quants [ MAX_DWT_LEVELS ] [ 4 ] ; int p , level , orientation ; memset ( put_bits_ptr ( pb ) , 0 , s -> prefix_bytes ) ; skip_put_bytes ( pb , s -> prefix_bytes ) ; put_bits ( pb , 8 , quant_idx ) ; for ( level = 0 ; level < s -> wavelet_depth ; level ++ ) for ( orientation = ! ! level ; orientation < 4 ; orientation ++ ) { quants [ level ] [ orientation ] = FFMAX ( quant_idx - s -> quant [ level ] [ orientation ] , 0 ) ; } for ( p = 0 ; p < 3 ; p ++ ) { int bytes_start , bytes_len , pad_s , pad_c ; bytes_start = put_bits_count ( pb ) >> 3 ; put_bits ( pb , 8 , 0 ) ; for ( level = 0 ; level < s -> wavelet_depth ; level ++ ) { for ( orientation = ! ! level ; orientation < 4 ; orientation ++ ) { encode_subband ( s , pb , slice_x , slice_y , & s -> plane [ p ] . band [ level ] [ orientation ] , quants [ level ] [ orientation ] ) ; } } avpriv_align_put_bits ( pb ) ; bytes_len = ( put_bits_count ( pb ) >> 3 ) - bytes_start - 1 ; if ( p == 2 ) { int len_diff = slice_bytes_max - ( put_bits_count ( pb ) >> 3 ) ; pad_s = FFALIGN ( ( bytes_len + len_diff ) , s -> size_scaler ) / s -> size_scaler ; pad_c = ( pad_s * s -> size_scaler ) - bytes_len ; } else { pad_s = FFALIGN ( bytes_len , s -> size_scaler ) / s -> size_scaler ; pad_c = ( pad_s * s -> size_scaler ) - bytes_len ; } pb -> buf [ bytes_start ] = pad_s ; flush_put_bits ( pb ) ; skip_put_bytes ( pb , pad_c ) ; } return 0 ; }##::##1##::##9634
static void old_pc_system_rom_init ( MemoryRegion * rom_memory , bool isapc_ram_fw ) { char * filename ; MemoryRegion * bios , * isa_bios ; int bios_size , isa_bios_size ; int ret ; if ( bios_name == NULL ) { bios_name = BIOS_FILENAME ; } filename = qemu_find_file ( QEMU_FILE_TYPE_BIOS , bios_name ) ; if ( filename ) { bios_size = get_image_size ( filename ) ; } else { bios_size = - 1 ; } if ( bios_size <= 0 || ( bios_size % 65536 ) != 0 ) { goto bios_error ; } bios = g_malloc ( sizeof ( * bios ) ) ; memory_region_init_ram ( bios , NULL , "pc.bios" , bios_size , & error_abort ) ; vmstate_register_ram_global ( bios ) ; if ( ! isapc_ram_fw ) { memory_region_set_readonly ( bios , true ) ; } ret = rom_add_file_fixed ( bios_name , ( uint32_t ) ( - bios_size ) , - 1 ) ; if ( ret != 0 ) { bios_error : fprintf ( stderr , "qemu: could not load PC BIOS '%s'\n" , bios_name ) ; exit ( 1 ) ; } g_free ( filename ) ; isa_bios_size = bios_size ; if ( isa_bios_size > ( 128 * 1024 ) ) { isa_bios_size = 128 * 1024 ; } isa_bios = g_malloc ( sizeof ( * isa_bios ) ) ; memory_region_init_alias ( isa_bios , NULL , "isa-bios" , bios , bios_size - isa_bios_size , isa_bios_size ) ; memory_region_add_subregion_overlap ( rom_memory , 0x100000 - isa_bios_size , isa_bios , 1 ) ; if ( ! isapc_ram_fw ) { memory_region_set_readonly ( isa_bios , true ) ; } memory_region_add_subregion ( rom_memory , ( uint32_t ) ( - bios_size ) , bios ) ; }##::##1##::##4352
static void vfio_pci_load_rom ( VFIODevice * vdev ) { struct vfio_region_info reg_info = { . argsz = sizeof ( reg_info ) , . index = VFIO_PCI_ROM_REGION_INDEX } ; uint64_t size ; off_t off = 0 ; size_t bytes ; if ( ioctl ( vdev -> fd , VFIO_DEVICE_GET_REGION_INFO , & reg_info ) ) { error_report ( "vfio: Error getting ROM info: %m" ) ; return ; } DPRINTF ( "Device %04x:%02x:%02x.%x ROM:\n" , vdev -> host . domain , vdev -> host . bus , vdev -> host . slot , vdev -> host . function ) ; DPRINTF ( "  size: 0x%lx, offset: 0x%lx, flags: 0x%lx\n" , ( unsigned long ) reg_info . size , ( unsigned long ) reg_info . offset , ( unsigned long ) reg_info . flags ) ; vdev -> rom_size = size = reg_info . size ; vdev -> rom_offset = reg_info . offset ; if ( ! vdev -> rom_size ) { error_report ( "vfio-pci: Cannot read device rom at " "%04x:%02x:%02x.%x\n" , vdev -> host . domain , vdev -> host . bus , vdev -> host . slot , vdev -> host . function ) ; error_printf ( "Device option ROM contents are probably invalid " "(check dmesg).\nSkip option ROM probe with rombar=0, " "or load from file with romfile=\n" ) ; return ; } vdev -> rom = g_malloc ( size ) ; memset ( vdev -> rom , 0xff , size ) ; while ( size ) { bytes = pread ( vdev -> fd , vdev -> rom + off , size , vdev -> rom_offset + off ) ; if ( bytes == 0 ) { break ; } else if ( bytes > 0 ) { off += bytes ; size -= bytes ; } else { if ( errno == EINTR || errno == EAGAIN ) { continue ; } error_report ( "vfio: Error reading device ROM: %m" ) ; break ; } } }##::##1##::##3639
static av_cold int iss_read_header ( AVFormatContext * s ) { IssDemuxContext * iss = s -> priv_data ; AVIOContext * pb = s -> pb ; AVStream * st ; char token [ MAX_TOKEN_SIZE ] ; int stereo , rate_divisor ; get_token ( pb , token , sizeof ( token ) ) ; get_token ( pb , token , sizeof ( token ) ) ; sscanf ( token , "%d" , & iss -> packet_size ) ; get_token ( pb , token , sizeof ( token ) ) ; get_token ( pb , token , sizeof ( token ) ) ; get_token ( pb , token , sizeof ( token ) ) ; sscanf ( token , "%d" , & stereo ) ; get_token ( pb , token , sizeof ( token ) ) ; get_token ( pb , token , sizeof ( token ) ) ; sscanf ( token , "%d" , & rate_divisor ) ; get_token ( pb , token , sizeof ( token ) ) ; get_token ( pb , token , sizeof ( token ) ) ; get_token ( pb , token , sizeof ( token ) ) ; if ( iss -> packet_size <= 0 ) { av_log ( s , AV_LOG_ERROR , "packet_size %d is invalid\n" , iss -> packet_size ) ; return AVERROR_INVALIDDATA ; } iss -> sample_start_pos = avio_tell ( pb ) ; st = avformat_new_stream ( s , NULL ) ; if ( ! st ) { return AVERROR ( ENOMEM ) ; } st -> codec -> codec_type = AVMEDIA_TYPE_AUDIO ; st -> codec -> codec_id = AV_CODEC_ID_ADPCM_IMA_ISS ; if ( stereo ) { st -> codec -> channels = 2 ; st -> codec -> channel_layout = AV_CH_LAYOUT_STEREO ; } else { st -> codec -> channels = 1 ; st -> codec -> channel_layout = AV_CH_LAYOUT_MONO ; } st -> codec -> sample_rate = 44100 ; if ( rate_divisor > 0 ) { st -> codec -> sample_rate /= rate_divisor ; } st -> codec -> bits_per_coded_sample = 4 ; st -> codec -> bit_rate = st -> codec -> channels * st -> codec -> sample_rate * st -> codec -> bits_per_coded_sample ; st -> codec -> block_align = iss -> packet_size ; avpriv_set_pts_info ( st , 32 , 1 , st -> codec -> sample_rate ) ; return 0 ; }##::##1##::##10996
ram_addr_t qemu_ram_alloc_from_ptr ( ram_addr_t size , void * host , MemoryRegion * mr ) { RAMBlock * new_block ; size = TARGET_PAGE_ALIGN ( size ) ; new_block = g_malloc0 ( sizeof ( * new_block ) ) ; new_block -> mr = mr ; new_block -> offset = find_ram_offset ( size ) ; if ( host ) { new_block -> host = host ; new_block -> flags |= RAM_PREALLOC_MASK ; } else { if ( mem_path ) { # if defined ( __linux__ ) && ! defined ( TARGET_S390X ) new_block -> host = file_ram_alloc ( new_block , size , mem_path ) ; if ( ! new_block -> host ) { new_block -> host = qemu_vmalloc ( size ) ; qemu_madvise ( new_block -> host , size , QEMU_MADV_MERGEABLE ) ; } # else fprintf ( stderr , "-mem-path option unsupported\n" ) ; exit ( 1 ) ; # endif } else { if ( xen_enabled ( ) ) { xen_ram_alloc ( new_block -> offset , size , mr ) ; } else if ( kvm_enabled ( ) ) { new_block -> host = kvm_vmalloc ( size ) ; } else { new_block -> host = qemu_vmalloc ( size ) ; } qemu_madvise ( new_block -> host , size , QEMU_MADV_MERGEABLE ) ; } } new_block -> length = size ; QLIST_INSERT_HEAD ( & ram_list . blocks , new_block , next ) ; ram_list . phys_dirty = g_realloc ( ram_list . phys_dirty , last_ram_offset ( ) >> TARGET_PAGE_BITS ) ; cpu_physical_memory_set_dirty_range ( new_block -> offset , size , 0xff ) ; if ( kvm_enabled ( ) ) { kvm_setup_guest_memory ( new_block -> host , size ) ; } return new_block -> offset ; }##::##1##::##581
static void scsi_write_data ( SCSIRequest * req ) { SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; uint32_t n ; assert ( r -> req . aiocb == NULL ) ; scsi_req_ref ( & r -> req ) ; if ( r -> req . cmd . mode != SCSI_XFER_TO_DEV ) { DPRINTF ( "Data transfer direction invalid\n" ) ; scsi_write_complete ( r , - EINVAL ) ; return ; } if ( ! r -> req . sg && ! r -> qiov . size ) { r -> started = true ; scsi_write_complete ( r , 0 ) ; return ; } if ( s -> tray_open ) { scsi_write_complete ( r , - ENOMEDIUM ) ; return ; } if ( r -> req . cmd . buf [ 0 ] == VERIFY_10 || r -> req . cmd . buf [ 0 ] == VERIFY_12 || r -> req . cmd . buf [ 0 ] == VERIFY_16 ) { if ( r -> req . sg ) { scsi_dma_complete ( r , 0 ) ; } else { scsi_write_complete ( r , 0 ) ; } return ; } if ( r -> req . sg ) { dma_acct_start ( s -> qdev . conf . bs , & r -> acct , r -> req . sg , BDRV_ACCT_WRITE ) ; r -> req . resid -= r -> req . sg -> size ; r -> req . aiocb = dma_bdrv_write ( s -> qdev . conf . bs , r -> req . sg , r -> sector , scsi_dma_complete , r ) ; } else { n = r -> qiov . size / 512 ; bdrv_acct_start ( s -> qdev . conf . bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_WRITE ) ; r -> req . aiocb = bdrv_aio_writev ( s -> qdev . conf . bs , r -> sector , & r -> qiov , n , scsi_write_complete , r ) ; } }##::##1##::##9532
static av_always_inline void mc_chroma_dir ( VP9Context * s , vp9_mc_func ( * mc ) [ 2 ] , uint8_t * dst_u , uint8_t * dst_v , ptrdiff_t dst_stride , const uint8_t * ref_u , ptrdiff_t src_stride_u , const uint8_t * ref_v , ptrdiff_t src_stride_v , ThreadFrame * ref_frame , ptrdiff_t y , ptrdiff_t x , const VP56mv * mv , int bw , int bh , int w , int h ) { int mx = mv -> x , my = mv -> y ; int th ; y += my >> 4 ; x += mx >> 4 ; ref_u += y * src_stride_u + x ; ref_v += y * src_stride_v + x ; mx &= 15 ; my &= 15 ; th = ( y + bh + 4 * ! ! my + 7 ) >> 5 ; ff_thread_await_progress ( ref_frame , FFMAX ( th , 0 ) , 0 ) ; if ( x < ! ! mx * 3 || y < ! ! my * 3 || x + ! ! mx * 4 > w - bw || y + ! ! my * 4 > h - bh ) { s -> vdsp . emulated_edge_mc ( s -> edge_emu_buffer , ref_u - ! ! my * 3 * src_stride_u - ! ! mx * 3 , 80 , src_stride_u , bw + ! ! mx * 7 , bh + ! ! my * 7 , x - ! ! mx * 3 , y - ! ! my * 3 , w , h ) ; ref_u = s -> edge_emu_buffer + ! ! my * 3 * 80 + ! ! mx * 3 ; mc [ ! ! mx ] [ ! ! my ] ( dst_u , dst_stride , ref_u , 80 , bh , mx , my ) ; s -> vdsp . emulated_edge_mc ( s -> edge_emu_buffer , ref_v - ! ! my * 3 * src_stride_v - ! ! mx * 3 , 80 , src_stride_v , bw + ! ! mx * 7 , bh + ! ! my * 7 , x - ! ! mx * 3 , y - ! ! my * 3 , w , h ) ; ref_v = s -> edge_emu_buffer + ! ! my * 3 * 80 + ! ! mx * 3 ; mc [ ! ! mx ] [ ! ! my ] ( dst_v , dst_stride , ref_v , 80 , bh , mx , my ) ; } else { mc [ ! ! mx ] [ ! ! my ] ( dst_u , dst_stride , ref_u , src_stride_u , bh , mx , my ) ; mc [ ! ! mx ] [ ! ! my ] ( dst_v , dst_stride , ref_v , src_stride_v , bh , mx , my ) ; } }##::##1##::##5072
static void add_ptimer_tests ( uint8_t policy ) { uint8_t * ppolicy = g_malloc ( 1 ) ; char * policy_name = g_malloc0 ( 256 ) ; * ppolicy = policy ; if ( policy == PTIMER_POLICY_DEFAULT ) { g_sprintf ( policy_name , "default" ) ; } if ( policy & PTIMER_POLICY_WRAP_AFTER_ONE_PERIOD ) { g_strlcat ( policy_name , "wrap_after_one_period," , 256 ) ; } if ( policy & PTIMER_POLICY_CONTINUOUS_TRIGGER ) { g_strlcat ( policy_name , "continuous_trigger," , 256 ) ; } if ( policy & PTIMER_POLICY_NO_IMMEDIATE_TRIGGER ) { g_strlcat ( policy_name , "no_immediate_trigger," , 256 ) ; } if ( policy & PTIMER_POLICY_NO_IMMEDIATE_RELOAD ) { g_strlcat ( policy_name , "no_immediate_reload," , 256 ) ; } if ( policy & PTIMER_POLICY_NO_COUNTER_ROUND_DOWN ) { g_strlcat ( policy_name , "no_counter_rounddown," , 256 ) ; } g_test_add_data_func ( g_strdup_printf ( "/ptimer/set_count policy=%s" , policy_name ) , ppolicy , check_set_count ) ; g_test_add_data_func ( g_strdup_printf ( "/ptimer/set_limit policy=%s" , policy_name ) , ppolicy , check_set_limit ) ; g_test_add_data_func ( g_strdup_printf ( "/ptimer/oneshot policy=%s" , policy_name ) , ppolicy , check_oneshot ) ; g_test_add_data_func ( g_strdup_printf ( "/ptimer/periodic policy=%s" , policy_name ) , ppolicy , check_periodic ) ; g_test_add_data_func ( g_strdup_printf ( "/ptimer/on_the_fly_mode_change policy=%s" , policy_name ) , ppolicy , check_on_the_fly_mode_change ) ; g_test_add_data_func ( g_strdup_printf ( "/ptimer/on_the_fly_period_change policy=%s" , policy_name ) , ppolicy , check_on_the_fly_period_change ) ; g_test_add_data_func ( g_strdup_printf ( "/ptimer/on_the_fly_freq_change policy=%s" , policy_name ) , ppolicy , check_on_the_fly_freq_change ) ; g_test_add_data_func ( g_strdup_printf ( "/ptimer/run_with_period_0 policy=%s" , policy_name ) , ppolicy , check_run_with_period_0 ) ; g_test_add_data_func ( g_strdup_printf ( "/ptimer/run_with_delta_0 policy=%s" , policy_name ) , ppolicy , check_run_with_delta_0 ) ; g_test_add_data_func ( g_strdup_printf ( "/ptimer/periodic_with_load_0 policy=%s" , policy_name ) , ppolicy , check_periodic_with_load_0 ) ; g_test_add_data_func ( g_strdup_printf ( "/ptimer/oneshot_with_load_0 policy=%s" , policy_name ) , ppolicy , check_oneshot_with_load_0 ) ; }##::##1##::##11609
void ff_h264_direct_ref_list_init ( H264Context * const h ) { MpegEncContext * const s = & h -> s ; Picture * const ref1 = & h -> ref_list [ 1 ] [ 0 ] ; Picture * const cur = s -> current_picture_ptr ; int list , j , field ; int sidx = ( s -> picture_structure & 1 ) ^ 1 ; int ref1sidx = ( ref1 -> f . reference & 1 ) ^ 1 ; for ( list = 0 ; list < 2 ; list ++ ) { cur -> ref_count [ sidx ] [ list ] = h -> ref_count [ list ] ; for ( j = 0 ; j < h -> ref_count [ list ] ; j ++ ) { cur -> ref_poc [ sidx ] [ list ] [ j ] = 4 * h -> ref_list [ list ] [ j ] . frame_num + ( h -> ref_list [ list ] [ j ] . f . reference & 3 ) ; } } if ( s -> picture_structure == PICT_FRAME ) { memcpy ( cur -> ref_count [ 1 ] , cur -> ref_count [ 0 ] , sizeof ( cur -> ref_count [ 0 ] ) ) ; memcpy ( cur -> ref_poc [ 1 ] , cur -> ref_poc [ 0 ] , sizeof ( cur -> ref_poc [ 0 ] ) ) ; } cur -> mbaff = FRAME_MBAFF ; h -> col_fieldoff = 0 ; if ( s -> picture_structure == PICT_FRAME ) { int cur_poc = s -> current_picture_ptr -> poc ; int * col_poc = h -> ref_list [ 1 ] -> field_poc ; h -> col_parity = ( FFABS ( col_poc [ 0 ] - cur_poc ) >= FFABS ( col_poc [ 1 ] - cur_poc ) ) ; ref1sidx = sidx = h -> col_parity ; } else if ( ! ( s -> picture_structure & h -> ref_list [ 1 ] [ 0 ] . f . reference ) && ! h -> ref_list [ 1 ] [ 0 ] . mbaff ) { h -> col_fieldoff = 2 * h -> ref_list [ 1 ] [ 0 ] . f . reference - 3 ; } if ( cur -> f . pict_type != AV_PICTURE_TYPE_B || h -> direct_spatial_mv_pred ) { return ; } for ( list = 0 ; list < 2 ; list ++ ) { fill_colmap ( h , h -> map_col_to_list0 , list , sidx , ref1sidx , 0 ) ; if ( FRAME_MBAFF ) for ( field = 0 ; field < 2 ; field ++ ) { fill_colmap ( h , h -> map_col_to_list0_field [ field ] , list , field , field , 1 ) ; } } }##::##1##::##4459
static void test_cancel ( void ) { WorkerTestData data [ 100 ] ; int num_canceled ; int i ; test_submit_many ( ) ; for ( i = 0 ; i < 100 ; i ++ ) { data [ i ] . n = 0 ; data [ i ] . ret = - EINPROGRESS ; data [ i ] . aiocb = thread_pool_submit_aio ( pool , long_cb , & data [ i ] , done_cb , & data [ i ] ) ; } active = 100 ; aio_notify ( ctx ) ; aio_poll ( ctx , false ) ; g_assert_cmpint ( active , == , 100 ) ; g_usleep ( 1000000 ) ; g_assert_cmpint ( active , > , 50 ) ; num_canceled = 0 ; for ( i = 0 ; i < 100 ; i ++ ) { if ( atomic_cmpxchg ( & data [ i ] . n , 0 , 3 ) == 0 ) { data [ i ] . ret = - ECANCELED ; bdrv_aio_cancel ( data [ i ] . aiocb ) ; active -- ; num_canceled ++ ; } } g_assert_cmpint ( active , > , 0 ) ; g_assert_cmpint ( num_canceled , < , 100 ) ; for ( i = 0 ; i < 100 ; i ++ ) { if ( data [ i ] . n != 3 ) { bdrv_aio_cancel ( data [ i ] . aiocb ) ; } } qemu_aio_wait_all ( ) ; g_assert_cmpint ( active , == , 0 ) ; for ( i = 0 ; i < 100 ; i ++ ) { if ( data [ i ] . n == 3 ) { g_assert_cmpint ( data [ i ] . ret , == , - ECANCELED ) ; g_assert ( data [ i ] . aiocb != NULL ) ; } else { g_assert_cmpint ( data [ i ] . n , == , 2 ) ; g_assert_cmpint ( data [ i ] . ret , == , 0 ) ; g_assert ( data [ i ] . aiocb == NULL ) ; } } }##::##1##::##2362
static int get_buffer_internal ( AVCodecContext * avctx , AVFrame * frame , int flags ) { const AVHWAccel * hwaccel = avctx -> hwaccel ; int override_dimensions = 1 ; int ret ; if ( avctx -> codec_type == AVMEDIA_TYPE_VIDEO ) { if ( ( ret = av_image_check_size2 ( avctx -> width , avctx -> height , avctx -> max_pixels , AV_PIX_FMT_NONE , 0 , avctx ) ) < 0 || avctx -> pix_fmt < 0 ) { av_log ( avctx , AV_LOG_ERROR , "video_get_buffer: image parameters invalid\n" ) ; return AVERROR ( EINVAL ) ; } if ( frame -> width <= 0 || frame -> height <= 0 ) { frame -> width = FFMAX ( avctx -> width , AV_CEIL_RSHIFT ( avctx -> coded_width , avctx -> lowres ) ) ; frame -> height = FFMAX ( avctx -> height , AV_CEIL_RSHIFT ( avctx -> coded_height , avctx -> lowres ) ) ; override_dimensions = 0 ; } if ( frame -> data [ 0 ] || frame -> data [ 1 ] || frame -> data [ 2 ] || frame -> data [ 3 ] ) { av_log ( avctx , AV_LOG_ERROR , "pic->data[*]!=NULL in get_buffer_internal\n" ) ; return AVERROR ( EINVAL ) ; } } ret = ff_decode_frame_props ( avctx , frame ) ; return ret ; if ( hwaccel ) { if ( hwaccel -> alloc_frame ) { ret = hwaccel -> alloc_frame ( avctx , frame ) ; goto end ; } } else { avctx -> sw_pix_fmt = avctx -> pix_fmt ; } ret = avctx -> get_buffer2 ( avctx , frame , flags ) ; if ( ret >= 0 ) { validate_avframe_allocation ( avctx , frame ) ; } end : if ( avctx -> codec_type == AVMEDIA_TYPE_VIDEO && ! override_dimensions && ! ( avctx -> codec -> caps_internal & FF_CODEC_CAP_EXPORTS_CROPPING ) ) { frame -> width = avctx -> width ; frame -> height = avctx -> height ; } return ret ; }##::##1##::##10936
static void do_video_stats ( AVOutputStream * ost , AVInputStream * ist , int frame_size ) { static FILE * fvstats = NULL ; static INT64 total_size = 0 ; struct tm * today ; time_t today2 ; char filename [ 40 ] ; AVCodecContext * enc ; int frame_number ; INT64 ti ; double ti1 , bitrate , avg_bitrate ; if ( ! fvstats ) { today2 = time ( NULL ) ; today = localtime ( & today2 ) ; sprintf ( filename , "vstats_%02d%02d%02d.log" , today -> tm_hour , today -> tm_min , today -> tm_sec ) ; fvstats = fopen ( filename , "w" ) ; if ( ! fvstats ) { perror ( "fopen" ) ; exit ( 1 ) ; } } ti = MAXINT64 ; enc = & ost -> st -> codec ; total_size += frame_size ; if ( enc -> codec_type == CODEC_TYPE_VIDEO ) { frame_number = ist -> frame_number ; fprintf ( fvstats , "frame= %5d q= %2d " , frame_number , enc -> quality ) ; if ( do_psnr ) { fprintf ( fvstats , "PSNR= %6.2f " , enc -> psnr_y ) ; } fprintf ( fvstats , "f_size= %6d " , frame_size ) ; if ( ! ist -> discard && ist -> pts < ti ) { ti = ist -> pts ; } ti1 = ( double ) ti / 1000000.0 ; if ( ti1 < 0.01 ) { ti1 = 0.01 ; } bitrate = ( double ) ( frame_size * 8 ) * enc -> frame_rate / FRAME_RATE_BASE / 1000.0 ; avg_bitrate = ( double ) ( total_size * 8 ) / ti1 / 1000.0 ; fprintf ( fvstats , "s_size= %8.0fkB time= %0.3f br= %7.1fkbits/s avg_br= %7.1fkbits/s " , ( double ) total_size / 1024 , ti1 , bitrate , avg_bitrate ) ; fprintf ( fvstats , "type= %s\n" , enc -> key_frame == 1 ? "I" : "P" ) ; } }##::##1##::##6624
void qmp_migrate ( const char * uri , bool has_blk , bool blk , bool has_inc , bool inc , bool has_detach , bool detach , Error * * errp ) { Error * local_err = NULL ; MigrationState * s = migrate_get_current ( ) ; MigrationParams params ; const char * p ; params . blk = has_blk && blk ; params . shared = has_inc && inc ; if ( s -> state == MIG_STATE_ACTIVE || s -> state == MIG_STATE_SETUP || s -> state == MIG_STATE_CANCELLING ) { error_set ( errp , QERR_MIGRATION_ACTIVE ) ; if ( qemu_savevm_state_blocked ( errp ) ) { if ( migration_blockers ) { * errp = error_copy ( migration_blockers -> data ) ; s = migrate_init ( & params ) ; if ( strstart ( uri , "tcp:" , & p ) ) { tcp_start_outgoing_migration ( s , p , & local_err ) ; # ifdef CONFIG_RDMA } else if ( strstart ( uri , "rdma:" , & p ) ) { rdma_start_outgoing_migration ( s , p , & local_err ) ; # endif # if ! defined ( WIN32 ) } else if ( strstart ( uri , "exec:" , & p ) ) { exec_start_outgoing_migration ( s , p , & local_err ) ; } else if ( strstart ( uri , "unix:" , & p ) ) { unix_start_outgoing_migration ( s , p , & local_err ) ; } else if ( strstart ( uri , "fd:" , & p ) ) { fd_start_outgoing_migration ( s , p , & local_err ) ; # endif } else { error_set ( errp , QERR_INVALID_PARAMETER_VALUE , "uri" , "a valid migration protocol" ) ; s -> state = MIG_STATE_ERROR ; if ( local_err ) { migrate_fd_error ( s ) ; error_propagate ( errp , local_err ) ;##::##1##::##12146
static inline int RENAME ( yuv420_rgb32 ) ( SwsContext * c , uint8_t * src [ ] , int srcStride [ ] , int srcSliceY , int srcSliceH , uint8_t * dst [ ] , int dstStride [ ] ) { int y , h_size ; if ( c -> srcFormat == PIX_FMT_YUV422P ) { srcStride [ 1 ] *= 2 ; srcStride [ 2 ] *= 2 ; } h_size = ( c -> dstW + 7 ) & ~ 7 ; if ( h_size * 4 > FFABS ( dstStride [ 0 ] ) ) { h_size -= 8 ; } __asm__ __volatile__ ( "pxor %mm4, %mm4;" ) ; for ( y = 0 ; y < srcSliceH ; y ++ ) { uint8_t * _image = dst [ 0 ] + ( y + srcSliceY ) * dstStride [ 0 ] ; uint8_t * _py = src [ 0 ] + y * srcStride [ 0 ] ; uint8_t * _pu = src [ 1 ] + ( y >> 1 ) * srcStride [ 1 ] ; uint8_t * _pv = src [ 2 ] + ( y >> 1 ) * srcStride [ 2 ] ; long index = - h_size / 2 ; __asm__ __volatile__ ( "movd (%2, %0), %%mm0;" "movd (%3, %0), %%mm1;" "movq (%5, %0, 2), %%mm6;" "1:				\n\t" YUV2RGB "pxor %%mm3, %%mm3;" "movq %%mm0, %%mm6;" "movq %%mm1, %%mm7;" "movq %%mm0, %%mm4;" "movq %%mm1, %%mm5;" "punpcklbw %%mm2, %%mm6;" "punpcklbw %%mm3, %%mm7;" "punpcklwd %%mm7, %%mm6;" MOVNTQ " %%mm6, (%1);" "movq %%mm0, %%mm6;" "punpcklbw %%mm2, %%mm6;" "punpckhwd %%mm7, %%mm6;" MOVNTQ " %%mm6, 8 (%1);" "punpckhbw %%mm2, %%mm4;" "punpckhbw %%mm3, %%mm5;" "punpcklwd %%mm5, %%mm4;" MOVNTQ " %%mm4, 16 (%1);" "movq %%mm0, %%mm4;" "punpckhbw %%mm2, %%mm4;" "punpckhwd %%mm5, %%mm4;" MOVNTQ " %%mm4, 24 (%1);" "movd 4 (%2, %0), %%mm0;" "movd 4 (%3, %0), %%mm1;" "pxor %%mm4, %%mm4;" "movq 8 (%5, %0, 2), %%mm6;" "add $32, %1			\n\t" "add $4, %0			\n\t" " js 1b				\n\t" : "+r" ( index ) , "+r" ( _image ) : "r" ( _pu - index ) , "r" ( _pv - index ) , "r" ( & c -> redDither ) , "r" ( _py - 2 * index ) ) ; } __asm__ __volatile__ ( EMMS ) ; return srcSliceH ; }##::##1##::##3345
static float pvq_band_cost ( CeltPVQ * pvq , CeltFrame * f , OpusRangeCoder * rc , int band , float * bits , float lambda ) { int i , b = 0 ; uint32_t cm [ 2 ] = { ( 1 << f -> blocks ) - 1 , ( 1 << f -> blocks ) - 1 } ; const int band_size = ff_celt_freq_range [ band ] << f -> size ; float buf [ 176 * 2 ] , lowband_scratch [ 176 ] , norm1 [ 176 ] , norm2 [ 176 ] ; float dist , cost , err_x = 0.0f , err_y = 0.0f ; float * X = buf ; float * X_orig = f -> block [ 0 ] . coeffs + ( ff_celt_freq_bands [ band ] << f -> size ) ; float * Y = ( f -> channels == 2 ) ? & buf [ 176 ] : NULL ; float * Y_orig = f -> block [ 1 ] . coeffs + ( ff_celt_freq_bands [ band ] << f -> size ) ; OPUS_RC_CHECKPOINT_SPAWN ( rc ) ; memcpy ( X , X_orig , band_size * sizeof ( float ) ) ; if ( Y ) { memcpy ( Y , Y_orig , band_size * sizeof ( float ) ) ; } f -> remaining2 = ( ( f -> framebits << 3 ) - f -> anticollapse_needed ) - opus_rc_tell_frac ( rc ) - 1 ; if ( band <= f -> coded_bands - 1 ) { int curr_balance = f -> remaining / FFMIN ( 3 , f -> coded_bands - band ) ; b = av_clip_uintp2 ( FFMIN ( f -> remaining2 + 1 , f -> pulses [ band ] + curr_balance ) , 14 ) ; } if ( f -> dual_stereo ) { pvq -> encode_band ( pvq , f , rc , band , X , NULL , band_size , b / 2 , f -> blocks , NULL , f -> size , norm1 , 0 , 1.0f , lowband_scratch , cm [ 0 ] ) ; pvq -> encode_band ( pvq , f , rc , band , Y , NULL , band_size , b / 2 , f -> blocks , NULL , f -> size , norm2 , 0 , 1.0f , lowband_scratch , cm [ 1 ] ) ; } else { pvq -> encode_band ( pvq , f , rc , band , X , Y , band_size , b , f -> blocks , NULL , f -> size , norm1 , 0 , 1.0f , lowband_scratch , cm [ 0 ] | cm [ 1 ] ) ; } for ( i = 0 ; i < band_size ; i ++ ) { err_x += ( X [ i ] - X_orig [ i ] ) * ( X [ i ] - X_orig [ i ] ) ; err_y += ( Y [ i ] - Y_orig [ i ] ) * ( Y [ i ] - Y_orig [ i ] ) ; } dist = sqrtf ( err_x ) + sqrtf ( err_y ) ; cost = OPUS_RC_CHECKPOINT_BITS ( rc ) / 8.0f ; * bits += cost ; OPUS_RC_CHECKPOINT_ROLLBACK ( rc ) ; return lambda * dist * cost ; }##::##1##::##7985
static int mov_write_udta_tag ( ByteIOContext * pb , MOVMuxContext * mov , AVFormatContext * s ) { ByteIOContext * pb_buf ; int i , ret , size ; uint8_t * buf ; for ( i = 0 ; i < s -> nb_streams ; i ++ ) if ( mov -> tracks [ i ] . enc -> flags & CODEC_FLAG_BITEXACT ) { return 0 ; } ret = url_open_dyn_buf ( & pb_buf ) ; if ( ret < 0 ) { return ret ; } if ( mov -> mode & MODE_3GP ) { mov_write_3gp_udta_tag ( pb_buf , s , "perf" , "artist" ) ; mov_write_3gp_udta_tag ( pb_buf , s , "titl" , "title" ) ; mov_write_3gp_udta_tag ( pb_buf , s , "auth" , "author" ) ; mov_write_3gp_udta_tag ( pb_buf , s , "gnre" , "genre" ) ; mov_write_3gp_udta_tag ( pb_buf , s , "dscp" , "comment" ) ; mov_write_3gp_udta_tag ( pb_buf , s , "albm" , "album" ) ; mov_write_3gp_udta_tag ( pb_buf , s , "cprt" , "copyright" ) ; mov_write_3gp_udta_tag ( pb_buf , s , "yrrc" , "date" ) ; } else if ( mov -> mode == MODE_MOV ) { mov_write_string_metadata ( s , pb_buf , "\251nam" , "title" , 0 ) ; mov_write_string_metadata ( s , pb_buf , "\251aut" , "author" , 0 ) ; mov_write_string_metadata ( s , pb_buf , "\251alb" , "album" , 0 ) ; mov_write_string_metadata ( s , pb_buf , "\251day" , "date" , 0 ) ; mov_write_string_tag ( pb_buf , "\251enc" , LIBAVFORMAT_IDENT , 0 , 0 ) ; mov_write_string_metadata ( s , pb_buf , "\251des" , "comment" , 0 ) ; mov_write_string_metadata ( s , pb_buf , "\251gen" , "genre" , 0 ) ; mov_write_string_metadata ( s , pb_buf , "\251cpy" , "copyright" , 0 ) ; } else { mov_write_meta_tag ( pb_buf , mov , s ) ; } if ( s -> nb_chapters ) { mov_write_chpl_tag ( pb_buf , s ) ; } if ( ( size = url_close_dyn_buf ( pb_buf , & buf ) ) > 0 ) { put_be32 ( pb , size + 8 ) ; put_tag ( pb , "udta" ) ; put_buffer ( pb , buf , size ) ; av_free ( buf ) ; } return 0 ; }##::##1##::##210
static int decode_segment ( TAKDecContext * s , int8_t mode , int32_t * decoded , int len ) { struct CParam code ; GetBitContext * gb = & s -> gb ; int i ; if ( ! mode ) { memset ( decoded , 0 , len * sizeof ( * decoded ) ) ; return 0 ; } if ( mode > FF_ARRAY_ELEMS ( xcodes ) ) { return AVERROR_INVALIDDATA ; } code = xcodes [ mode - 1 ] ; for ( i = 0 ; i < len ; i ++ ) { int x = get_bits_long ( gb , code . init ) ; if ( x >= code . escape && get_bits1 ( gb ) ) { x |= 1 << code . init ; if ( x >= code . aescape ) { int scale = get_unary ( gb , 1 , 9 ) ; if ( scale == 9 ) { int scale_bits = get_bits ( gb , 3 ) ; if ( scale_bits > 0 ) { if ( scale_bits == 7 ) { scale_bits += get_bits ( gb , 5 ) ; if ( scale_bits > 29 ) { return AVERROR_INVALIDDATA ; } } scale = get_bits_long ( gb , scale_bits ) + 1 ; x += code . scale * scale ; } x += code . bias ; } else { x += code . scale * scale - code . escape ; } } else { x -= code . escape ; } } decoded [ i ] = ( x >> 1 ) ^ - ( x & 1 ) ; } return 0 ; }##::##1##::##97
static void mirror_start_job ( BlockDriverState * bs , BlockDriverState * target , const char * replaces , int64_t speed , uint32_t granularity , int64_t buf_size , BlockMirrorBackingMode backing_mode , BlockdevOnError on_source_error , BlockdevOnError on_target_error , bool unmap , BlockCompletionFunc * cb , void * opaque , Error * * errp , const BlockJobDriver * driver , bool is_none_mode , BlockDriverState * base ) { MirrorBlockJob * s ; if ( granularity == 0 ) { granularity = bdrv_get_default_bitmap_granularity ( target ) ; } assert ( ( granularity & ( granularity - 1 ) ) == 0 ) ; if ( buf_size < 0 ) { error_setg ( errp , "Invalid parameter 'buf-size'" ) ; return ; } if ( buf_size == 0 ) { buf_size = DEFAULT_MIRROR_BUF_SIZE ; } s = block_job_create ( driver , bs , speed , cb , opaque , errp ) ; if ( ! s ) { return ; } s -> target = blk_new ( ) ; blk_insert_bs ( s -> target , target ) ; s -> replaces = g_strdup ( replaces ) ; s -> on_source_error = on_source_error ; s -> on_target_error = on_target_error ; s -> is_none_mode = is_none_mode ; s -> backing_mode = backing_mode ; s -> base = base ; s -> granularity = granularity ; s -> buf_size = ROUND_UP ( buf_size , granularity ) ; s -> unmap = unmap ; s -> dirty_bitmap = bdrv_create_dirty_bitmap ( bs , granularity , NULL , errp ) ; if ( ! s -> dirty_bitmap ) { g_free ( s -> replaces ) ; blk_unref ( s -> target ) ; block_job_unref ( & s -> common ) ; return ; } bdrv_op_block_all ( target , s -> common . blocker ) ; s -> common . co = qemu_coroutine_create ( mirror_run ) ; trace_mirror_start ( bs , s , s -> common . co , opaque ) ; qemu_coroutine_enter ( s -> common . co , s ) ; }##::##1##::##10103
static int colo_packet_compare_tcp ( Packet * spkt , Packet * ppkt ) { struct tcphdr * ptcp , * stcp ; int res ; trace_colo_compare_main ( "compare tcp" ) ; ptcp = ( struct tcphdr * ) ppkt -> transport_header ; stcp = ( struct tcphdr * ) spkt -> transport_header ; if ( ntohs ( ppkt -> ip -> ip_off ) & IP_DF ) { spkt -> ip -> ip_id = ppkt -> ip -> ip_id ; spkt -> ip -> ip_sum = ppkt -> ip -> ip_sum ; } if ( ptcp -> th_off > 5 ) { ptrdiff_t tcp_offset ; tcp_offset = ppkt -> transport_header - ( uint8_t * ) ppkt -> data + ( ptcp -> th_off * 4 ) - ppkt -> vnet_hdr_len ; res = colo_packet_compare_common ( ppkt , spkt , tcp_offset ) ; } else if ( ptcp -> th_sum == stcp -> th_sum ) { res = colo_packet_compare_common ( ppkt , spkt , ETH_HLEN ) ; } else { res = - 1 ; } if ( res != 0 && trace_event_get_state ( TRACE_COLO_COMPARE_MISCOMPARE ) ) { char pri_ip_src [ 20 ] , pri_ip_dst [ 20 ] , sec_ip_src [ 20 ] , sec_ip_dst [ 20 ] ; strcpy ( pri_ip_src , inet_ntoa ( ppkt -> ip -> ip_src ) ) ; strcpy ( pri_ip_dst , inet_ntoa ( ppkt -> ip -> ip_dst ) ) ; strcpy ( sec_ip_src , inet_ntoa ( spkt -> ip -> ip_src ) ) ; strcpy ( sec_ip_dst , inet_ntoa ( spkt -> ip -> ip_dst ) ) ; trace_colo_compare_ip_info ( ppkt -> size , pri_ip_src , pri_ip_dst , spkt -> size , sec_ip_src , sec_ip_dst ) ; trace_colo_compare_tcp_info ( "pri tcp packet" , ntohl ( ptcp -> th_seq ) , ntohl ( ptcp -> th_ack ) , res , ptcp -> th_flags , ppkt -> size ) ; trace_colo_compare_tcp_info ( "sec tcp packet" , ntohl ( stcp -> th_seq ) , ntohl ( stcp -> th_ack ) , res , stcp -> th_flags , spkt -> size ) ; qemu_hexdump ( ( char * ) ppkt -> data , stderr , "colo-compare ppkt" , ppkt -> size ) ; qemu_hexdump ( ( char * ) spkt -> data , stderr , "colo-compare spkt" , spkt -> size ) ; } return res ; }##::##1##::##6545
av_cold int avcodec_close ( AVCodecContext * avctx ) { if ( ff_lockmgr_cb ) { if ( ( * ff_lockmgr_cb ) ( & codec_mutex , AV_LOCK_OBTAIN ) ) { return - 1 ; } } entangled_thread_counter ++ ; if ( entangled_thread_counter != 1 ) { av_log ( avctx , AV_LOG_ERROR , "insufficient thread locking around avcodec_open/close()\n" ) ; entangled_thread_counter -- ; return - 1 ; } if ( avcodec_is_open ( avctx ) ) { if ( HAVE_THREADS && avctx -> internal -> frame_thread_encoder && avctx -> thread_count > 1 ) { entangled_thread_counter -- ; ff_frame_thread_encoder_free ( avctx ) ; entangled_thread_counter ++ ; } if ( HAVE_THREADS && avctx -> thread_opaque ) { ff_thread_free ( avctx ) ; } if ( avctx -> codec && avctx -> codec -> close ) { avctx -> codec -> close ( avctx ) ; } avcodec_default_free_buffers ( avctx ) ; avctx -> coded_frame = NULL ; avctx -> internal -> byte_buffer_size = 0 ; av_freep ( & avctx -> internal -> byte_buffer ) ; av_freep ( & avctx -> internal ) ; } if ( avctx -> priv_data && avctx -> codec && avctx -> codec -> priv_class ) { av_opt_free ( avctx -> priv_data ) ; } av_opt_free ( avctx ) ; av_freep ( & avctx -> priv_data ) ; if ( av_codec_is_encoder ( avctx -> codec ) ) { av_freep ( & avctx -> extradata ) ; } avctx -> codec = NULL ; avctx -> active_thread_type = 0 ; entangled_thread_counter -- ; if ( ff_lockmgr_cb ) { ( * ff_lockmgr_cb ) ( & codec_mutex , AV_LOCK_RELEASE ) ; } return 0 ; }##::##1##::##7979
static int vp3_update_thread_context ( AVCodecContext * dst , const AVCodecContext * src ) { Vp3DecodeContext * s = dst -> priv_data , * s1 = src -> priv_data ; int qps_changed = 0 , i , err ; # define copy_fields ( to , from , start_field , end_field ) memcpy ( & to -> start_field , & from -> start_field , ( char * ) & to -> end_field - ( char * ) & to -> start_field ) if ( ! s1 -> current_frame . data [ 0 ] || s -> width != s1 -> width || s -> height != s1 -> height ) { if ( s != s1 ) { copy_fields ( s , s1 , golden_frame , current_frame ) ; } return - 1 ; } if ( s != s1 ) { if ( ! s -> current_frame . data [ 0 ] ) { int y_fragment_count , c_fragment_count ; s -> avctx = dst ; err = allocate_tables ( dst ) ; if ( err ) { return err ; } y_fragment_count = s -> fragment_width [ 0 ] * s -> fragment_height [ 0 ] ; c_fragment_count = s -> fragment_width [ 1 ] * s -> fragment_height [ 1 ] ; memcpy ( s -> motion_val [ 0 ] , s1 -> motion_val [ 0 ] , y_fragment_count * sizeof ( * s -> motion_val [ 0 ] ) ) ; memcpy ( s -> motion_val [ 1 ] , s1 -> motion_val [ 1 ] , c_fragment_count * sizeof ( * s -> motion_val [ 1 ] ) ) ; } copy_fields ( s , s1 , golden_frame , dsp ) ; for ( i = 0 ; i < 3 ; i ++ ) { if ( s -> qps [ i ] != s1 -> qps [ 1 ] ) { qps_changed = 1 ; memcpy ( & s -> qmat [ i ] , & s1 -> qmat [ i ] , sizeof ( s -> qmat [ i ] ) ) ; } } if ( s -> qps [ 0 ] != s1 -> qps [ 0 ] ) { memcpy ( & s -> bounding_values_array , & s1 -> bounding_values_array , sizeof ( s -> bounding_values_array ) ) ; } if ( qps_changed ) { copy_fields ( s , s1 , qps , superblock_count ) ; } # undef copy_fields } update_frames ( dst ) ; return 0 ; }##::##1##::##2225
static void cirrus_do_copy ( CirrusVGAState * s , int dst , int src , int w , int h ) { int sx , sy ; int dx , dy ; int width , height ; int depth ; int notify = 0 ; depth = s -> get_bpp ( ( VGAState * ) s ) / 8 ; s -> get_resolution ( ( VGAState * ) s , & width , & height ) ; sx = ( src % ( width * depth ) ) / depth ; sy = ( src / ( width * depth ) ) ; dx = ( dst % ( width * depth ) ) / depth ; dy = ( dst / ( width * depth ) ) ; w /= depth ; if ( s -> cirrus_blt_dstpitch < 0 ) { sx -= ( s -> cirrus_blt_width / depth ) - 1 ; dx -= ( s -> cirrus_blt_width / depth ) - 1 ; sy -= s -> cirrus_blt_height - 1 ; dy -= s -> cirrus_blt_height - 1 ; } if ( sx >= 0 && sy >= 0 && dx >= 0 && dy >= 0 && ( sx + w ) <= width && ( sy + h ) <= height && ( dx + w ) <= width && ( dy + h ) <= height ) { notify = 1 ; } if ( * s -> cirrus_rop != cirrus_bitblt_rop_fwd_src && * s -> cirrus_rop != cirrus_bitblt_rop_bkwd_src ) { notify = 0 ; } if ( notify ) { vga_hw_update ( ) ; } ( * s -> cirrus_rop ) ( s , s -> vram_ptr + ( s -> cirrus_blt_dstaddr & s -> cirrus_addr_mask ) , s -> vram_ptr + ( s -> cirrus_blt_srcaddr & s -> cirrus_addr_mask ) , s -> cirrus_blt_dstpitch , s -> cirrus_blt_srcpitch , s -> cirrus_blt_width , s -> cirrus_blt_height ) ; if ( notify ) qemu_console_copy ( s -> ds , sx , sy , dx , dy , s -> cirrus_blt_width / depth , s -> cirrus_blt_height ) ; if ( ! notify ) cirrus_invalidate_region ( s , s -> cirrus_blt_dstaddr , s -> cirrus_blt_dstpitch , s -> cirrus_blt_width , s -> cirrus_blt_height ) ; }##::##1##::##10739
static int encode_superframe ( AVCodecContext * avctx , AVPacket * avpkt , const AVFrame * frame , int * got_packet_ptr ) { WMACodecContext * s = avctx -> priv_data ; int i , total_gain , ret , error ; s -> block_len_bits = s -> frame_len_bits ; s -> block_len = 1 << s -> block_len_bits ; apply_window_and_mdct ( avctx , frame ) ; if ( s -> ms_stereo ) { float a , b ; int i ; for ( i = 0 ; i < s -> block_len ; i ++ ) { a = s -> coefs [ 0 ] [ i ] * 0.5 ; b = s -> coefs [ 1 ] [ i ] * 0.5 ; s -> coefs [ 0 ] [ i ] = a + b ; s -> coefs [ 1 ] [ i ] = a - b ; if ( ( ret = ff_alloc_packet2 ( avctx , avpkt , 2 * MAX_CODED_SUPERFRAME_SIZE ) ) < 0 ) { return ret ; } total_gain = 128 ; for ( i = 64 ; i ; i >>= 1 ) { error = encode_frame ( s , s -> coefs , avpkt -> data , avpkt -> size , total_gain - i ) ; if ( error <= 0 ) { total_gain -= i ; } while ( total_gain <= 128 && error > 0 ) { error = encode_frame ( s , s -> coefs , avpkt -> data , avpkt -> size , total_gain ++ ) ; } av_assert0 ( ( put_bits_count ( & s -> pb ) & 7 ) == 0 ) ; i = avctx -> block_align - ( put_bits_count ( & s -> pb ) + 7 ) / 8 ; av_assert0 ( i >= 0 ) ; while ( i -- ) { put_bits ( & s -> pb , 8 , 'N' ) ; } flush_put_bits ( & s -> pb ) ; av_assert0 ( put_bits_ptr ( & s -> pb ) - s -> pb . buf == avctx -> block_align ) ; if ( frame -> pts != AV_NOPTS_VALUE ) { avpkt -> pts = frame -> pts - ff_samples_to_time_base ( avctx , avctx -> delay ) ; } avpkt -> size = avctx -> block_align ; * got_packet_ptr = 1 ; return 0 ;##::##1##::##9925
static int decode_pce ( AVCodecContext * avctx , MPEG4AudioConfig * m4ac , uint8_t ( * layout_map ) [ 3 ] , GetBitContext * gb ) { int num_front , num_side , num_back , num_lfe , num_assoc_data , num_cc , sampling_index ; int comment_len ; int tags ; skip_bits ( gb , 2 ) ; sampling_index = get_bits ( gb , 4 ) ; if ( m4ac -> sampling_index != sampling_index ) { av_log ( avctx , AV_LOG_WARNING , "Sample rate index in program config element does not match the sample rate index configured by the container.\n" ) ; } num_front = get_bits ( gb , 4 ) ; num_side = get_bits ( gb , 4 ) ; num_back = get_bits ( gb , 4 ) ; num_lfe = get_bits ( gb , 2 ) ; num_assoc_data = get_bits ( gb , 3 ) ; num_cc = get_bits ( gb , 4 ) ; if ( get_bits1 ( gb ) ) { skip_bits ( gb , 4 ) ; } if ( get_bits1 ( gb ) ) { skip_bits ( gb , 4 ) ; } if ( get_bits1 ( gb ) ) { skip_bits ( gb , 3 ) ; } if ( get_bits_left ( gb ) < 4 * ( num_front + num_side + num_back + num_lfe + num_assoc_data + num_cc ) ) { av_log ( avctx , AV_LOG_ERROR , overread_err ) ; return - 1 ; } decode_channel_map ( layout_map , AAC_CHANNEL_FRONT , gb , num_front ) ; tags = num_front ; decode_channel_map ( layout_map + tags , AAC_CHANNEL_SIDE , gb , num_side ) ; tags += num_side ; decode_channel_map ( layout_map + tags , AAC_CHANNEL_BACK , gb , num_back ) ; tags += num_back ; decode_channel_map ( layout_map + tags , AAC_CHANNEL_LFE , gb , num_lfe ) ; tags += num_lfe ; skip_bits_long ( gb , 4 * num_assoc_data ) ; decode_channel_map ( layout_map + tags , AAC_CHANNEL_CC , gb , num_cc ) ; tags += num_cc ; align_get_bits ( gb ) ; comment_len = get_bits ( gb , 8 ) * 8 ; if ( get_bits_left ( gb ) < comment_len ) { av_log ( avctx , AV_LOG_ERROR , overread_err ) ; return - 1 ; } skip_bits_long ( gb , comment_len ) ; return tags ; }##::##1##::##7860
static int qemu_loadvm_state ( QEMUFile * f ) { SaveStateEntry * se ; int len , ret , instance_id , record_len , version_id ; int64_t total_len , end_pos , cur_pos ; unsigned int v ; char idstr [ 256 ] ; v = qemu_get_be32 ( f ) ; if ( v != QEMU_VM_FILE_MAGIC ) { goto fail ; } v = qemu_get_be32 ( f ) ; if ( v != QEMU_VM_FILE_VERSION ) { fail : ret = - 1 ; goto the_end ; } total_len = qemu_get_be64 ( f ) ; end_pos = total_len + qemu_ftell ( f ) ; for ( ; ; ) { if ( qemu_ftell ( f ) >= end_pos ) { break ; } len = qemu_get_byte ( f ) ; qemu_get_buffer ( f , ( uint8_t * ) idstr , len ) ; idstr [ len ] = '\0' ; instance_id = qemu_get_be32 ( f ) ; version_id = qemu_get_be32 ( f ) ; record_len = qemu_get_be32 ( f ) ; # if 0 printf ( "idstr=%s instance=0x%x version=%d len=%d\n" , idstr , instance_id , version_id , record_len ) ; # endif cur_pos = qemu_ftell ( f ) ; se = find_se ( idstr , instance_id ) ; if ( ! se ) { fprintf ( stderr , "qemu: warning: instance 0x%x of device '%s' not present in current VM\n" , instance_id , idstr ) ; } else { ret = se -> load_state ( f , se -> opaque , version_id ) ; if ( ret < 0 ) { fprintf ( stderr , "qemu: warning: error while loading state for instance 0x%x of device '%s'\n" , instance_id , idstr ) ; } } qemu_fseek ( f , cur_pos + record_len , SEEK_SET ) ; } ret = 0 ; the_end : return ret ; }##::##1##::##3237
static int block_load ( QEMUFile * f , void * opaque , int version_id ) { static int banner_printed ; int len , flags ; char device_name [ 256 ] ; int64_t addr ; BlockDriverState * bs ; uint8_t * buf ; do { addr = qemu_get_be64 ( f ) ; flags = addr & ~ BDRV_SECTOR_MASK ; addr >>= BDRV_SECTOR_BITS ; if ( flags & BLK_MIG_FLAG_DEVICE_BLOCK ) { int ret ; len = qemu_get_byte ( f ) ; qemu_get_buffer ( f , ( uint8_t * ) device_name , len ) ; device_name [ len ] = '\0' ; bs = bdrv_find ( device_name ) ; if ( ! bs ) { fprintf ( stderr , "Error unknown block device %s\n" , device_name ) ; return - EINVAL ; } buf = qemu_malloc ( BLOCK_SIZE ) ; qemu_get_buffer ( f , buf , BLOCK_SIZE ) ; ret = bdrv_write ( bs , addr , buf , BDRV_SECTORS_PER_DIRTY_CHUNK ) ; qemu_free ( buf ) ; if ( ret < 0 ) { return ret ; } } else if ( flags & BLK_MIG_FLAG_PROGRESS ) { if ( ! banner_printed ) { printf ( "Receiving block device images\n" ) ; banner_printed = 1 ; } printf ( "Completed %d %%%c" , ( int ) addr , ( addr == 100 ) ? '\n' : '\r' ) ; fflush ( stdout ) ; } else if ( ! ( flags & BLK_MIG_FLAG_EOS ) ) { fprintf ( stderr , "Unknown flags\n" ) ; return - EINVAL ; } if ( qemu_file_has_error ( f ) ) { return - EIO ; } } while ( ! ( flags & BLK_MIG_FLAG_EOS ) ) ; return 0 ; }##::##1##::##8838
static int vmdk_add_extent ( BlockDriverState * bs , BlockDriverState * file , bool flat , int64_t sectors , int64_t l1_offset , int64_t l1_backup_offset , uint32_t l1_size , int l2_size , uint64_t cluster_sectors , VmdkExtent * * new_extent , Error * * errp ) { VmdkExtent * extent ; BDRVVmdkState * s = bs -> opaque ; int64_t length ; if ( cluster_sectors > 0x200000 ) { error_setg ( errp , "Invalid granularity, image may be corrupt" ) ; return - EFBIG ; } if ( l1_size > 512 * 1024 * 1024 ) { error_setg ( errp , "L1 size too big" ) ; return - EFBIG ; } length = bdrv_getlength ( file ) ; if ( length < 0 ) { return length ; } s -> extents = g_realloc ( s -> extents , ( s -> num_extents + 1 ) * sizeof ( VmdkExtent ) ) ; extent = & s -> extents [ s -> num_extents ] ; s -> num_extents ++ ; memset ( extent , 0 , sizeof ( VmdkExtent ) ) ; extent -> file = file ; extent -> flat = flat ; extent -> sectors = sectors ; extent -> l1_table_offset = l1_offset ; extent -> l1_backup_table_offset = l1_backup_offset ; extent -> l1_size = l1_size ; extent -> l1_entry_sectors = l2_size * cluster_sectors ; extent -> l2_size = l2_size ; extent -> cluster_sectors = flat ? sectors : cluster_sectors ; extent -> next_cluster_sector = ROUND_UP ( DIV_ROUND_UP ( length , BDRV_SECTOR_SIZE ) , cluster_sectors ) ; if ( s -> num_extents > 1 ) { extent -> end_sector = ( * ( extent - 1 ) ) . end_sector + extent -> sectors ; } else { extent -> end_sector = extent -> sectors ; } bs -> total_sectors = extent -> end_sector ; if ( new_extent ) { * new_extent = extent ; } return 0 ; }##::##1##::##10664
static int decode_user_data ( MpegEncContext * s , GetBitContext * gb ) { char buf [ 256 ] ; int i ; int e ; int ver , build , ver2 , ver3 ; char last ; for ( i = 0 ; i < 255 ; i ++ ) { if ( show_bits ( gb , 23 ) == 0 ) { break ; } buf [ i ] = get_bits ( gb , 8 ) ; } buf [ i ] = 0 ; e = sscanf ( buf , "DivX%dBuild%d%c" , & ver , & build , & last ) ; if ( e < 2 ) { e = sscanf ( buf , "DivX%db%d%c" , & ver , & build , & last ) ; } if ( e >= 2 ) { s -> divx_version = ver ; s -> divx_build = build ; s -> divx_packed = e == 3 && last == 'p' ; } e = sscanf ( buf , "FFmpe%*[^b]b%d" , & build ) + 3 ; if ( e != 4 ) { e = sscanf ( buf , "FFmpeg v%d.%d.%d / libavcodec build: %d" , & ver , & ver2 , & ver3 , & build ) ; } if ( e != 4 ) { e = sscanf ( buf , "Lavc%d.%d.%d" , & ver , & ver2 , & ver3 ) + 1 ; build = ( ver << 16 ) + ( ver2 << 8 ) + ver3 ; } if ( e != 4 ) { if ( strcmp ( buf , "ffmpeg" ) == 0 ) { s -> lavc_build = 4600 ; } } if ( e == 4 ) { s -> lavc_build = build ; } e = sscanf ( buf , "XviD%d" , & build ) ; if ( e == 1 ) { s -> xvid_build = build ; } return 0 ; }##::##1##::##11023
SwsFunc yuv2rgb_init_altivec ( SwsContext * c ) { if ( ! ( c -> flags & SWS_CPU_CAPS_ALTIVEC ) ) { return NULL ; } if ( ( c -> srcW & 0xf ) != 0 ) { return NULL ; } switch ( c -> srcFormat ) { case PIX_FMT_YUV410P : case PIX_FMT_YUV420P : case PIX_FMT_GRAY8 : case PIX_FMT_NV12 : case PIX_FMT_NV21 : if ( ( c -> srcH & 0x1 ) != 0 ) { return NULL ; } switch ( c -> dstFormat ) { case PIX_FMT_RGB24 : av_log ( c , AV_LOG_WARNING , "ALTIVEC: Color Space RGB24\n" ) ; return altivec_yuv2_rgb24 ; case PIX_FMT_BGR24 : av_log ( c , AV_LOG_WARNING , "ALTIVEC: Color Space BGR24\n" ) ; return altivec_yuv2_bgr24 ; case PIX_FMT_ARGB : av_log ( c , AV_LOG_WARNING , "ALTIVEC: Color Space ARGB\n" ) ; return altivec_yuv2_argb ; case PIX_FMT_ABGR : av_log ( c , AV_LOG_WARNING , "ALTIVEC: Color Space ABGR\n" ) ; return altivec_yuv2_abgr ; case PIX_FMT_RGBA : av_log ( c , AV_LOG_WARNING , "ALTIVEC: Color Space RGBA\n" ) ; return altivec_yuv2_rgba ; case PIX_FMT_BGRA : av_log ( c , AV_LOG_WARNING , "ALTIVEC: Color Space BGRA\n" ) ; return altivec_yuv2_bgra ; default : return NULL ; } break ; case PIX_FMT_UYVY422 : switch ( c -> dstFormat ) { case PIX_FMT_BGR32 : av_log ( c , AV_LOG_WARNING , "ALTIVEC: Color Space UYVY -> RGB32\n" ) ; return altivec_uyvy_rgb32 ; default : return NULL ; } break ; } return NULL ; }##::##1##::##10058
void ff_vdpau_mpeg_picture_complete ( MpegEncContext * s , const uint8_t * buf , int buf_size , int slice_count ) { struct vdpau_render_state * render , * last , * next ; int i ; render = ( struct vdpau_render_state * ) s -> current_picture_ptr -> data [ 0 ] ; assert ( render ) ; render -> info . mpeg . picture_structure = s -> picture_structure ; render -> info . mpeg . picture_coding_type = s -> pict_type ; render -> info . mpeg . intra_dc_precision = s -> intra_dc_precision ; render -> info . mpeg . frame_pred_frame_dct = s -> frame_pred_frame_dct ; render -> info . mpeg . concealment_motion_vectors = s -> concealment_motion_vectors ; render -> info . mpeg . intra_vlc_format = s -> intra_vlc_format ; render -> info . mpeg . alternate_scan = s -> alternate_scan ; render -> info . mpeg . q_scale_type = s -> q_scale_type ; render -> info . mpeg . top_field_first = s -> top_field_first ; render -> info . mpeg . full_pel_forward_vector = s -> full_pel [ 0 ] ; render -> info . mpeg . full_pel_backward_vector = s -> full_pel [ 1 ] ; render -> info . mpeg . f_code [ 0 ] [ 0 ] = s -> mpeg_f_code [ 0 ] [ 0 ] ; render -> info . mpeg . f_code [ 0 ] [ 1 ] = s -> mpeg_f_code [ 0 ] [ 1 ] ; render -> info . mpeg . f_code [ 1 ] [ 0 ] = s -> mpeg_f_code [ 1 ] [ 0 ] ; render -> info . mpeg . f_code [ 1 ] [ 1 ] = s -> mpeg_f_code [ 1 ] [ 1 ] ; for ( i = 0 ; i < 64 ; ++ i ) { render -> info . mpeg . intra_quantizer_matrix [ i ] = s -> intra_matrix [ i ] ; render -> info . mpeg . non_intra_quantizer_matrix [ i ] = s -> inter_matrix [ i ] ; } render -> info . mpeg . forward_reference = VDP_INVALID_HANDLE ; render -> info . mpeg . backward_reference = VDP_INVALID_HANDLE ; switch ( s -> pict_type ) { case FF_B_TYPE : next = ( struct vdpau_render_state * ) s -> next_picture . data [ 0 ] ; assert ( next ) ; render -> info . mpeg . backward_reference = next -> surface ; case FF_P_TYPE : last = ( struct vdpau_render_state * ) s -> last_picture . data [ 0 ] ; if ( ! last ) { last = render ; } render -> info . mpeg . forward_reference = last -> surface ; } ff_vdpau_add_data_chunk ( s , buf , buf_size ) ; render -> info . mpeg . slice_count = slice_count ; if ( slice_count ) { ff_draw_horiz_band ( s , 0 , s -> avctx -> height ) ; } render -> bitstream_buffers_used = 0 ; }##::##1##::##7741
static int vmdk_init_tables ( BlockDriverState * bs , VmdkExtent * extent , Error * * errp ) { int ret ; int l1_size , i ; l1_size = extent -> l1_size * sizeof ( uint32_t ) ; extent -> l1_table = g_try_malloc ( l1_size ) ; if ( l1_size && extent -> l1_table == NULL ) { return - ENOMEM ; } ret = bdrv_pread ( extent -> file , extent -> l1_table_offset , extent -> l1_table , l1_size ) ; if ( ret < 0 ) { error_setg_errno ( errp , - ret , "Could not read l1 table from extent '%s'" , extent -> file -> filename ) ; goto fail_l1 ; } for ( i = 0 ; i < extent -> l1_size ; i ++ ) { le32_to_cpus ( & extent -> l1_table [ i ] ) ; } if ( extent -> l1_backup_table_offset ) { extent -> l1_backup_table = g_try_malloc ( l1_size ) ; if ( l1_size && extent -> l1_backup_table == NULL ) { ret = - ENOMEM ; goto fail_l1 ; } ret = bdrv_pread ( extent -> file , extent -> l1_backup_table_offset , extent -> l1_backup_table , l1_size ) ; if ( ret < 0 ) { error_setg_errno ( errp , - ret , "Could not read l1 backup table from extent '%s'" , extent -> file -> filename ) ; goto fail_l1b ; } for ( i = 0 ; i < extent -> l1_size ; i ++ ) { le32_to_cpus ( & extent -> l1_backup_table [ i ] ) ; } } extent -> l2_cache = g_new ( uint32_t , extent -> l2_size * L2_CACHE_SIZE ) ; return 0 ; fail_l1b : g_free ( extent -> l1_backup_table ) ; fail_l1 : g_free ( extent -> l1_table ) ; return ret ; }##::##1##::##11871
int chr_baum_init ( QemuOpts * opts , CharDriverState * * _chr ) { BaumDriverState * baum ; CharDriverState * chr ; brlapi_handle_t * handle ; # ifdef CONFIG_SDL SDL_SysWMinfo info ; # endif int tty ; baum = g_malloc0 ( sizeof ( BaumDriverState ) ) ; baum -> chr = chr = g_malloc0 ( sizeof ( CharDriverState ) ) ; chr -> opaque = baum ; chr -> chr_write = baum_write ; chr -> chr_accept_input = baum_accept_input ; chr -> chr_close = baum_close ; handle = g_malloc0 ( brlapi_getHandleSize ( ) ) ; baum -> brlapi = handle ; baum -> brlapi_fd = brlapi__openConnection ( handle , NULL , NULL ) ; if ( baum -> brlapi_fd == - 1 ) { brlapi_perror ( "baum_init: brlapi_openConnection" ) ; goto fail_handle ; } baum -> cellCount_timer = qemu_new_timer_ns ( vm_clock , baum_cellCount_timer_cb , baum ) ; if ( brlapi__getDisplaySize ( handle , & baum -> x , & baum -> y ) == - 1 ) { brlapi_perror ( "baum_init: brlapi_getDisplaySize" ) ; goto fail ; } # ifdef CONFIG_SDL memset ( & info , 0 , sizeof ( info ) ) ; SDL_VERSION ( & info . version ) ; if ( SDL_GetWMInfo ( & info ) ) { tty = info . info . x11 . wmwindow ; } else # endif tty = BRLAPI_TTY_DEFAULT ; if ( brlapi__enterTtyMode ( handle , tty , NULL ) == - 1 ) { brlapi_perror ( "baum_init: brlapi_enterTtyMode" ) ; goto fail ; } qemu_set_fd_handler ( baum -> brlapi_fd , baum_chr_read , NULL , baum ) ; qemu_chr_generic_open ( chr ) ; * _chr = chr ; return 0 ; fail : qemu_free_timer ( baum -> cellCount_timer ) ; brlapi__closeConnection ( handle ) ; fail_handle : g_free ( handle ) ; g_free ( chr ) ; g_free ( baum ) ; return - EIO ; }##::##1##::##4155
static int wavpack_decode_frame ( AVCodecContext * avctx , void * data , int * data_size , AVPacket * avpkt ) { WavpackContext * s = avctx -> priv_data ; const uint8_t * buf = avpkt -> data ; int buf_size = avpkt -> size ; int frame_size ; int samplecount = 0 ; s -> block = 0 ; s -> samples_left = 0 ; s -> ch_offset = 0 ; if ( s -> mkv_mode ) { s -> samples = AV_RL32 ( buf ) ; buf += 4 ; } while ( buf_size > 0 ) { if ( ! s -> multichannel ) { frame_size = buf_size ; } else { if ( ! s -> mkv_mode ) { frame_size = AV_RL32 ( buf ) - 12 ; buf += 4 ; buf_size -= 4 ; } else { if ( buf_size < 12 ) { break ; } frame_size = AV_RL32 ( buf + 8 ) + 12 ; } } if ( frame_size < 0 || frame_size > buf_size ) { av_log ( avctx , AV_LOG_ERROR , "Block %d has invalid size (size %d vs. %d bytes left)\n" , s -> block , frame_size , buf_size ) ; return - 1 ; } if ( ( samplecount = wavpack_decode_block ( avctx , s -> block , data , data_size , buf , frame_size ) ) < 0 ) { return - 1 ; } s -> block ++ ; buf += frame_size ; buf_size -= frame_size ; } * data_size = samplecount * avctx -> channels ; return s -> samples_left > 0 ? 0 : avpkt -> size ; }##::##1##::##1547
static void targa_decode_rle ( AVCodecContext * avctx , TargaContext * s , const uint8_t * src , uint8_t * dst , int w , int h , int stride , int bpp ) { int i , x , y ; int depth = ( bpp + 1 ) >> 3 ; int type , count ; int diff ; diff = stride - w * depth ; x = y = 0 ; while ( y < h ) { type = * src ++ ; count = ( type & 0x7F ) + 1 ; type &= 0x80 ; if ( ( x + count > w ) && ( x + count + 1 > ( h - y ) * w ) ) { av_log ( avctx , AV_LOG_ERROR , "Packet went out of bounds: position (%i,%i) size %i\n" , x , y , count ) ; return ; } for ( i = 0 ; i < count ; i ++ ) { switch ( depth ) { case 1 : * dst = * src ; break ; case 2 : * ( ( uint16_t * ) dst ) = AV_RL16 ( src ) ; break ; case 3 : dst [ 0 ] = src [ 0 ] ; dst [ 1 ] = src [ 1 ] ; dst [ 2 ] = src [ 2 ] ; break ; case 4 : * ( ( uint32_t * ) dst ) = AV_RL32 ( src ) ; break ; } dst += depth ; if ( ! type ) { src += depth ; } x ++ ; if ( x == w ) { x = 0 ; y ++ ; dst += diff ; } } if ( type ) { src += depth ; } } }##::##1##::##6952
static int skip_check ( MpegEncContext * s , Picture * p , Picture * ref ) { int x , y , plane ; int score = 0 ; int64_t score64 = 0 ; for ( plane = 0 ; plane < 3 ; plane ++ ) { const int stride = p -> f . linesize [ plane ] ; const int bw = plane ? 1 : 2 ; for ( y = 0 ; y < s -> mb_height * bw ; y ++ ) { for ( x = 0 ; x < s -> mb_width * bw ; x ++ ) { int off = p -> shared ? 0 : 16 ; uint8_t * dptr = p -> f . data [ plane ] + 8 * ( x + y * stride ) + off ; uint8_t * rptr = ref -> f . data [ plane ] + 8 * ( x + y * stride ) ; int v = s -> dsp . frame_skip_cmp [ 1 ] ( s , dptr , rptr , stride , 8 ) ; switch ( s -> avctx -> frame_skip_exp ) { case 0 : score = FFMAX ( score , v ) ; break ; case 1 : score += FFABS ( v ) ; break ; case 2 : score += v * v ; break ; case 3 : score64 += FFABS ( v * v * ( int64_t ) v ) ; break ; case 4 : score64 += v * v * ( int64_t ) ( v * v ) ; break ; } } } } if ( score ) { score64 = score ; } if ( score64 < s -> avctx -> frame_skip_threshold ) { return 1 ; } if ( score64 < ( ( s -> avctx -> frame_skip_factor * ( int64_t ) s -> lambda ) >> 8 ) ) { return 1 ; } return 0 ; }##::##1##::##7987
static int sbr_hf_calc_npatches ( AACContext * ac , SpectralBandReplication * sbr ) { int i , k , sb = 0 ; int msb = sbr -> k [ 0 ] ; int usb = sbr -> kx [ 1 ] ; int goal_sb = ( ( 1000 << 11 ) + ( sbr -> sample_rate >> 1 ) ) / sbr -> sample_rate ; sbr -> num_patches = 0 ; if ( goal_sb < sbr -> kx [ 1 ] + sbr -> m [ 1 ] ) { for ( k = 0 ; sbr -> f_master [ k ] < goal_sb ; k ++ ) ; } else { k = sbr -> n_master ; } do { int odd = 0 ; for ( i = k ; i == k || sb > ( sbr -> k [ 0 ] - 1 + msb - odd ) ; i -- ) { sb = sbr -> f_master [ i ] ; odd = ( sb + sbr -> k [ 0 ] ) & 1 ; } sbr -> patch_num_subbands [ sbr -> num_patches ] = FFMAX ( sb - usb , 0 ) ; sbr -> patch_start_subband [ sbr -> num_patches ] = sbr -> k [ 0 ] - odd - sbr -> patch_num_subbands [ sbr -> num_patches ] ; if ( sbr -> patch_num_subbands [ sbr -> num_patches ] > 0 ) { usb = sb ; msb = sb ; sbr -> num_patches ++ ; } else { msb = sbr -> kx [ 1 ] ; } if ( sbr -> f_master [ k ] - sb < 3 ) { k = sbr -> n_master ; } } while ( sb != sbr -> kx [ 1 ] + sbr -> m [ 1 ] ) ; if ( sbr -> patch_num_subbands [ sbr -> num_patches - 1 ] < 3 && sbr -> num_patches > 1 ) { sbr -> num_patches -- ; } if ( sbr -> num_patches > 6 ) { av_log ( ac -> avccontext , AV_LOG_ERROR , "Too many patches: %d\n" , sbr -> num_patches ) ; return - 1 ; } return 0 ; }##::##1##::##9718
SwsFunc ff_yuv2rgb_init_mmx ( SwsContext * c ) { int cpu_flags = av_get_cpu_flags ( ) ; if ( c -> srcFormat != PIX_FMT_YUV420P && c -> srcFormat != PIX_FMT_YUVA420P ) { return NULL ; } if ( HAVE_MMX2 && cpu_flags & AV_CPU_FLAG_MMX2 ) { switch ( c -> dstFormat ) { case PIX_FMT_RGB24 : return yuv420_rgb24_MMX2 ; case PIX_FMT_BGR24 : return yuv420_bgr24_MMX2 ; } } if ( HAVE_MMX && cpu_flags & AV_CPU_FLAG_MMX ) { switch ( c -> dstFormat ) { case PIX_FMT_RGB32 : if ( CONFIG_SWSCALE_ALPHA && c -> srcFormat == PIX_FMT_YUVA420P ) { # if HAVE_7REGS return yuva420_rgb32_MMX ; # endif break ; } else { return yuv420_rgb32_MMX ; } case PIX_FMT_BGR32 : if ( CONFIG_SWSCALE_ALPHA && c -> srcFormat == PIX_FMT_YUVA420P ) { # if HAVE_7REGS return yuva420_bgr32_MMX ; # endif break ; } else { return yuv420_bgr32_MMX ; } case PIX_FMT_RGB24 : return yuv420_rgb24_MMX ; case PIX_FMT_BGR24 : return yuv420_bgr24_MMX ; case PIX_FMT_RGB565 : return yuv420_rgb16_MMX ; case PIX_FMT_RGB555 : return yuv420_rgb15_MMX ; } } return NULL ; }##::##1##::##2120
static int flac_encode_frame ( AVCodecContext * avctx , AVPacket * avpkt , const AVFrame * frame , int * got_packet_ptr ) { FlacEncodeContext * s ; const int16_t * samples ; int frame_bytes , out_bytes , ret ; s = avctx -> priv_data ; if ( ! frame ) { s -> max_framesize = s -> max_encoded_framesize ; av_md5_final ( s -> md5ctx , s -> md5sum ) ; write_streaminfo ( s , avctx -> extradata ) ; return 0 ; } samples = ( const int16_t * ) frame -> data [ 0 ] ; if ( frame -> nb_samples < s -> frame . blocksize ) { s -> max_framesize = ff_flac_get_max_frame_size ( frame -> nb_samples , s -> channels , 16 ) ; } init_frame ( s , frame -> nb_samples ) ; copy_samples ( s , samples ) ; channel_decorrelation ( s ) ; remove_wasted_bits ( s ) ; frame_bytes = encode_frame ( s ) ; if ( frame_bytes > s -> max_framesize ) { s -> frame . verbatim_only = 1 ; frame_bytes = encode_frame ( s ) ; } if ( ( ret = ff_alloc_packet ( avpkt , frame_bytes ) ) ) { av_log ( avctx , AV_LOG_ERROR , "Error getting output packet\n" ) ; return ret ; } out_bytes = write_frame ( s , avpkt ) ; s -> frame_count ++ ; s -> sample_count += frame -> nb_samples ; if ( ( ret = update_md5_sum ( s , samples ) ) < 0 ) { av_log ( avctx , AV_LOG_ERROR , "Error updating MD5 checksum\n" ) ; return ret ; } if ( out_bytes > s -> max_encoded_framesize ) { s -> max_encoded_framesize = out_bytes ; } if ( out_bytes < s -> min_framesize ) { s -> min_framesize = out_bytes ; } avpkt -> pts = frame -> pts ; avpkt -> duration = ff_samples_to_time_base ( avctx , frame -> nb_samples ) ; avpkt -> size = out_bytes ; * got_packet_ptr = 1 ; return 0 ; }##::##1##::##236
static void dwt_encode97_int ( DWTContext * s , int * t ) { int lev , w = s -> linelen [ s -> ndeclevels - 1 ] [ 0 ] ; int * line = s -> i_linebuf ; line += 5 ; for ( lev = s -> ndeclevels - 1 ; lev >= 0 ; lev -- ) { int lh = s -> linelen [ lev ] [ 0 ] , lv = s -> linelen [ lev ] [ 1 ] , mh = s -> mod [ lev ] [ 0 ] , mv = s -> mod [ lev ] [ 1 ] , lp ; int * l ; l = line + mv ; for ( lp = 0 ; lp < lh ; lp ++ ) { int i , j = 0 ; for ( i = 0 ; i < lv ; i ++ ) { l [ i ] = t [ w * i + lp ] ; } sd_1d97_int ( line , mv , mv + lv ) ; for ( i = mv ; i < lv ; i += 2 , j ++ ) { t [ w * j + lp ] = ( ( l [ i ] * I_LFTG_X ) + ( 1 << 16 ) ) >> 17 ; } for ( i = 1 - mv ; i < lv ; i += 2 , j ++ ) { t [ w * j + lp ] = ( ( l [ i ] * I_LFTG_K ) + ( 1 << 16 ) ) >> 17 ; } } l = line + mh ; for ( lp = 0 ; lp < lv ; lp ++ ) { int i , j = 0 ; for ( i = 0 ; i < lh ; i ++ ) { l [ i ] = t [ w * lp + i ] ; } sd_1d97_int ( line , mh , mh + lh ) ; for ( i = mh ; i < lh ; i += 2 , j ++ ) { t [ w * lp + j ] = ( ( l [ i ] * I_LFTG_X ) + ( 1 << 16 ) ) >> 17 ; } for ( i = 1 - mh ; i < lh ; i += 2 , j ++ ) { t [ w * lp + j ] = ( ( l [ i ] * I_LFTG_K ) + ( 1 << 16 ) ) >> 17 ; } } } }##::##1##::##667
void pc_dimm_memory_plug ( DeviceState * dev , MemoryHotplugState * hpms , MemoryRegion * mr , uint64_t align , bool gap , Error * * errp ) { int slot ; MachineState * machine = MACHINE ( qdev_get_machine ( ) ) ; PCDIMMDevice * dimm = PC_DIMM ( dev ) ; Error * local_err = NULL ; uint64_t existing_dimms_capacity = 0 ; uint64_t addr ; addr = object_property_get_int ( OBJECT ( dimm ) , PC_DIMM_ADDR_PROP , & local_err ) ; if ( local_err ) { addr = pc_dimm_get_free_addr ( hpms -> base , memory_region_size ( & hpms -> mr ) , ! addr ? NULL : & addr , align , gap , memory_region_size ( mr ) , & local_err ) ; if ( local_err ) { existing_dimms_capacity = pc_existing_dimms_capacity ( & local_err ) ; if ( local_err ) { if ( existing_dimms_capacity + memory_region_size ( mr ) > machine -> maxram_size - machine -> ram_size ) { error_setg ( & local_err , "not enough space, currently 0x%" PRIx64 " in use of total hot pluggable 0x" RAM_ADDR_FMT , existing_dimms_capacity , machine -> maxram_size - machine -> ram_size ) ; object_property_set_int ( OBJECT ( dev ) , addr , PC_DIMM_ADDR_PROP , & local_err ) ; if ( local_err ) { trace_mhp_pc_dimm_assigned_address ( addr ) ; slot = object_property_get_int ( OBJECT ( dev ) , PC_DIMM_SLOT_PROP , & local_err ) ; if ( local_err ) { slot = pc_dimm_get_free_slot ( slot == PC_DIMM_UNASSIGNED_SLOT ? NULL : & slot , machine -> ram_slots , & local_err ) ; if ( local_err ) { object_property_set_int ( OBJECT ( dev ) , slot , PC_DIMM_SLOT_PROP , & local_err ) ; if ( local_err ) { trace_mhp_pc_dimm_assigned_slot ( slot ) ; if ( kvm_enabled ( ) && ! kvm_has_free_slot ( machine ) ) { error_setg ( & local_err , "hypervisor has no free memory slots left" ) ; memory_region_add_subregion ( & hpms -> mr , addr - hpms -> base , mr ) ; vmstate_register_ram ( mr , dev ) ; numa_set_mem_node_id ( addr , memory_region_size ( mr ) , dimm -> node ) ; out : error_propagate ( errp , local_err ) ;##::##1##::##2887
static void qtrle_decode_32bpp ( QtrleContext * s , int stream_ptr , int row_ptr , int lines_to_change ) { int rle_code ; int pixel_ptr ; int row_inc = s -> frame . linesize [ 0 ] ; unsigned char a , r , g , b ; unsigned int argb ; unsigned char * rgb = s -> frame . data [ 0 ] ; int pixel_limit = s -> frame . linesize [ 0 ] * s -> avctx -> height ; while ( lines_to_change -- ) { CHECK_STREAM_PTR ( 2 ) ; pixel_ptr = row_ptr + ( s -> buf [ stream_ptr ++ ] - 1 ) * 4 ; while ( ( rle_code = ( signed char ) s -> buf [ stream_ptr ++ ] ) != - 1 ) { if ( rle_code == 0 ) { CHECK_STREAM_PTR ( 1 ) ; pixel_ptr += ( s -> buf [ stream_ptr ++ ] - 1 ) * 4 ; } else if ( rle_code < 0 ) { rle_code = - rle_code ; CHECK_STREAM_PTR ( 4 ) ; a = s -> buf [ stream_ptr ++ ] ; r = s -> buf [ stream_ptr ++ ] ; g = s -> buf [ stream_ptr ++ ] ; b = s -> buf [ stream_ptr ++ ] ; argb = ( a << 24 ) | ( r << 16 ) | ( g << 8 ) | ( b << 0 ) ; CHECK_PIXEL_PTR ( rle_code * 4 ) ; while ( rle_code -- ) { * ( unsigned int * ) ( & rgb [ pixel_ptr ] ) = argb ; pixel_ptr += 4 ; } } else { CHECK_STREAM_PTR ( rle_code * 4 ) ; CHECK_PIXEL_PTR ( rle_code * 4 ) ; while ( rle_code -- ) { a = s -> buf [ stream_ptr ++ ] ; r = s -> buf [ stream_ptr ++ ] ; g = s -> buf [ stream_ptr ++ ] ; b = s -> buf [ stream_ptr ++ ] ; argb = ( a << 24 ) | ( r << 16 ) | ( g << 8 ) | ( b << 0 ) ; * ( unsigned int * ) ( & rgb [ pixel_ptr ] ) = argb ; pixel_ptr += 4 ; } } } row_ptr += row_inc ; } }##::##1##::##414
static void mirror_start_job ( const char * job_id , BlockDriverState * bs , BlockDriverState * target , const char * replaces , int64_t speed , uint32_t granularity , int64_t buf_size , BlockMirrorBackingMode backing_mode , BlockdevOnError on_source_error , BlockdevOnError on_target_error , bool unmap , BlockCompletionFunc * cb , void * opaque , Error * * errp , const BlockJobDriver * driver , bool is_none_mode , BlockDriverState * base ) { MirrorBlockJob * s ; if ( granularity == 0 ) { granularity = bdrv_get_default_bitmap_granularity ( target ) ; } assert ( ( granularity & ( granularity - 1 ) ) == 0 ) ; if ( buf_size < 0 ) { error_setg ( errp , "Invalid parameter 'buf-size'" ) ; return ; } if ( buf_size == 0 ) { buf_size = DEFAULT_MIRROR_BUF_SIZE ; } s = block_job_create ( job_id , driver , bs , speed , cb , opaque , errp ) ; if ( ! s ) { return ; } s -> target = blk_new ( ) ; blk_insert_bs ( s -> target , target ) ; s -> replaces = g_strdup ( replaces ) ; s -> on_source_error = on_source_error ; s -> on_target_error = on_target_error ; s -> is_none_mode = is_none_mode ; s -> backing_mode = backing_mode ; s -> base = base ; s -> granularity = granularity ; s -> buf_size = ROUND_UP ( buf_size , granularity ) ; s -> unmap = unmap ; s -> dirty_bitmap = bdrv_create_dirty_bitmap ( bs , granularity , NULL , errp ) ; if ( ! s -> dirty_bitmap ) { g_free ( s -> replaces ) ; blk_unref ( s -> target ) ; block_job_unref ( & s -> common ) ; return ; } bdrv_op_block_all ( target , s -> common . blocker ) ; s -> common . co = qemu_coroutine_create ( mirror_run ) ; trace_mirror_start ( bs , s , s -> common . co , opaque ) ; qemu_coroutine_enter ( s -> common . co , s ) ; }##::##1##::##10454
static void dec_rcsr ( DisasContext * dc ) { LOG_DIS ( "rcsr r%d, %d\n" , dc -> r2 , dc -> csr ) ; switch ( dc -> csr ) { case CSR_IE : tcg_gen_mov_tl ( cpu_R [ dc -> r2 ] , cpu_ie ) ; break ; case CSR_IM : gen_helper_rcsr_im ( cpu_R [ dc -> r2 ] , cpu_env ) ; break ; case CSR_IP : gen_helper_rcsr_ip ( cpu_R [ dc -> r2 ] , cpu_env ) ; break ; case CSR_CC : tcg_gen_mov_tl ( cpu_R [ dc -> r2 ] , cpu_cc ) ; break ; case CSR_CFG : tcg_gen_mov_tl ( cpu_R [ dc -> r2 ] , cpu_cfg ) ; break ; case CSR_EBA : tcg_gen_mov_tl ( cpu_R [ dc -> r2 ] , cpu_eba ) ; break ; case CSR_DC : tcg_gen_mov_tl ( cpu_R [ dc -> r2 ] , cpu_dc ) ; break ; case CSR_DEBA : tcg_gen_mov_tl ( cpu_R [ dc -> r2 ] , cpu_deba ) ; break ; case CSR_JTX : gen_helper_rcsr_jtx ( cpu_R [ dc -> r2 ] , cpu_env ) ; break ; case CSR_JRX : gen_helper_rcsr_jrx ( cpu_R [ dc -> r2 ] , cpu_env ) ; break ; case CSR_ICC : case CSR_DCC : case CSR_BP0 : case CSR_BP1 : case CSR_BP2 : case CSR_BP3 : case CSR_WP0 : case CSR_WP1 : case CSR_WP2 : case CSR_WP3 : cpu_abort ( dc -> env , "invalid read access csr=%x\n" , dc -> csr ) ; break ; default : cpu_abort ( dc -> env , "read_csr: unknown csr=%x\n" , dc -> csr ) ; break ; } }##::##1##::##9349
static av_cold int vdadec_init ( AVCodecContext * avctx ) { VDADecoderContext * ctx = avctx -> priv_data ; struct vda_context * vda_ctx = & ctx -> vda_ctx ; OSStatus status ; int ret ; ctx -> h264_initialized = 0 ; if ( ! ff_h264_vda_decoder . pix_fmts ) { if ( kCFCoreFoundationVersionNumber < kCFCoreFoundationVersionNumber10_7 ) { ff_h264_vda_decoder . pix_fmts = vda_pixfmts_prior_10_7 ; } else { ff_h264_vda_decoder . pix_fmts = vda_pixfmts ; } memset ( vda_ctx , 0 , sizeof ( struct vda_context ) ) ; vda_ctx -> width = avctx -> width ; vda_ctx -> height = avctx -> height ; vda_ctx -> format = 'avc1' ; vda_ctx -> use_sync_decoding = 1 ; vda_ctx -> use_ref_buffer = 1 ; ctx -> pix_fmt = avctx -> get_format ( avctx , avctx -> codec -> pix_fmts ) ; switch ( ctx -> pix_fmt ) { case AV_PIX_FMT_UYVY422 : vda_ctx -> cv_pix_fmt_type = '2vuy' ; break ; case AV_PIX_FMT_YUYV422 : vda_ctx -> cv_pix_fmt_type = 'yuvs' ; break ; case AV_PIX_FMT_NV12 : vda_ctx -> cv_pix_fmt_type = '420v' ; break ; case AV_PIX_FMT_YUV420P : vda_ctx -> cv_pix_fmt_type = 'y420' ; break ; default : av_log ( avctx , AV_LOG_ERROR , "Unsupported pixel format: %d\n" , avctx -> pix_fmt ) ; status = ff_vda_create_decoder ( vda_ctx , avctx -> extradata , avctx -> extradata_size ) ; if ( status != kVDADecoderNoErr ) { av_log ( avctx , AV_LOG_ERROR , "Failed to init VDA decoder: %d.\n" , status ) ; set_context ( avctx ) ; ret = ff_h264_decoder . init ( avctx ) ; restore_context ( avctx ) ; if ( ret < 0 ) { av_log ( avctx , AV_LOG_ERROR , "Failed to open H.264 decoder.\n" ) ; ctx -> h264_initialized = 1 ; return 0 ; failed : vdadec_close ( avctx ) ; return - 1 ;##::##1##::##3879
} while ( 0 ) READ16 ( version ) ; READ16 ( nb_curves ) ; for ( i = 0 ; i < FFMIN ( nb_curves , FF_ARRAY_ELEMS ( comp_ids ) ) ; i ++ ) { int nb_points , n ; av_bprint_clear ( & ptstr ) ; READ16 ( nb_points ) ; for ( n = 0 ; n < nb_points ; n ++ ) { int y , x ; READ16 ( y ) ; READ16 ( x ) ; av_bprintf ( & ptstr , "%f/%f " , x / 255. , y / 255. ) ; } if ( * ptstr . str ) { char * * pts = & curves -> comp_points_str [ comp_ids [ i ] ] ; if ( ! * pts ) { * pts = av_strdup ( ptstr . str ) ; av_log ( ctx , AV_LOG_DEBUG , "curves %d (intid=%d) [%d points]: [%s]\n" , i , comp_ids [ i ] , nb_points , * pts ) ; if ( ! * pts ) { ret = AVERROR ( ENOMEM ) ; goto end ; } } } } end : av_bprint_finalize ( & ptstr , NULL ) ; av_file_unmap ( buf , size ) ; return ret ; }##::##1##::##6503
int attribute_align_arg avcodec_decode_audio4 ( AVCodecContext * avctx , AVFrame * frame , int * got_frame_ptr , AVPacket * avpkt ) { AVCodecInternal * avci = avctx -> internal ; int planar , channels ; int ret = 0 ; * got_frame_ptr = 0 ; avctx -> pkt = avpkt ; if ( ! avpkt -> data && avpkt -> size ) { av_log ( avctx , AV_LOG_ERROR , "invalid packet: NULL data, size != 0\n" ) ; return AVERROR ( EINVAL ) ; } apply_param_change ( avctx , avpkt ) ; avcodec_get_frame_defaults ( frame ) ; if ( ! avctx -> refcounted_frames ) { av_frame_unref ( & avci -> to_free ) ; } if ( ( avctx -> codec -> capabilities & CODEC_CAP_DELAY ) || avpkt -> size ) { ret = avctx -> codec -> decode ( avctx , frame , got_frame_ptr , avpkt ) ; if ( ret >= 0 && * got_frame_ptr ) { avctx -> frame_number ++ ; frame -> pkt_dts = avpkt -> dts ; if ( frame -> format == AV_SAMPLE_FMT_NONE ) { frame -> format = avctx -> sample_fmt ; } if ( ! avctx -> refcounted_frames ) { avci -> to_free = * frame ; avci -> to_free . extended_data = avci -> to_free . data ; memset ( frame -> buf , 0 , sizeof ( frame -> buf ) ) ; frame -> extended_buf = NULL ; frame -> nb_extended_buf = 0 ; } } if ( ret < 0 && frame -> data [ 0 ] ) { av_frame_unref ( frame ) ; } } planar = av_sample_fmt_is_planar ( frame -> format ) ; channels = av_get_channel_layout_nb_channels ( frame -> channel_layout ) ; if ( ! ( planar && channels > AV_NUM_DATA_POINTERS ) ) { frame -> extended_data = frame -> data ; } return ret ; }##::##1##::##8657
static int smacker_decode_bigtree ( GetBitContext * gb , HuffContext * hc , DBCtx * ctx ) { if ( hc -> current + 1 >= hc -> length ) { av_log ( NULL , AV_LOG_ERROR , "Tree size exceeded!\n" ) ; return AVERROR_INVALIDDATA ; } if ( ! get_bits1 ( gb ) ) { int val , i1 , i2 ; i1 = ctx -> v1 -> table ? get_vlc2 ( gb , ctx -> v1 -> table , SMKTREE_BITS , 3 ) : 0 ; i2 = ctx -> v2 -> table ? get_vlc2 ( gb , ctx -> v2 -> table , SMKTREE_BITS , 3 ) : 0 ; if ( i1 < 0 || i2 < 0 ) { return AVERROR_INVALIDDATA ; } val = ctx -> recode1 [ i1 ] | ( ctx -> recode2 [ i2 ] << 8 ) ; if ( val == ctx -> escapes [ 0 ] ) { ctx -> last [ 0 ] = hc -> current ; val = 0 ; } else if ( val == ctx -> escapes [ 1 ] ) { ctx -> last [ 1 ] = hc -> current ; val = 0 ; } else if ( val == ctx -> escapes [ 2 ] ) { ctx -> last [ 2 ] = hc -> current ; val = 0 ; } hc -> values [ hc -> current ++ ] = val ; return 1 ; } else { int r = 0 , r_new , t ; t = hc -> current ++ ; r = smacker_decode_bigtree ( gb , hc , ctx ) ; if ( r < 0 ) { return r ; } hc -> values [ t ] = SMK_NODE | r ; r ++ ; r_new = smacker_decode_bigtree ( gb , hc , ctx ) ; if ( r_new < 0 ) { return r_new ; } return r + r_new ; } }##::##1##::##10329
static void decode_rlc_opc ( CPUTriCoreState * env , DisasContext * ctx , uint32_t op1 ) { int32_t const16 ; int r1 , r2 ; const16 = MASK_OP_RLC_CONST16_SEXT ( ctx -> opcode ) ; r1 = MASK_OP_RLC_S1 ( ctx -> opcode ) ; r2 = MASK_OP_RLC_D ( ctx -> opcode ) ; switch ( op1 ) { case OPC1_32_RLC_ADDI : gen_addi_d ( cpu_gpr_d [ r2 ] , cpu_gpr_d [ r1 ] , const16 ) ; break ; case OPC1_32_RLC_ADDIH : gen_addi_d ( cpu_gpr_d [ r2 ] , cpu_gpr_d [ r1 ] , const16 << 16 ) ; break ; case OPC1_32_RLC_ADDIH_A : tcg_gen_addi_tl ( cpu_gpr_a [ r2 ] , cpu_gpr_a [ r1 ] , const16 << 16 ) ; break ; case OPC1_32_RLC_MFCR : const16 = MASK_OP_RLC_CONST16 ( ctx -> opcode ) ; gen_mfcr ( env , cpu_gpr_d [ r2 ] , const16 ) ; break ; case OPC1_32_RLC_MOV : tcg_gen_movi_tl ( cpu_gpr_d [ r2 ] , const16 ) ; break ; case OPC1_32_RLC_MOV_64 : if ( tricore_feature ( env , TRICORE_FEATURE_16 ) ) { if ( ( r2 & 0x1 ) != 0 ) { } tcg_gen_movi_tl ( cpu_gpr_d [ r2 ] , const16 ) ; tcg_gen_movi_tl ( cpu_gpr_d [ r2 + 1 ] , const16 >> 15 ) ; } else { } break ; case OPC1_32_RLC_MOV_U : const16 = MASK_OP_RLC_CONST16 ( ctx -> opcode ) ; tcg_gen_movi_tl ( cpu_gpr_d [ r2 ] , const16 ) ; break ; case OPC1_32_RLC_MOV_H : tcg_gen_movi_tl ( cpu_gpr_d [ r2 ] , const16 << 16 ) ; break ; case OPC1_32_RLC_MOVH_A : tcg_gen_movi_tl ( cpu_gpr_a [ r2 ] , const16 << 16 ) ; break ; case OPC1_32_RLC_MTCR : const16 = MASK_OP_RLC_CONST16 ( ctx -> opcode ) ; gen_mtcr ( env , ctx , cpu_gpr_d [ r1 ] , const16 ) ; break ; } }##::##1##::##733
static inline void RENAME ( yuv2yuvX ) ( int16_t * lumFilter , int16_t * * lumSrc , int lumFilterSize , int16_t * chrFilter , int16_t * * chrSrc , int chrFilterSize , uint8_t * dest , uint8_t * uDest , uint8_t * vDest , int dstW , int16_t * lumMmxFilter , int16_t * chrMmxFilter ) { # ifdef HAVE_MMX if ( uDest != NULL ) { asm volatile ( YSCALEYUV2YV12X ( 0 ) :: "m" ( - chrFilterSize ) , "r" ( chrSrc + chrFilterSize ) , "r" ( chrMmxFilter + chrFilterSize * 4 ) , "r" ( uDest ) , "m" ( dstW >> 1 ) : "%eax" , "%edx" , "%esi" ) ; asm volatile ( YSCALEYUV2YV12X ( 4096 ) :: "m" ( - chrFilterSize ) , "r" ( chrSrc + chrFilterSize ) , "r" ( chrMmxFilter + chrFilterSize * 4 ) , "r" ( vDest ) , "m" ( dstW >> 1 ) : "%eax" , "%edx" , "%esi" ) ; } asm volatile ( YSCALEYUV2YV12X ( 0 ) :: "m" ( - lumFilterSize ) , "r" ( lumSrc + lumFilterSize ) , "r" ( lumMmxFilter + lumFilterSize * 4 ) , "r" ( dest ) , "m" ( dstW ) : "%eax" , "%edx" , "%esi" ) ; # else int i ; for ( i = 0 ; i < dstW ; i ++ ) { int val = 0 ; int j ; for ( j = 0 ; j < lumFilterSize ; j ++ ) { val += lumSrc [ j ] [ i ] * lumFilter [ j ] ; } dest [ i ] = MIN ( MAX ( val >> 19 , 0 ) , 255 ) ; } if ( uDest != NULL ) for ( i = 0 ; i < ( dstW >> 1 ) ; i ++ ) { int u = 0 ; int v = 0 ; int j ; for ( j = 0 ; j < lumFilterSize ; j ++ ) { u += chrSrc [ j ] [ i ] * chrFilter [ j ] ; v += chrSrc [ j ] [ i + 2048 ] * chrFilter [ j ] ; } uDest [ i ] = MIN ( MAX ( u >> 19 , 0 ) , 255 ) ; vDest [ i ] = MIN ( MAX ( v >> 19 , 0 ) , 255 ) ; } # endif }##::##1##::##643
static void bdrv_query_info ( BlockBackend * blk , BlockInfo * * p_info , Error * * errp ) { BlockInfo * info = g_malloc0 ( sizeof ( * info ) ) ; BlockDriverState * bs = blk_bs ( blk ) ; BlockDriverState * bs0 ; ImageInfo * * p_image_info ; Error * local_err = NULL ; info -> device = g_strdup ( blk_name ( blk ) ) ; info -> type = g_strdup ( "unknown" ) ; info -> locked = blk_dev_is_medium_locked ( blk ) ; info -> removable = blk_dev_has_removable_media ( blk ) ; if ( blk_dev_has_removable_media ( blk ) ) { info -> has_tray_open = true ; info -> tray_open = blk_dev_is_tray_open ( blk ) ; } if ( bdrv_iostatus_is_enabled ( bs ) ) { info -> has_io_status = true ; info -> io_status = bs -> iostatus ; } if ( ! QLIST_EMPTY ( & bs -> dirty_bitmaps ) ) { info -> has_dirty_bitmaps = true ; info -> dirty_bitmaps = bdrv_query_dirty_bitmaps ( bs ) ; } if ( bs -> drv ) { info -> has_inserted = true ; info -> inserted = bdrv_block_device_info ( bs ) ; bs0 = bs ; p_image_info = & info -> inserted -> image ; while ( 1 ) { bdrv_query_image_info ( bs0 , p_image_info , & local_err ) ; if ( local_err ) { error_propagate ( errp , local_err ) ; goto err ; } if ( bs0 -> drv && bs0 -> backing_hd ) { bs0 = bs0 -> backing_hd ; ( * p_image_info ) -> has_backing_image = true ; p_image_info = & ( ( * p_image_info ) -> backing_image ) ; } else { break ; } } } * p_info = info ; return ; err : qapi_free_BlockInfo ( info ) ; }##::##1##::##10316
static int decode_init_mp3on4 ( AVCodecContext * avctx ) { MP3On4DecodeContext * s = avctx -> priv_data ; MPEG4AudioConfig cfg ; int i ; if ( ( avctx -> extradata_size < 2 ) || ( avctx -> extradata == NULL ) ) { av_log ( avctx , AV_LOG_ERROR , "Codec extradata missing or too short.\n" ) ; return - 1 ; } avpriv_mpeg4audio_get_config ( & cfg , avctx -> extradata , avctx -> extradata_size ) ; if ( ! cfg . chan_config || cfg . chan_config > 7 ) { av_log ( avctx , AV_LOG_ERROR , "Invalid channel config number.\n" ) ; return - 1 ; } s -> frames = mp3Frames [ cfg . chan_config ] ; s -> coff = chan_offset [ cfg . chan_config ] ; avctx -> channels = ff_mpeg4audio_channels [ cfg . chan_config ] ; avctx -> channel_layout = chan_layout [ cfg . chan_config ] ; if ( cfg . sample_rate < 16000 ) { s -> syncword = 0xffe00000 ; } else { s -> syncword = 0xfff00000 ; } s -> mp3decctx [ 0 ] = av_mallocz ( sizeof ( MPADecodeContext ) ) ; avctx -> priv_data = s -> mp3decctx [ 0 ] ; decode_init ( avctx ) ; avctx -> priv_data = s ; s -> mp3decctx [ 0 ] -> adu_mode = 1 ; for ( i = 1 ; i < s -> frames ; i ++ ) { s -> mp3decctx [ i ] = av_mallocz ( sizeof ( MPADecodeContext ) ) ; if ( ! s -> mp3decctx [ i ] ) { s -> mp3decctx [ i ] -> adu_mode = 1 ; } s -> mp3decctx [ i ] -> avctx = avctx ; s -> mp3decctx [ i ] -> mpadsp = s -> mp3decctx [ 0 ] -> mpadsp ; } if ( s -> frames > 1 ) { s -> decoded_buf = av_malloc ( MPA_FRAME_SIZE * MPA_MAX_CHANNELS * sizeof ( * s -> decoded_buf ) ) ; if ( ! s -> decoded_buf ) } return 0 ; alloc_fail : decode_close_mp3on4 ( avctx ) ; return AVERROR ( ENOMEM ) ; }##::##1##::##6698
static void av_update_stream_timings ( AVFormatContext * ic ) { int64_t start_time , start_time1 , end_time , end_time1 ; int64_t duration , duration1 ; int i ; AVStream * st ; start_time = INT64_MAX ; end_time = INT64_MIN ; duration = INT64_MIN ; for ( i = 0 ; i < ic -> nb_streams ; i ++ ) { st = ic -> streams [ i ] ; if ( st -> start_time != AV_NOPTS_VALUE ) { start_time1 = av_rescale_q ( st -> start_time , st -> time_base , AV_TIME_BASE_Q ) ; if ( start_time1 < start_time ) { start_time = start_time1 ; } if ( st -> duration != AV_NOPTS_VALUE ) { end_time1 = start_time1 + av_rescale_q ( st -> duration , st -> time_base , AV_TIME_BASE_Q ) ; if ( end_time1 > end_time ) { end_time = end_time1 ; } } } if ( st -> duration != AV_NOPTS_VALUE ) { duration1 = av_rescale_q ( st -> duration , st -> time_base , AV_TIME_BASE_Q ) ; if ( duration1 > duration ) { duration = duration1 ; } } } if ( start_time != INT64_MAX ) { ic -> start_time = start_time ; if ( end_time != INT64_MIN ) { if ( end_time - start_time > duration ) { duration = end_time - start_time ; } } } if ( duration != INT64_MIN ) { ic -> duration = duration ; if ( ic -> file_size > 0 ) { ic -> bit_rate = ( double ) ic -> file_size * 8.0 * AV_TIME_BASE / ( double ) ic -> duration ; } } }##::##1##::##10453
static void sdl_audio_callback ( void * opaque , Uint8 * stream , int len ) { VideoState * is = opaque ; int audio_size , len1 , silence = 0 ; audio_callback_time = av_gettime_relative ( ) ; while ( len > 0 ) { if ( is -> audio_buf_index >= is -> audio_buf_size ) { audio_size = audio_decode_frame ( is ) ; if ( audio_size < 0 ) { silence = 1 ; is -> audio_buf_size = SDL_AUDIO_MIN_BUFFER_SIZE / is -> audio_tgt . frame_size * is -> audio_tgt . frame_size ; } else { if ( is -> show_mode != SHOW_MODE_VIDEO ) { update_sample_display ( is , ( int16_t * ) is -> audio_buf , audio_size ) ; } is -> audio_buf_size = audio_size ; } is -> audio_buf_index = 0 ; } len1 = is -> audio_buf_size - is -> audio_buf_index ; if ( len1 > len ) { len1 = len ; } if ( ! is -> muted && ! silence && is -> audio_volume == SDL_MIX_MAXVOLUME ) { memcpy ( stream , ( uint8_t * ) is -> audio_buf + is -> audio_buf_index , len1 ) ; } else { memset ( stream , 0 , len1 ) ; if ( ! is -> muted && ! silence ) { SDL_MixAudio ( stream , ( uint8_t * ) is -> audio_buf + is -> audio_buf_index , len1 , is -> audio_volume ) ; } } len -= len1 ; stream += len1 ; is -> audio_buf_index += len1 ; } is -> audio_write_buf_size = is -> audio_buf_size - is -> audio_buf_index ; if ( ! isnan ( is -> audio_clock ) ) { set_clock_at ( & is -> audclk , is -> audio_clock - ( double ) ( 2 * is -> audio_hw_buf_size + is -> audio_write_buf_size ) / is -> audio_tgt . bytes_per_sec , is -> audio_clock_serial , audio_callback_time / 1000000.0 ) ; sync_clock_to_slave ( & is -> extclk , & is -> audclk ) ; } }##::##1##::##10823
static int vhost_user_set_mem_table ( struct vhost_dev * dev , struct vhost_memory * mem ) { int fds [ VHOST_MEMORY_MAX_NREGIONS ] ; int i , fd ; size_t fd_num = 0 ; bool reply_supported = virtio_has_feature ( dev -> protocol_features , VHOST_USER_PROTOCOL_F_REPLY_ACK ) ; VhostUserMsg msg = { . hdr . request = VHOST_USER_SET_MEM_TABLE , . hdr . flags = VHOST_USER_VERSION , } ; if ( reply_supported ) { msg . hdr . flags |= VHOST_USER_NEED_REPLY_MASK ; } for ( i = 0 ; i < dev -> mem -> nregions ; ++ i ) { struct vhost_memory_region * reg = dev -> mem -> regions + i ; ram_addr_t offset ; MemoryRegion * mr ; assert ( ( uintptr_t ) reg -> userspace_addr == reg -> userspace_addr ) ; mr = memory_region_from_host ( ( void * ) ( uintptr_t ) reg -> userspace_addr , & offset ) ; fd = memory_region_get_fd ( mr ) ; if ( fd > 0 ) { msg . payload . memory . regions [ fd_num ] . userspace_addr = reg -> userspace_addr ; msg . payload . memory . regions [ fd_num ] . memory_size = reg -> memory_size ; msg . payload . memory . regions [ fd_num ] . guest_phys_addr = reg -> guest_phys_addr ; msg . payload . memory . regions [ fd_num ] . mmap_offset = offset ; assert ( fd_num < VHOST_MEMORY_MAX_NREGIONS ) ; fds [ fd_num ++ ] = fd ; } } msg . payload . memory . nregions = fd_num ; if ( ! fd_num ) { error_report ( "Failed initializing vhost-user memory map, " "consider using -object memory-backend-file share=on" ) ; return - 1 ; } msg . hdr . size = sizeof ( msg . payload . memory . nregions ) ; msg . hdr . size += sizeof ( msg . payload . memory . padding ) ; msg . hdr . size += fd_num * sizeof ( VhostUserMemoryRegion ) ; if ( vhost_user_write ( dev , & msg , fds , fd_num ) < 0 ) { return - 1 ; } if ( reply_supported ) { return process_message_reply ( dev , & msg ) ; } return 0 ; }##::##1##::##7296
static int vhdx_log_read_desc ( BlockDriverState * bs , BDRVVHDXState * s , VHDXLogEntries * log , VHDXLogDescEntries * * buffer , bool convert_endian ) { int ret = 0 ; uint32_t desc_sectors ; uint32_t sectors_read ; VHDXLogEntryHeader hdr ; VHDXLogDescEntries * desc_entries = NULL ; VHDXLogDescriptor desc ; int i ; assert ( * buffer == NULL ) ; ret = vhdx_log_peek_hdr ( bs , log , & hdr ) ; if ( ret < 0 ) { goto exit ; } if ( vhdx_log_hdr_is_valid ( log , & hdr , s ) == false ) { ret = - EINVAL ; goto exit ; } desc_sectors = vhdx_compute_desc_sectors ( hdr . descriptor_count ) ; desc_entries = qemu_blockalign ( bs , desc_sectors * VHDX_LOG_SECTOR_SIZE ) ; ret = vhdx_log_read_sectors ( bs , log , & sectors_read , desc_entries , desc_sectors , false ) ; if ( ret < 0 ) { goto free_and_exit ; } if ( sectors_read != desc_sectors ) { ret = - EINVAL ; goto free_and_exit ; } for ( i = 0 ; i < hdr . descriptor_count ; i ++ ) { desc = desc_entries -> desc [ i ] ; vhdx_log_desc_le_import ( & desc ) ; if ( convert_endian ) { desc_entries -> desc [ i ] = desc ; } if ( vhdx_log_desc_is_valid ( & desc , & hdr ) == false ) { ret = - EINVAL ; goto free_and_exit ; } } if ( convert_endian ) { desc_entries -> hdr = hdr ; } * buffer = desc_entries ; goto exit ; free_and_exit : qemu_vfree ( desc_entries ) ; exit : return ret ; }##::##1##::##2589
static int device_open ( AVFormatContext * ctx ) { struct v4l2_capability cap ; int fd ; # if CONFIG_LIBV4L2 int fd_libv4l ; # endif int res , err ; int flags = O_RDWR ; if ( ctx -> flags & AVFMT_FLAG_NONBLOCK ) { flags |= O_NONBLOCK ; } fd = v4l2_open ( ctx -> filename , flags , 0 ) ; if ( fd < 0 ) { err = errno ; av_log ( ctx , AV_LOG_ERROR , "Cannot open video device %s : %s\n" , ctx -> filename , strerror ( err ) ) ; return AVERROR ( err ) ; } # if CONFIG_LIBV4L2 fd_libv4l = v4l2_fd_open ( fd , 0 ) ; if ( fd < 0 ) { err = AVERROR ( errno ) ; av_log ( ctx , AV_LOG_ERROR , "Cannot open video device with libv4l neither %s : %s\n" , ctx -> filename , strerror ( errno ) ) ; return err ; } fd = fd_libv4l ; # endif res = v4l2_ioctl ( fd , VIDIOC_QUERYCAP , & cap ) ; if ( res < 0 ) { err = errno ; av_log ( ctx , AV_LOG_ERROR , "ioctl(VIDIOC_QUERYCAP): %s\n" , strerror ( err ) ) ; goto fail ; } av_log ( ctx , AV_LOG_VERBOSE , "[%d]Capabilities: %x\n" , fd , cap . capabilities ) ; if ( ! ( cap . capabilities & V4L2_CAP_VIDEO_CAPTURE ) ) { av_log ( ctx , AV_LOG_ERROR , "Not a video capture device.\n" ) ; err = ENODEV ; goto fail ; } if ( ! ( cap . capabilities & V4L2_CAP_STREAMING ) ) { av_log ( ctx , AV_LOG_ERROR , "The device does not support the streaming I/O method.\n" ) ; err = ENOSYS ; goto fail ; } return fd ; fail : v4l2_close ( fd ) ; return AVERROR ( err ) ; }##::##1##::##8852
static void smp_parse ( QemuOpts * opts ) { if ( opts ) { unsigned cpus = qemu_opt_get_number ( opts , "cpus" , 0 ) ; unsigned sockets = qemu_opt_get_number ( opts , "sockets" , 0 ) ; unsigned cores = qemu_opt_get_number ( opts , "cores" , 0 ) ; unsigned threads = qemu_opt_get_number ( opts , "threads" , 0 ) ; if ( cpus == 0 || sockets == 0 ) { sockets = sockets > 0 ? sockets : 1 ; cores = cores > 0 ? cores : 1 ; threads = threads > 0 ? threads : 1 ; if ( cpus == 0 ) { cpus = cores * threads * sockets ; } } else if ( cores == 0 ) { threads = threads > 0 ? threads : 1 ; cores = cpus / ( sockets * threads ) ; } else if ( threads == 0 ) { threads = cpus / ( cores * sockets ) ; } else if ( sockets * cores * threads < cpus ) { fprintf ( stderr , "cpu topology: error: " "sockets (%u) * cores (%u) * threads (%u) < " "smp_cpus (%u)\n" , sockets , cores , threads , cpus ) ; exit ( 1 ) ; } max_cpus = qemu_opt_get_number ( opts , "maxcpus" , 0 ) ; smp_cpus = cpus ; smp_cores = cores > 0 ? cores : 1 ; smp_threads = threads > 0 ? threads : 1 ; } if ( max_cpus == 0 ) { max_cpus = smp_cpus ; } if ( max_cpus > MAX_CPUMASK_BITS ) { fprintf ( stderr , "Unsupported number of maxcpus\n" ) ; exit ( 1 ) ; } if ( max_cpus < smp_cpus ) { fprintf ( stderr , "maxcpus must be equal to or greater than smp\n" ) ; exit ( 1 ) ; } }##::##1##::##2100
static void mc_block ( uint8_t * dst , uint8_t * src , uint8_t * tmp , int stride , int b_w , int b_h , int dx , int dy ) { int x , y ; START_TIMER for ( y = 0 ; y < b_h + 5 ; y ++ ) { for ( x = 0 ; x < b_w ; x ++ ) { int a0 = src [ x ] ; int a1 = src [ x + 1 ] ; int a2 = src [ x + 2 ] ; int a3 = src [ x + 3 ] ; int a4 = src [ x + 4 ] ; int a5 = src [ x + 5 ] ; int am = 20 * ( a2 + a3 ) - 5 * ( a1 + a4 ) + ( a0 + a5 ) ; if ( dx < 8 ) { tmp [ x ] = ( 32 * a2 * ( 8 - dx ) + am * dx + 128 ) >> 8 ; } else { tmp [ x ] = ( am * ( 16 - dx ) + 32 * a3 * ( dx - 8 ) + 128 ) >> 8 ; } } tmp += stride ; src += stride ; } tmp -= ( b_h + 5 ) * stride ; for ( y = 0 ; y < b_h ; y ++ ) { for ( x = 0 ; x < b_w ; x ++ ) { int a0 = tmp [ x + 0 * stride ] ; int a1 = tmp [ x + 1 * stride ] ; int a2 = tmp [ x + 2 * stride ] ; int a3 = tmp [ x + 3 * stride ] ; int a4 = tmp [ x + 4 * stride ] ; int a5 = tmp [ x + 5 * stride ] ; int am = 20 * ( a2 + a3 ) - 5 * ( a1 + a4 ) + ( a0 + a5 ) ; if ( dy < 8 ) { dst [ x ] = ( 32 * a2 * ( 8 - dy ) + am * dy + 128 ) >> 8 ; } else { dst [ x ] = ( am * ( 16 - dy ) + 32 * a3 * ( dy - 8 ) + 128 ) >> 8 ; } } dst += stride ; tmp += stride ; } STOP_TIMER ( "mc_block" ) }##::##1##::##1576
static int lag_decode_zero_run_line ( LagarithContext * l , uint8_t * dst , const uint8_t * src , const uint8_t * src_end , int width , int esc_count ) { int i = 0 ; int count ; uint8_t zero_run = 0 ; const uint8_t * src_start = src ; uint8_t mask1 = - ( esc_count < 2 ) ; uint8_t mask2 = - ( esc_count < 3 ) ; uint8_t * end = dst + ( width - 2 ) ; avpriv_request_sample ( l -> avctx , "zero_run_line" ) ; return AVERROR_PATCHWELCOME ; output_zeros : if ( l -> zeros_rem ) { count = FFMIN ( l -> zeros_rem , width - i ) ; if ( end - dst < count ) { av_log ( l -> avctx , AV_LOG_ERROR , "Too many zeros remaining.\n" ) ; return AVERROR_INVALIDDATA ; } memset ( dst , 0 , count ) ; l -> zeros_rem -= count ; dst += count ; } while ( dst < end ) { i = 0 ; while ( ! zero_run && dst + i < end ) { i ++ ; if ( i + 2 >= src_end - src ) { return AVERROR_INVALIDDATA ; } zero_run = ! ( src [ i ] | ( src [ i + 1 ] & mask1 ) | ( src [ i + 2 ] & mask2 ) ) ; } if ( zero_run ) { zero_run = 0 ; i += esc_count ; memcpy ( dst , src , i ) ; dst += i ; l -> zeros_rem = lag_calc_zero_run ( src [ i ] ) ; src += i + 1 ; goto output_zeros ; } else { memcpy ( dst , src , i ) ; src += i ; dst += i ; } } return src - src_start ; }##::##1##::##346
static void gmc_motion ( MpegEncContext * s , uint8_t * dest_y , uint8_t * dest_cb , uint8_t * dest_cr , uint8_t * * ref_picture ) { uint8_t * ptr ; int linesize , uvlinesize ; const int a = s -> sprite_warping_accuracy ; int ox , oy ; linesize = s -> linesize ; uvlinesize = s -> uvlinesize ; ptr = ref_picture [ 0 ] ; ox = s -> sprite_offset [ 0 ] [ 0 ] + s -> sprite_delta [ 0 ] [ 0 ] * s -> mb_x * 16 + s -> sprite_delta [ 0 ] [ 1 ] * s -> mb_y * 16 ; oy = s -> sprite_offset [ 0 ] [ 1 ] + s -> sprite_delta [ 1 ] [ 0 ] * s -> mb_x * 16 + s -> sprite_delta [ 1 ] [ 1 ] * s -> mb_y * 16 ; s -> mdsp . gmc ( dest_y , ptr , linesize , 16 , ox , oy , s -> sprite_delta [ 0 ] [ 0 ] , s -> sprite_delta [ 0 ] [ 1 ] , s -> sprite_delta [ 1 ] [ 0 ] , s -> sprite_delta [ 1 ] [ 1 ] , a + 1 , ( 1 << ( 2 * a + 1 ) ) - s -> no_rounding , s -> h_edge_pos , s -> v_edge_pos ) ; s -> mdsp . gmc ( dest_y + 8 , ptr , linesize , 16 , ox + s -> sprite_delta [ 0 ] [ 0 ] * 8 , oy + s -> sprite_delta [ 1 ] [ 0 ] * 8 , s -> sprite_delta [ 0 ] [ 0 ] , s -> sprite_delta [ 0 ] [ 1 ] , s -> sprite_delta [ 1 ] [ 0 ] , s -> sprite_delta [ 1 ] [ 1 ] , a + 1 , ( 1 << ( 2 * a + 1 ) ) - s -> no_rounding , s -> h_edge_pos , s -> v_edge_pos ) ; if ( CONFIG_GRAY && s -> flags & CODEC_FLAG_GRAY ) { return ; } ox = s -> sprite_offset [ 1 ] [ 0 ] + s -> sprite_delta [ 0 ] [ 0 ] * s -> mb_x * 8 + s -> sprite_delta [ 0 ] [ 1 ] * s -> mb_y * 8 ; oy = s -> sprite_offset [ 1 ] [ 1 ] + s -> sprite_delta [ 1 ] [ 0 ] * s -> mb_x * 8 + s -> sprite_delta [ 1 ] [ 1 ] * s -> mb_y * 8 ; ptr = ref_picture [ 1 ] ; s -> mdsp . gmc ( dest_cb , ptr , uvlinesize , 8 , ox , oy , s -> sprite_delta [ 0 ] [ 0 ] , s -> sprite_delta [ 0 ] [ 1 ] , s -> sprite_delta [ 1 ] [ 0 ] , s -> sprite_delta [ 1 ] [ 1 ] , a + 1 , ( 1 << ( 2 * a + 1 ) ) - s -> no_rounding , s -> h_edge_pos >> 1 , s -> v_edge_pos >> 1 ) ; ptr = ref_picture [ 2 ] ; s -> mdsp . gmc ( dest_cr , ptr , uvlinesize , 8 , ox , oy , s -> sprite_delta [ 0 ] [ 0 ] , s -> sprite_delta [ 0 ] [ 1 ] , s -> sprite_delta [ 1 ] [ 0 ] , s -> sprite_delta [ 1 ] [ 1 ] , a + 1 , ( 1 << ( 2 * a + 1 ) ) - s -> no_rounding , s -> h_edge_pos >> 1 , s -> v_edge_pos >> 1 ) ; }##::##1##::##2270
static inline void mcdc ( uint16_t * dst , uint16_t * src , int log2w , int h , int stride , int scale , int dc ) { int i ; dc *= 0x10001 ; switch ( log2w ) { case 0 : for ( i = 0 ; i < h ; i ++ ) { dst [ 0 ] = scale * src [ 0 ] + dc ; if ( scale ) { src += stride ; } dst += stride ; } break ; case 1 : for ( i = 0 ; i < h ; i ++ ) { LE_CENTRIC_MUL ( dst , src , scale , dc ) ; if ( scale ) { src += stride ; } dst += stride ; } break ; case 2 : for ( i = 0 ; i < h ; i ++ ) { LE_CENTRIC_MUL ( dst , src , scale , dc ) ; LE_CENTRIC_MUL ( dst + 2 , src + 2 , scale , dc ) ; if ( scale ) { src += stride ; } dst += stride ; } break ; case 3 : for ( i = 0 ; i < h ; i ++ ) { LE_CENTRIC_MUL ( dst , src , scale , dc ) ; LE_CENTRIC_MUL ( dst + 2 , src + 2 , scale , dc ) ; LE_CENTRIC_MUL ( dst + 4 , src + 4 , scale , dc ) ; LE_CENTRIC_MUL ( dst + 6 , src + 6 , scale , dc ) ; if ( scale ) { src += stride ; } dst += stride ; } break ; default : assert ( 0 ) ; } }##::##1##::##4968
