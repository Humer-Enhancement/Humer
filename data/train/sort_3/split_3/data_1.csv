s##::##label##::##id
int boot_sector_init ( const char * fname ) { FILE * f = fopen ( fname , "w" ) ; size_t len = sizeof boot_sector ; if ( ! f ) { fprintf ( stderr , "Couldn't open \"%s\": %s" , fname , strerror ( errno ) ) ; return 1 ; } if ( strcmp ( qtest_get_arch ( ) , "ppc64" ) == 0 ) { len = sprintf ( ( char * ) boot_sector , "\\ Bootscript\n%x %x c! %x %x c!\n" , LOW ( SIGNATURE ) , BOOT_SECTOR_ADDRESS + SIGNATURE_OFFSET , HIGH ( SIGNATURE ) , BOOT_SECTOR_ADDRESS + SIGNATURE_OFFSET + 1 ) ; } fwrite ( boot_sector , 1 , len , f ) ; fclose ( f ) ; return 0 ; }##::##1##::##1089
static void qcow2_close ( BlockDriverState * bs ) { BDRVQcowState * s = bs -> opaque ; g_free ( s -> l1_table ) ; s -> l1_table = NULL ; if ( ! ( bs -> open_flags & BDRV_O_INCOMING ) ) { qcow2_cache_flush ( bs , s -> l2_table_cache ) ; qcow2_cache_flush ( bs , s -> refcount_block_cache ) ; qcow2_mark_clean ( bs ) ; } qcow2_cache_destroy ( bs , s -> l2_table_cache ) ; qcow2_cache_destroy ( bs , s -> refcount_block_cache ) ; g_free ( s -> unknown_header_fields ) ; cleanup_unknown_header_ext ( bs ) ; g_free ( s -> cluster_cache ) ; qemu_vfree ( s -> cluster_data ) ; qcow2_refcount_close ( bs ) ; qcow2_free_snapshots ( bs ) ; }##::##1##::##4961
static void init_excp_4xx_real ( CPUPPCState * env ) { # if ! defined ( CONFIG_USER_ONLY ) env -> excp_vectors [ POWERPC_EXCP_CRITICAL ] = 0x00000100 ; env -> excp_vectors [ POWERPC_EXCP_MCHECK ] = 0x00000200 ; env -> excp_vectors [ POWERPC_EXCP_EXTERNAL ] = 0x00000500 ; env -> excp_vectors [ POWERPC_EXCP_ALIGN ] = 0x00000600 ; env -> excp_vectors [ POWERPC_EXCP_PROGRAM ] = 0x00000700 ; env -> excp_vectors [ POWERPC_EXCP_SYSCALL ] = 0x00000C00 ; env -> excp_vectors [ POWERPC_EXCP_PIT ] = 0x00001000 ; env -> excp_vectors [ POWERPC_EXCP_FIT ] = 0x00001010 ; env -> excp_vectors [ POWERPC_EXCP_WDT ] = 0x00001020 ; env -> excp_vectors [ POWERPC_EXCP_DEBUG ] = 0x00002000 ; env -> excp_prefix = 0x00000000 ; env -> ivor_mask = 0x0000FFF0 ; env -> ivpr_mask = 0xFFFF0000 ; env -> hreset_vector = 0xFFFFFFFCUL ; # endif }##::##1##::##322
static void openpic_src_write ( void * opaque , hwaddr addr , uint64_t val , unsigned len ) { OpenPICState * opp = opaque ; int idx ; DPRINTF ( "%s: addr %08x <= %08x\n" , __func__ , addr , val ) ; if ( addr & 0xF ) { return ; } addr = addr & 0xFFF0 ; idx = addr >> 5 ; if ( addr & 0x10 ) { write_IRQreg_ide ( opp , idx , val ) ; } else { write_IRQreg_ipvp ( opp , idx , val ) ; } }##::##1##::##9607
static void parse_type_number ( Visitor * v , const char * name , double * obj , Error * * errp ) { StringInputVisitor * siv = to_siv ( v ) ; char * endp = ( char * ) siv -> string ; double val ; errno = 0 ; if ( siv -> string ) { val = strtod ( siv -> string , & endp ) ; } if ( ! siv -> string || errno || endp == siv -> string || * endp ) { error_setg ( errp , QERR_INVALID_PARAMETER_TYPE , name ? name : "null" , "number" ) ; return ; } * obj = val ; }##::##1##::##7507
int qemu_devtree_add_subnode ( void * fdt , const char * name ) { int offset ; char * dupname = g_strdup ( name ) ; char * basename = strrchr ( dupname , '/' ) ; int retval ; if ( ! basename ) { return - 1 ; } basename [ 0 ] = '\0' ; basename ++ ; offset = fdt_path_offset ( fdt , dupname ) ; if ( offset < 0 ) { return offset ; } retval = fdt_add_subnode ( fdt , offset , basename ) ; g_free ( dupname ) ; return retval ; }##::##1##::##1332
static void test_qga_fsfreeze_and_thaw ( gconstpointer fix ) { const TestFixture * fixture = fix ; QDict * ret ; const gchar * status ; ret = qmp_fd ( fixture -> fd , "{'execute': 'guest-fsfreeze-freeze'}" ) ; g_assert_nonnull ( ret ) ; qmp_assert_no_error ( ret ) ; QDECREF ( ret ) ; ret = qmp_fd ( fixture -> fd , "{'execute': 'guest-fsfreeze-status'}" ) ; g_assert_nonnull ( ret ) ; qmp_assert_no_error ( ret ) ; status = qdict_get_try_str ( ret , "return" ) ; g_assert_cmpstr ( status , == , "frozen" ) ; QDECREF ( ret ) ; ret = qmp_fd ( fixture -> fd , "{'execute': 'guest-fsfreeze-thaw'}" ) ; g_assert_nonnull ( ret ) ; qmp_assert_no_error ( ret ) ; QDECREF ( ret ) ; }##::##1##::##11912
static void fw_cfg_realize ( DeviceState * dev , Error * * errp ) { FWCfgState * s = FW_CFG ( dev ) ; SysBusDevice * sbd = SYS_BUS_DEVICE ( dev ) ; if ( s -> ctl_iobase + 1 == s -> data_iobase ) { sysbus_add_io ( sbd , s -> ctl_iobase , & s -> comb_iomem ) ; } else { if ( s -> ctl_iobase ) { sysbus_add_io ( sbd , s -> ctl_iobase , & s -> ctl_iomem ) ; } if ( s -> data_iobase ) { sysbus_add_io ( sbd , s -> data_iobase , & s -> data_iomem ) ; } } }##::##1##::##723
static int av_thread_message_queue_send_locked ( AVThreadMessageQueue * mq , void * msg , unsigned flags ) { while ( ! mq -> err_send && av_fifo_space ( mq -> fifo ) < mq -> elsize ) { if ( ( flags & AV_THREAD_MESSAGE_NONBLOCK ) ) { return AVERROR ( EAGAIN ) ; } pthread_cond_wait ( & mq -> cond , & mq -> lock ) ; } if ( mq -> err_send ) { return mq -> err_send ; } av_fifo_generic_write ( mq -> fifo , msg , mq -> elsize , NULL ) ; pthread_cond_signal ( & mq -> cond ) ; return 0 ; }##::##1##::##8950
yuv2planeX_16_c_template ( const int16_t * filter , int filterSize , const int32_t * * src , uint16_t * dest , int dstW , int big_endian , int output_bits ) { int i ; int shift = 15 ; av_assert0 ( output_bits == 16 ) ; for ( i = 0 ; i < dstW ; i ++ ) { int val = 1 << ( shift - 1 ) ; int j ; val -= 0x40000000 ; for ( j = 0 ; j < filterSize ; j ++ ) { val += src [ j ] [ i ] * filter [ j ] ; } output_pixel ( & dest [ i ] , val , 0x8000 , int ) ; } }##::##1##::##11456
static int kvm_handle_debug ( PowerPCCPU * cpu , struct kvm_run * run ) { CPUState * cs = CPU ( cpu ) ; CPUPPCState * env = & cpu -> env ; struct kvm_debug_exit_arch * arch_info = & run -> debug . arch ; int handle = 0 ; if ( kvm_find_sw_breakpoint ( cs , arch_info -> address ) ) { handle = 1 ; } else { cpu_synchronize_state ( cs ) ; env -> nip += 4 ; cs -> exception_index = POWERPC_EXCP_PROGRAM ; env -> error_code = POWERPC_EXCP_INVAL ; ppc_cpu_do_interrupt ( cs ) ; } return handle ; }##::##1##::##5549
static int create_shared_memory_BAR ( IVShmemState * s , int fd , uint8_t attr , Error * * errp ) { void * ptr ; ptr = mmap ( 0 , s -> ivshmem_size , PROT_READ | PROT_WRITE , MAP_SHARED , fd , 0 ) ; if ( ptr == MAP_FAILED ) { error_setg_errno ( errp , errno , "Failed to mmap shared memory" ) ; return - 1 ; } s -> shm_fd = fd ; memory_region_init_ram_ptr ( & s -> ivshmem , OBJECT ( s ) , "ivshmem.bar2" , s -> ivshmem_size , ptr ) ; vmstate_register_ram ( & s -> ivshmem , DEVICE ( s ) ) ; memory_region_add_subregion ( & s -> bar , 0 , & s -> ivshmem ) ; pci_register_bar ( PCI_DEVICE ( s ) , 2 , attr , & s -> bar ) ; return 0 ; }##::##1##::##7402
void helper_ocbi ( CPUSH4State * env , uint32_t address ) { memory_content * * current = & ( env -> movcal_backup ) ; while ( * current ) { uint32_t a = ( * current ) -> address ; if ( ( a & ~ 0x1F ) == ( address & ~ 0x1F ) ) { memory_content * next = ( * current ) -> next ; cpu_stl_data ( env , a , ( * current ) -> value ) ; if ( next == NULL ) { env -> movcal_backup_tail = current ; } free ( * current ) ; * current = next ; break ; } } }##::##1##::##240
BlockJobInfoList * qmp_query_block_jobs ( Error * * errp ) { BlockJobInfoList * head = NULL , * * p_next = & head ; BlockDriverState * bs ; BdrvNextIterator * it = NULL ; while ( ( it = bdrv_next ( it , & bs ) ) ) { AioContext * aio_context = bdrv_get_aio_context ( bs ) ; aio_context_acquire ( aio_context ) ; if ( bs -> job ) { BlockJobInfoList * elem = g_new0 ( BlockJobInfoList , 1 ) ; elem -> value = block_job_query ( bs -> job ) ; * p_next = elem ; p_next = & elem -> next ; } aio_context_release ( aio_context ) ; } return head ; }##::##1##::##11349
static void update_msix_table_msg_data ( S390PCIBusDevice * pbdev , uint64_t offset , uint64_t * data , uint8_t len ) { uint32_t val ; uint8_t * msg_data ; if ( offset % PCI_MSIX_ENTRY_SIZE != 8 ) { return ; } if ( len != 4 ) { DPRINTF ( "access msix table msg data but len is %d\n" , len ) ; return ; } msg_data = ( uint8_t * ) data - offset % PCI_MSIX_ENTRY_SIZE + PCI_MSIX_ENTRY_VECTOR_CTRL ; val = pci_get_long ( msg_data ) | ( pbdev -> fid << ZPCI_MSI_VEC_BITS ) ; pci_set_long ( msg_data , val ) ; DPRINTF ( "update msix msg_data to 0x%" PRIx64 "\n" , * data ) ; }##::##1##::##4037
static int mm_start_timer ( struct qemu_alarm_timer * t ) { TIMECAPS tc ; memset ( & tc , 0 , sizeof ( tc ) ) ; timeGetDevCaps ( & tc , sizeof ( tc ) ) ; mm_period = tc . wPeriodMin ; timeBeginPeriod ( mm_period ) ; mm_timer = timeSetEvent ( 1 , mm_period , mm_alarm_handler , ( DWORD_PTR ) t , TIME_ONESHOT | TIME_CALLBACK_FUNCTION ) ; if ( ! mm_timer ) { fprintf ( stderr , "Failed to initialize win32 alarm timer: %ld\n" , GetLastError ( ) ) ; timeEndPeriod ( mm_period ) ; return - 1 ; } return 0 ; }##::##1##::##11676
static UHCIQueue * uhci_queue_get ( UHCIState * s , UHCI_TD * td , USBEndpoint * ep ) { uint32_t token = uhci_queue_token ( td ) ; UHCIQueue * queue ; QTAILQ_FOREACH ( queue , & s -> queues , next ) { if ( queue -> token == token ) { return queue ; } } queue = g_new0 ( UHCIQueue , 1 ) ; queue -> uhci = s ; queue -> token = token ; queue -> ep = ep ; QTAILQ_INIT ( & queue -> asyncs ) ; QTAILQ_INSERT_HEAD ( & s -> queues , queue , next ) ; trace_usb_uhci_queue_add ( queue -> token ) ; return queue ; }##::##1##::##2862
static void pci_edu_realize ( PCIDevice * pdev , Error * * errp ) { EduState * edu = DO_UPCAST ( EduState , pdev , pdev ) ; uint8_t * pci_conf = pdev -> config ; timer_init_ms ( & edu -> dma_timer , QEMU_CLOCK_VIRTUAL , edu_dma_timer , edu ) ; qemu_mutex_init ( & edu -> thr_mutex ) ; qemu_cond_init ( & edu -> thr_cond ) ; qemu_thread_create ( & edu -> thread , "edu" , edu_fact_thread , edu , QEMU_THREAD_JOINABLE ) ; pci_config_set_interrupt_pin ( pci_conf , 1 ) ; if ( msi_init ( pdev , 0 , 1 , true , false , errp ) ) { return ; } memory_region_init_io ( & edu -> mmio , OBJECT ( edu ) , & edu_mmio_ops , edu , "edu-mmio" , 1 << 20 ) ; pci_register_bar ( pdev , 0 , PCI_BASE_ADDRESS_SPACE_MEMORY , & edu -> mmio ) ; }##::##1##::##10598
static void ecc_reset ( void * opaque ) { ECCState * s = opaque ; int i ; s -> regs [ ECC_MER ] &= ( ECC_MER_VER | ECC_MER_IMPL ) ; s -> regs [ ECC_MER ] |= ECC_MER_MRR ; s -> regs [ ECC_MDR ] = 0x20 ; s -> regs [ ECC_MFSR ] = 0 ; s -> regs [ ECC_VCR ] = 0 ; s -> regs [ ECC_MFAR0 ] = 0x07c00000 ; s -> regs [ ECC_MFAR1 ] = 0 ; s -> regs [ ECC_DR ] = 0 ; s -> regs [ ECC_ECR0 ] = 0 ; s -> regs [ ECC_ECR1 ] = 0 ; for ( i = 1 ; i < ECC_NREGS ; i ++ ) { s -> regs [ i ] = 0 ; } }##::##1##::##4369
static uint32_t m5206_mbar_readb ( void * opaque , target_phys_addr_t offset ) { m5206_mbar_state * s = ( m5206_mbar_state * ) opaque ; offset &= 0x3ff ; if ( offset > 0x200 ) { hw_error ( "Bad MBAR read offset 0x%x" , ( int ) offset ) ; } if ( m5206_mbar_width [ offset >> 2 ] > 1 ) { uint16_t val ; val = m5206_mbar_readw ( opaque , offset & ~ 1 ) ; if ( ( offset & 1 ) == 0 ) { val >>= 8 ; } return val & 0xff ; } return m5206_mbar_read ( s , offset , 1 ) ; }##::##1##::##8843
VIOsPAPRBus * spapr_vio_bus_init ( void ) { VIOsPAPRBus * bus ; BusState * qbus ; DeviceState * dev ; dev = qdev_create ( NULL , "spapr-vio-bridge" ) ; qdev_init_nofail ( dev ) ; qbus = qbus_create ( TYPE_SPAPR_VIO_BUS , dev , "spapr-vio" ) ; bus = DO_UPCAST ( VIOsPAPRBus , bus , qbus ) ; bus -> next_reg = 0x1000 ; spapr_register_hypercall ( H_VIO_SIGNAL , h_vio_signal ) ; spapr_register_hypercall ( H_PUT_TCE , h_put_tce ) ; spapr_register_hypercall ( H_REG_CRQ , h_reg_crq ) ; spapr_register_hypercall ( H_FREE_CRQ , h_free_crq ) ; spapr_register_hypercall ( H_SEND_CRQ , h_send_crq ) ; spapr_register_hypercall ( H_ENABLE_CRQ , h_enable_crq ) ; spapr_rtas_register ( "ibm,set-tce-bypass" , rtas_set_tce_bypass ) ; spapr_rtas_register ( "quiesce" , rtas_quiesce ) ; return bus ; }##::##1##::##1439
static int coroutine_fn bdrv_co_do_readv ( BlockDriverState * bs , int64_t sector_num , int nb_sectors , QEMUIOVector * qiov ) { BlockDriver * drv = bs -> drv ; BdrvTrackedRequest req ; int ret ; if ( ! drv ) { return - ENOMEDIUM ; if ( bdrv_check_request ( bs , sector_num , nb_sectors ) ) { return - EIO ; if ( bs -> io_limits_enabled ) { bdrv_io_limits_intercept ( bs , false , nb_sectors ) ; tracked_request_begin ( & req , bs , sector_num , nb_sectors , false ) ; ret = drv -> bdrv_co_readv ( bs , sector_num , nb_sectors , qiov ) ; tracked_request_end ( & req ) ; return ret ;##::##1##::##5226
void ff_prores_idct ( DCTELEM * block , const int16_t * qmat ) { int i ; for ( i = 0 ; i < 64 ; i ++ ) { block [ i ] *= qmat [ i ] ; } for ( i = 0 ; i < 8 ; i ++ ) { idctRowCondDC_10 ( block + i * 8 ) ; } for ( i = 0 ; i < 64 ; i ++ ) { block [ i ] >>= 2 ; } for ( i = 0 ; i < 8 ; i ++ ) { idctSparseCol_10 ( block + i ) ; } }##::##1##::##9959
static void migrate_fd_cancel ( MigrationState * s ) { int old_state ; QEMUFile * f = migrate_get_current ( ) -> to_dst_file ; trace_migrate_fd_cancel ( ) ; if ( s -> rp_state . from_dst_file ) { qemu_file_shutdown ( s -> rp_state . from_dst_file ) ; do { old_state = s -> state ; if ( ! migration_is_setup_or_active ( old_state ) ) { break ; migrate_set_state ( & s -> state , old_state , MIGRATION_STATUS_CANCELLING ) ; } while ( s -> state != MIGRATION_STATUS_CANCELLING ) ; if ( s -> state == MIGRATION_STATUS_CANCELLING && f ) { qemu_file_shutdown ( f ) ;##::##1##::##9572
static void cleanup_infolist ( CommandLineParameterInfoList * head ) { CommandLineParameterInfoList * pre_entry , * cur , * del_entry ; cur = head ; while ( cur -> next ) { pre_entry = head ; while ( pre_entry != cur -> next ) { if ( ! strcmp ( pre_entry -> value -> name , cur -> next -> value -> name ) ) { del_entry = cur -> next ; cur -> next = cur -> next -> next ; g_free ( del_entry ) ; break ; } pre_entry = pre_entry -> next ; } cur = cur -> next ; } }##::##1##::##1848
int ff_cmap_read_palette ( AVCodecContext * avctx , uint32_t * pal ) { int count , i ; if ( avctx -> bits_per_coded_sample > 8 ) { av_log ( avctx , AV_LOG_ERROR , "bit_per_coded_sample > 8 not supported\n" ) ; return AVERROR_INVALIDDATA ; } count = 1 << avctx -> bits_per_coded_sample ; if ( avctx -> extradata_size < count * 3 ) { av_log ( avctx , AV_LOG_ERROR , "palette data underflow\n" ) ; return AVERROR_INVALIDDATA ; } for ( i = 0 ; i < count ; i ++ ) { pal [ i ] = 0xFF000000 | AV_RB24 ( avctx -> extradata + i * 3 ) ; } return 0 ; }##::##1##::##9406
static void cdg_load_palette ( CDGraphicsContext * cc , uint8_t * data , int low ) { uint8_t r , g , b ; uint16_t color ; int i ; int array_offset = low ? 0 : 8 ; uint32_t * palette = ( uint32_t * ) cc -> frame . data [ 1 ] ; for ( i = 0 ; i < 8 ; i ++ ) { color = ( data [ 2 * i ] << 6 ) + ( data [ 2 * i + 1 ] & 0x3F ) ; r = ( ( color >> 8 ) & 0x000F ) * 17 ; g = ( ( color >> 4 ) & 0x000F ) * 17 ; b = ( ( color ) & 0x000F ) * 17 ; palette [ i + array_offset ] = 0xFF << 24 | r << 16 | g << 8 | b ; } cc -> frame . palette_has_changed = 1 ; }##::##1##::##5115
static int spapr_cpu_core_realize_child ( Object * child , void * opaque ) { Error * * errp = opaque , * local_err = NULL ; sPAPRMachineState * spapr = SPAPR_MACHINE ( qdev_get_machine ( ) ) ; CPUState * cs = CPU ( child ) ; PowerPCCPU * cpu = POWERPC_CPU ( cs ) ; object_property_set_bool ( child , true , "realized" , & local_err ) ; if ( local_err ) { error_propagate ( errp , local_err ) ; return 1 ; } spapr_cpu_init ( spapr , cpu , & local_err ) ; if ( local_err ) { error_propagate ( errp , local_err ) ; return 1 ; } return 0 ; }##::##1##::##6772
int ff_vaapi_mpeg_end_frame ( AVCodecContext * avctx ) { struct vaapi_context * const vactx = avctx -> hwaccel_context ; MpegEncContext * s = avctx -> priv_data ; int ret ; ret = ff_vaapi_commit_slices ( vactx ) ; if ( ret < 0 ) { goto finish ; } ret = ff_vaapi_render_picture ( vactx , ff_vaapi_get_surface_id ( & s -> current_picture_ptr -> f ) ) ; if ( ret < 0 ) { goto finish ; } ff_mpeg_draw_horiz_band ( s , 0 , s -> avctx -> height ) ; finish : ff_vaapi_common_end_frame ( avctx ) ; return ret ; }##::##1##::##8992
static void init_excp_601 ( CPUPPCState * env ) { # if ! defined ( CONFIG_USER_ONLY ) env -> excp_vectors [ POWERPC_EXCP_RESET ] = 0x00000100 ; env -> excp_vectors [ POWERPC_EXCP_MCHECK ] = 0x00000200 ; env -> excp_vectors [ POWERPC_EXCP_DSI ] = 0x00000300 ; env -> excp_vectors [ POWERPC_EXCP_ISI ] = 0x00000400 ; env -> excp_vectors [ POWERPC_EXCP_EXTERNAL ] = 0x00000500 ; env -> excp_vectors [ POWERPC_EXCP_ALIGN ] = 0x00000600 ; env -> excp_vectors [ POWERPC_EXCP_PROGRAM ] = 0x00000700 ; env -> excp_vectors [ POWERPC_EXCP_FPU ] = 0x00000800 ; env -> excp_vectors [ POWERPC_EXCP_DECR ] = 0x00000900 ; env -> excp_vectors [ POWERPC_EXCP_IO ] = 0x00000A00 ; env -> excp_vectors [ POWERPC_EXCP_SYSCALL ] = 0x00000C00 ; env -> excp_vectors [ POWERPC_EXCP_RUNM ] = 0x00002000 ; env -> excp_prefix = 0xFFF00000 ; env -> hreset_vector = 0x00000100UL ; # endif }##::##1##::##9099
static void socket_sendf ( int fd , const char * fmt , va_list ap ) { gchar * str ; size_t size , offset ; str = g_strdup_vprintf ( fmt , ap ) ; size = strlen ( str ) ; offset = 0 ; while ( offset < size ) { ssize_t len ; len = write ( fd , str + offset , size - offset ) ; if ( len == - 1 && errno == EINTR ) { continue ; } g_assert_no_errno ( len ) ; g_assert_cmpint ( len , > , 0 ) ; offset += len ; } }##::##1##::##1978
static BlockAIOCB * read_quorum_children ( QuorumAIOCB * acb ) { BDRVQuorumState * s = acb -> common . bs -> opaque ; int i ; for ( i = 0 ; i < s -> num_children ; i ++ ) { acb -> qcrs [ i ] . buf = qemu_blockalign ( s -> children [ i ] -> bs , acb -> qiov -> size ) ; qemu_iovec_init ( & acb -> qcrs [ i ] . qiov , acb -> qiov -> niov ) ; qemu_iovec_clone ( & acb -> qcrs [ i ] . qiov , acb -> qiov , acb -> qcrs [ i ] . buf ) ; } for ( i = 0 ; i < s -> num_children ; i ++ ) { bdrv_aio_readv ( s -> children [ i ] -> bs , acb -> sector_num , & acb -> qcrs [ i ] . qiov , acb -> nb_sectors , quorum_aio_cb , & acb -> qcrs [ i ] ) ; } return & acb -> common ; }##::##1##::##10765
void stream_start ( BlockDriverState * bs , BlockDriverState * base , const char * backing_file_str , int64_t speed , BlockdevOnError on_error , BlockCompletionFunc * cb , void * opaque , Error * * errp ) { StreamBlockJob * s ; s = block_job_create ( & stream_job_driver , bs , speed , cb , opaque , errp ) ; if ( ! s ) { return ; } s -> base = base ; s -> backing_file_str = g_strdup ( backing_file_str ) ; s -> on_error = on_error ; s -> common . co = qemu_coroutine_create ( stream_run ) ; trace_stream_start ( bs , base , s , s -> common . co , opaque ) ; qemu_coroutine_enter ( s -> common . co , s ) ; }##::##1##::##9783
static void qobject_input_type_str ( Visitor * v , const char * name , char * * obj , Error * * errp ) { QObjectInputVisitor * qiv = to_qiv ( v ) ; QObject * qobj = qobject_input_get_object ( qiv , name , true , errp ) ; QString * qstr ; * obj = NULL ; if ( ! qobj ) { return ; } qstr = qobject_to_qstring ( qobj ) ; if ( ! qstr ) { error_setg ( errp , QERR_INVALID_PARAMETER_TYPE , name ? name : "null" , "string" ) ; return ; } * obj = g_strdup ( qstring_get_str ( qstr ) ) ; }##::##1##::##9131
void do_subfzeo ( void ) { T1 = T0 ; T0 = ~ T0 + xer_ca ; if ( likely ( ! ( ( ~ T1 ^ ( - 1 ) ) & ( ( ~ T1 ) ^ T0 ) & ( 1 << 31 ) ) ) ) { xer_ov = 0 ; } else { xer_ov = 1 ; xer_so = 1 ; } if ( likely ( T0 >= ~ T1 ) ) { xer_ca = 0 ; } else { xer_ca = 1 ; } }##::##1##::##6482
void do_subfco ( void ) { T2 = T0 ; T0 = T1 - T0 ; if ( likely ( T0 > T1 ) ) { xer_ca = 0 ; } else { xer_ca = 1 ; } if ( likely ( ! ( ( ( ~ T2 ) ^ T1 ^ ( - 1 ) ) & ( ( ~ T2 ) ^ T0 ) & ( 1 << 31 ) ) ) ) { xer_ov = 0 ; } else { xer_so = 1 ; xer_ov = 1 ; } }##::##1##::##8885
static int object_create ( QemuOpts * opts , void * opaque ) { const char * type = qemu_opt_get ( opts , "qom-type" ) ; const char * id = qemu_opts_id ( opts ) ; Object * obj ; g_assert ( type != NULL ) ; if ( id == NULL ) { qerror_report ( QERR_MISSING_PARAMETER , "id" ) ; return - 1 ; } obj = object_new ( type ) ; if ( qemu_opt_foreach ( opts , object_set_property , obj , 1 ) < 0 ) { return - 1 ; } object_property_add_child ( container_get ( object_get_root ( ) , "/objects" ) , id , obj , NULL ) ; return 0 ; }##::##1##::##6665
static int seqvideo_decode_frame ( AVCodecContext * avctx , void * data , int * data_size , AVPacket * avpkt ) { const uint8_t * buf = avpkt -> data ; int buf_size = avpkt -> size ; SeqVideoContext * seq = avctx -> priv_data ; seq -> frame . reference = 1 ; seq -> frame . buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE ; if ( avctx -> reget_buffer ( avctx , & seq -> frame ) ) { av_log ( seq -> avctx , AV_LOG_ERROR , "tiertexseqvideo: reget_buffer() failed\n" ) ; return - 1 ; } seqvideo_decode ( seq , buf , buf_size ) ; * data_size = sizeof ( AVFrame ) ; * ( AVFrame * ) data = seq -> frame ; return buf_size ; }##::##1##::##8847
static void rtsp_cmd_pause ( HTTPContext * c , const char * url , RTSPHeader * h ) { HTTPContext * rtp_c ; rtp_c = find_rtp_session_with_url ( url , h -> session_id ) ; if ( ! rtp_c ) { rtsp_reply_error ( c , RTSP_STATUS_SESSION ) ; return ; } if ( rtp_c -> state != HTTPSTATE_SEND_DATA && rtp_c -> state != HTTPSTATE_WAIT_FEED ) { rtsp_reply_error ( c , RTSP_STATUS_STATE ) ; return ; } rtp_c -> state = HTTPSTATE_READY ; rtsp_reply_header ( c , RTSP_STATUS_OK ) ; url_fprintf ( c -> pb , "Session: %s\r\n" , rtp_c -> session_id ) ; url_fprintf ( c -> pb , "\r\n" ) ; }##::##1##::##7802
static void test_dispatch_cmd_failure ( void ) { QDict * req = qdict_new ( ) ; QObject * resp ; qdict_put_obj ( req , "execute" , QOBJECT ( qstring_from_str ( "user_def_cmd2" ) ) ) ; resp = qmp_dispatch ( QOBJECT ( req ) ) ; assert ( resp != NULL ) ; assert ( qdict_haskey ( qobject_to_qdict ( resp ) , "error" ) ) ; qobject_decref ( resp ) ; QDECREF ( req ) ; req = qdict_new ( ) ; qdict_put ( args , "a" , qint_from_int ( 66 ) ) ; qdict_put ( req , "arguments" , args ) ; qdict_put_obj ( req , "execute" , QOBJECT ( qstring_from_str ( "user_def_cmd" ) ) ) ; resp = qmp_dispatch ( QOBJECT ( req ) ) ; assert ( resp != NULL ) ; assert ( qdict_haskey ( qobject_to_qdict ( resp ) , "error" ) ) ; qobject_decref ( resp ) ; QDECREF ( req ) ; }##::##1##::##11210
void ff_put_pixels_clamped_c ( const DCTELEM * block , uint8_t * restrict pixels , int line_size ) { int i ; uint8_t * cm = ff_cropTbl + MAX_NEG_CROP ; for ( i = 0 ; i < 8 ; i ++ ) { pixels [ 0 ] = cm [ block [ 0 ] ] ; pixels [ 1 ] = cm [ block [ 1 ] ] ; pixels [ 2 ] = cm [ block [ 2 ] ] ; pixels [ 3 ] = cm [ block [ 3 ] ] ; pixels [ 4 ] = cm [ block [ 4 ] ] ; pixels [ 5 ] = cm [ block [ 5 ] ] ; pixels [ 6 ] = cm [ block [ 6 ] ] ; pixels [ 7 ] = cm [ block [ 7 ] ] ; pixels += line_size ; block += 8 ; } }##::##1##::##6224
static int mov_parse_stsd_data ( MOVContext * c , AVIOContext * pb , AVStream * st , MOVStreamContext * sc , int size ) { if ( st -> codec -> codec_tag == MKTAG ( 't' , 'm' , 'c' , 'd' ) ) { st -> codec -> extradata_size = size ; st -> codec -> extradata = av_malloc ( size + FF_INPUT_BUFFER_PADDING_SIZE ) ; if ( ! st -> codec -> extradata ) { return AVERROR ( ENOMEM ) ; } avio_read ( pb , st -> codec -> extradata , size ) ; } else { avio_skip ( pb , size ) ; } return 0 ; }##::##1##::##10181
static void glfs_clear_preopened ( glfs_t * fs ) { ListElement * entry = NULL ; if ( fs == NULL ) { return ; } QLIST_FOREACH ( entry , & glfs_list , list ) { if ( entry -> saved . fs == fs ) { if ( -- entry -> saved . ref ) { return ; } QLIST_REMOVE ( entry , list ) ; glfs_fini ( entry -> saved . fs ) ; g_free ( entry -> saved . volume ) ; g_free ( entry ) ; } } }##::##1##::##7302
static av_cold int amr_wb_encode_init ( AVCodecContext * avctx ) { AMRWBContext * s = avctx -> priv_data ; if ( avctx -> sample_rate != 16000 ) { av_log ( avctx , AV_LOG_ERROR , "Only 16000Hz sample rate supported\n" ) ; return AVERROR ( ENOSYS ) ; } if ( avctx -> channels != 1 ) { av_log ( avctx , AV_LOG_ERROR , "Only mono supported\n" ) ; return AVERROR ( ENOSYS ) ; } s -> mode = get_wb_bitrate_mode ( avctx -> bit_rate , avctx ) ; s -> last_bitrate = avctx -> bit_rate ; avctx -> frame_size = 320 ; avctx -> coded_frame = avcodec_alloc_frame ( ) ; s -> state = E_IF_init ( ) ; return 0 ; }##::##1##::##7058
static void jpeg2000_dec_cleanup ( Jpeg2000DecoderContext * s ) { int tileno , compno ; for ( tileno = 0 ; tileno < s -> numXtiles * s -> numYtiles ; tileno ++ ) { if ( s -> tile [ tileno ] . comp ) { for ( compno = 0 ; compno < s -> ncomponents ; compno ++ ) { Jpeg2000Component * comp = s -> tile [ tileno ] . comp + compno ; Jpeg2000CodingStyle * codsty = s -> tile [ tileno ] . codsty + compno ; ff_jpeg2000_cleanup ( comp , codsty ) ; } av_freep ( & s -> tile [ tileno ] . comp ) ; } } av_freep ( & s -> tile ) ; s -> numXtiles = s -> numYtiles = 0 ; }##::##1##::##5509
static void dec_store ( DisasContext * dc ) { TCGv t , * addr ; unsigned int size ; size = 1 << ( dc -> opcode & 3 ) ; LOG_DIS ( "s%d%s\n" , size , dc -> type_b ? "i" : "" ) ; t_sync_flags ( dc ) ; sync_jmpstate ( dc ) ; addr = compute_ldst_addr ( dc , & t ) ; if ( ( dc -> env -> pvr . regs [ 2 ] & PVR2_UNALIGNED_EXC_MASK ) && size > 1 ) { gen_helper_memalign ( * addr , tcg_const_tl ( dc -> rd ) , tcg_const_tl ( 1 ) , tcg_const_tl ( size - 1 ) ) ; gen_store ( dc , * addr , cpu_R [ dc -> rd ] , size ) ; if ( addr == & t ) { tcg_temp_free ( t ) ; }##::##1##::##4856
static void gen_dcread ( DisasContext * ctx ) { # if defined ( CONFIG_USER_ONLY ) gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_OPC ) ; # else TCGv EA , val ; if ( unlikely ( ctx -> pr ) ) { gen_inval_exception ( ctx , POWERPC_EXCP_PRIV_OPC ) ; return ; } gen_set_access_type ( ctx , ACCESS_CACHE ) ; EA = tcg_temp_new ( ) ; gen_addr_reg_index ( ctx , EA ) ; val = tcg_temp_new ( ) ; gen_qemu_ld32u ( ctx , val , EA ) ; tcg_temp_free ( val ) ; tcg_gen_mov_tl ( cpu_gpr [ rD ( ctx -> opcode ) ] , EA ) ; tcg_temp_free ( EA ) ; # endif }##::##1##::##9290
void bdrv_detach_aio_context ( BlockDriverState * bs ) { BdrvAioNotifier * baf ; BdrvChild * child ; if ( ! bs -> drv ) { return ; } QLIST_FOREACH ( baf , & bs -> aio_notifiers , list ) { baf -> detach_aio_context ( baf -> opaque ) ; } if ( bs -> drv -> bdrv_detach_aio_context ) { bs -> drv -> bdrv_detach_aio_context ( bs ) ; } QLIST_FOREACH ( child , & bs -> children , next ) { bdrv_detach_aio_context ( child -> bs ) ; } bs -> aio_context = NULL ; }##::##1##::##2867
m48t59_t * m48t59_init_isa ( uint32_t io_base , uint16_t size , int type ) { M48t59ISAState * d ; ISADevice * dev ; m48t59_t * s ; dev = isa_create ( "m48t59_isa" ) ; qdev_prop_set_uint32 ( & dev -> qdev , "type" , type ) ; qdev_prop_set_uint32 ( & dev -> qdev , "size" , size ) ; qdev_prop_set_uint32 ( & dev -> qdev , "io_base" , io_base ) ; qdev_init ( & dev -> qdev ) ; d = DO_UPCAST ( M48t59ISAState , busdev , dev ) ; s = & d -> state ; if ( io_base != 0 ) { register_ioport_read ( io_base , 0x04 , 1 , NVRAM_readb , s ) ; register_ioport_write ( io_base , 0x04 , 1 , NVRAM_writeb , s ) ; } return s ; }##::##1##::##4238
static inline void RENAME ( duplicate ) ( uint8_t src [ ] , int stride ) { # if TEMPLATE_PP_MMX __asm__ volatile ( "movq (%0), %%mm0               \n\t" "add %1, %0                     \n\t" "movq %%mm0, (%0)               \n\t" "movq %%mm0, (%0, %1)           \n\t" "movq %%mm0, (%0, %1, 2)        \n\t" : "+r" ( src ) : "r" ( ( x86_reg ) - stride ) ) ; # else int i ; uint8_t * p = src ; for ( i = 0 ; i < 3 ; i ++ ) { p -= stride ; memcpy ( p , src , 8 ) ; } # endif }##::##1##::##7427
static int check_for_block_signature ( BlockDriverState * bs , const uint8_t * buf ) { static const uint8_t signatures [ ] [ 4 ] = { { 'Q' , 'F' , 'I' , 0xfb } , { 'C' , 'O' , 'W' , 'D' } , { 'V' , 'M' , 'D' , 'K' } , { 'O' , 'O' , 'O' , 'M' } , { } } ; int i ; for ( i = 0 ; signatures [ i ] [ 0 ] != 0 ; i ++ ) { if ( memcmp ( buf , signatures [ i ] , 4 ) == 0 ) { return 1 ; } } return 0 ; }##::##1##::##7144
void rgb24tobgr32 ( const uint8_t * src , uint8_t * dst , long src_size ) { long i ; for ( i = 0 ; 3 * i < src_size ; i ++ ) { # ifdef WORDS_BIGENDIAN dst [ 4 * i + 0 ] = 0 ; dst [ 4 * i + 1 ] = src [ 3 * i + 0 ] ; dst [ 4 * i + 2 ] = src [ 3 * i + 1 ] ; dst [ 4 * i + 3 ] = src [ 3 * i + 2 ] ; # else dst [ 4 * i + 0 ] = src [ 3 * i + 2 ] ; dst [ 4 * i + 1 ] = src [ 3 * i + 1 ] ; dst [ 4 * i + 2 ] = src [ 3 * i + 0 ] ; dst [ 4 * i + 3 ] = 0 ; # endif } }##::##1##::##2556
static void vm_change_state_handler ( void * opaque , int running , RunState state ) { GICv3ITSState * s = ( GICv3ITSState * ) opaque ; Error * err = NULL ; int ret ; if ( running ) { return ; } ret = kvm_device_access ( s -> dev_fd , KVM_DEV_ARM_VGIC_GRP_CTRL , KVM_DEV_ARM_ITS_SAVE_TABLES , NULL , true , & err ) ; if ( err ) { error_report_err ( err ) ; } if ( ret < 0 && ret != - EFAULT ) { abort ( ) ; } }##::##1##::##12210
static int append_to_cached_buf ( AVCodecContext * avctx , const uint8_t * buf , int buf_size ) { DVDSubContext * ctx = avctx -> priv_data ; if ( ctx -> buf_size > 0xffff - buf_size ) { av_log ( avctx , AV_LOG_WARNING , "Attempt to reconstruct " "too large SPU packets aborted.\n" ) ; av_freep ( & ctx -> buf ) ; return AVERROR_INVALIDDATA ; } ctx -> buf = av_realloc ( ctx -> buf , ctx -> buf_size + buf_size ) ; if ( ! ctx -> buf ) { return AVERROR ( ENOMEM ) ; } memcpy ( ctx -> buf + ctx -> buf_size , buf , buf_size ) ; ctx -> buf_size += buf_size ; return 0 ; }##::##1##::##2873
static void x86_cpu_apic_create ( X86CPU * cpu , Error * * errp ) { APICCommonState * apic ; const char * apic_type = "apic" ; if ( kvm_apic_in_kernel ( ) ) { apic_type = "kvm-apic" ; } else if ( xen_enabled ( ) ) { apic_type = "xen-apic" ; } cpu -> apic_state = DEVICE ( object_new ( apic_type ) ) ; object_property_add_child ( OBJECT ( cpu ) , "lapic" , OBJECT ( cpu -> apic_state ) , & error_abort ) ; qdev_prop_set_uint8 ( cpu -> apic_state , "id" , cpu -> apic_id ) ; apic = APIC_COMMON ( cpu -> apic_state ) ; apic -> cpu = cpu ; apic -> apicbase = APIC_DEFAULT_ADDRESS | MSR_IA32_APICBASE_ENABLE ; }##::##1##::##7418
static void qemu_net_queue_append ( NetQueue * queue , NetClientState * sender , unsigned flags , const uint8_t * buf , size_t size , NetPacketSent * sent_cb ) { NetPacket * packet ; if ( queue -> nq_count >= queue -> nq_maxlen && ! sent_cb ) { return ; } packet = g_malloc ( sizeof ( NetPacket ) + size ) ; packet -> sender = sender ; packet -> flags = flags ; packet -> size = size ; packet -> sent_cb = sent_cb ; memcpy ( packet -> data , buf , size ) ; QTAILQ_INSERT_TAIL ( & queue -> packets , packet , entry ) ; }##::##1##::##3111
static void vmxnet3_update_vlan_filters ( VMXNET3State * s ) { int i ; VMXNET3_READ_DRV_SHARED ( s -> drv_shmem , devRead . rxFilterConf . vfTable , s -> vlan_table , sizeof ( s -> vlan_table ) ) ; for ( i = 0 ; i < ARRAY_SIZE ( s -> vlan_table ) ; i ++ ) { s -> vlan_table [ i ] = le32_to_cpu ( s -> vlan_table [ i ] ) ; } VMW_CFPRN ( "Configured VLANs:" ) ; for ( i = 0 ; i < sizeof ( s -> vlan_table ) * 8 ; i ++ ) { if ( VMXNET3_VFTABLE_ENTRY_IS_SET ( s -> vlan_table , i ) ) { VMW_CFPRN ( "\tVLAN %d is present" , i ) ; } } }##::##1##::##12088
static int av_thread_message_queue_recv_locked ( AVThreadMessageQueue * mq , void * msg , unsigned flags ) { while ( ! mq -> err_recv && av_fifo_size ( mq -> fifo ) < mq -> elsize ) { if ( ( flags & AV_THREAD_MESSAGE_NONBLOCK ) ) { return AVERROR ( EAGAIN ) ; } pthread_cond_wait ( & mq -> cond , & mq -> lock ) ; } if ( av_fifo_size ( mq -> fifo ) < mq -> elsize ) { return mq -> err_recv ; } av_fifo_generic_read ( mq -> fifo , msg , mq -> elsize , NULL ) ; pthread_cond_signal ( & mq -> cond ) ; return 0 ; }##::##1##::##11783
static int get_bits ( Jpeg2000DecoderContext * s , int n ) { int res = 0 ; if ( s -> buf_end - s -> buf < ( ( n - s -> bit_index ) >> 8 ) ) { return AVERROR_INVALIDDATA ; } while ( -- n >= 0 ) { res <<= 1 ; if ( s -> bit_index == 0 ) { s -> bit_index = 7 + ( * s -> buf != 0xff ) ; s -> buf ++ ; } s -> bit_index -- ; res |= ( * s -> buf >> s -> bit_index ) & 1 ; } return res ; }##::##1##::##12171
static inline int l3_unscale ( int value , int exponent ) { unsigned int m ; int e ; e = table_4_3_exp [ 4 * value + ( exponent & 3 ) ] ; m = table_4_3_value [ 4 * value + ( exponent & 3 ) ] ; e -= exponent >> 2 ; # ifdef DEBUG if ( e < 1 ) { av_log ( NULL , AV_LOG_WARNING , "l3_unscale: e is %d\n" , e ) ; } # endif if ( e > ( SUINT ) 31 ) { return 0 ; } m = ( m + ( 1 << ( e - 1 ) ) ) >> e ; return m ; }##::##1##::##1886
static int net_vhost_user_init ( NetClientState * peer , const char * device , const char * name , CharDriverState * chr , int queues ) { NetClientState * nc ; VhostUserState * s ; int i ; for ( i = 0 ; i < queues ; i ++ ) { nc = qemu_new_net_client ( & net_vhost_user_info , peer , device , name ) ; snprintf ( nc -> info_str , sizeof ( nc -> info_str ) , "vhost-user%d to %s" , i , chr -> label ) ; nc -> queue_index = i ; s = DO_UPCAST ( VhostUserState , nc , nc ) ; s -> chr = chr ; } qemu_chr_add_handlers ( chr , NULL , NULL , net_vhost_user_event , ( void * ) name ) ; return 0 ; }##::##1##::##1532
static void create_default_qtables ( uint8_t * qtables , uint8_t q ) { int factor = q ; int i ; factor = av_clip ( q , 1 , 99 ) ; if ( q < 50 ) { q = 5000 / factor ; } else { q = 200 - factor * 2 ; } for ( i = 0 ; i < 128 ; i ++ ) { int val = ( default_quantizers [ i ] * q + 50 ) / 100 ; val = av_clip ( val , 1 , 255 ) ; qtables [ i ] = val ; } }##::##1##::##8713
int fw_cfg_add_callback ( FWCfgState * s , uint16_t key , FWCfgCallback callback , void * callback_opaque , uint8_t * data , size_t len ) { int arch = ! ! ( key & FW_CFG_ARCH_LOCAL ) ; if ( ! ( key & FW_CFG_WRITE_CHANNEL ) ) { return 0 ; } key &= FW_CFG_ENTRY_MASK ; if ( key >= FW_CFG_MAX_ENTRY || len > 65535 ) { return 0 ; } s -> entries [ arch ] [ key ] . data = data ; s -> entries [ arch ] [ key ] . len = len ; s -> entries [ arch ] [ key ] . callback_opaque = callback_opaque ; s -> entries [ arch ] [ key ] . callback = callback ; return 1 ; }##::##1##::##8172
e1000e_write_lgcy_rx_descr ( E1000ECore * core , uint8_t * desc , struct NetRxPkt * pkt , const E1000E_RSSInfo * rss_info , uint16_t length ) { uint32_t status_flags , rss , mrq ; uint16_t ip_id ; struct e1000_rx_desc * d = ( struct e1000_rx_desc * ) desc ; memset ( d , 0 , sizeof ( * d ) ) ; assert ( ! rss_info -> enabled ) ; d -> length = cpu_to_le16 ( length ) ; e1000e_build_rx_metadata ( core , pkt , pkt != NULL , rss_info , & rss , & mrq , & status_flags , & ip_id , & d -> special ) ; d -> errors = ( uint8_t ) ( le32_to_cpu ( status_flags ) >> 24 ) ; d -> status = ( uint8_t ) le32_to_cpu ( status_flags ) ; }##::##1##::##6353
int bdrv_pdiscard ( BlockDriverState * bs , int64_t offset , int count ) { Coroutine * co ; DiscardCo rwco = { . bs = bs , . offset = offset , . count = count , . ret = NOT_DONE , } ; if ( qemu_in_coroutine ( ) ) { bdrv_pdiscard_co_entry ( & rwco ) ; } else { co = qemu_coroutine_create ( bdrv_pdiscard_co_entry , & rwco ) ; qemu_coroutine_enter ( co ) ; BDRV_POLL_WHILE ( bs , rwco . ret == NOT_DONE ) ; } return rwco . ret ; }##::##1##::##9121
static void rearm_sensor_evts ( IPMIBmcSim * ibs , uint8_t * cmd , unsigned int cmd_len , uint8_t * rsp , unsigned int * rsp_len , unsigned int max_rsp_len ) { IPMISensor * sens ; IPMI_CHECK_CMD_LEN ( 4 ) ; if ( ( cmd [ 2 ] >= MAX_SENSORS ) || ! IPMI_SENSOR_GET_PRESENT ( ibs -> sensors + cmd [ 2 ] ) ) { rsp [ 2 ] = IPMI_CC_REQ_ENTRY_NOT_PRESENT ; return ; } sens = ibs -> sensors + cmd [ 2 ] ; if ( ( cmd [ 3 ] & 0x80 ) == 0 ) { sens -> states = 0 ; return ; } }##::##1##::##5186
static void virgl_cmd_get_capset_info ( VirtIOGPU * g , struct virtio_gpu_ctrl_command * cmd ) { struct virtio_gpu_get_capset_info info ; struct virtio_gpu_resp_capset_info resp ; VIRTIO_GPU_FILL_CMD ( info ) ; if ( info . capset_index == 0 ) { resp . capset_id = VIRTIO_GPU_CAPSET_VIRGL ; virgl_renderer_get_cap_set ( resp . capset_id , & resp . capset_max_version , & resp . capset_max_size ) ; } else { resp . capset_max_version = 0 ; resp . capset_max_size = 0 ; } resp . hdr . type = VIRTIO_GPU_RESP_OK_CAPSET_INFO ; virtio_gpu_ctrl_response ( g , cmd , & resp . hdr , sizeof ( resp ) ) ; }##::##1##::##8687
int qemu_uuid_parse ( const char * str , QemuUUID * uuid ) { unsigned char * uu = & uuid -> data [ 0 ] ; int ret ; if ( strlen ( str ) != 36 ) { return - 1 ; } ret = sscanf ( str , UUID_FMT , & uu [ 0 ] , & uu [ 1 ] , & uu [ 2 ] , & uu [ 3 ] , & uu [ 4 ] , & uu [ 5 ] , & uu [ 6 ] , & uu [ 7 ] , & uu [ 8 ] , & uu [ 9 ] , & uu [ 10 ] , & uu [ 11 ] , & uu [ 12 ] , & uu [ 13 ] , & uu [ 14 ] , & uu [ 15 ] ) ; if ( ret != 16 ) { return - 1 ; } return 0 ; }##::##1##::##3296
static AVStream * init_stream ( AVFormatContext * s ) { BinDemuxContext * bin = s -> priv_data ; AVStream * st = avformat_new_stream ( s , NULL ) ; if ( ! st ) { return NULL ; } st -> codec -> codec_tag = 0 ; st -> codec -> codec_type = AVMEDIA_TYPE_VIDEO ; if ( ! bin -> width ) { st -> codec -> width = ( 80 << 3 ) ; st -> codec -> height = ( 25 << 4 ) ; } avpriv_set_pts_info ( st , 60 , bin -> framerate . den , bin -> framerate . num ) ; bin -> chars_per_frame = FFMAX ( av_q2d ( st -> time_base ) * bin -> chars_per_frame , 1 ) ; return st ; }##::##1##::##8012
static QPCIDevice * get_ahci_device ( uint32_t * fingerprint ) { QPCIDevice * ahci ; uint32_t ahci_fingerprint ; QPCIBus * pcibus ; pcibus = qpci_init_pc ( ) ; ahci = qpci_device_find ( pcibus , QPCI_DEVFN ( 0x1F , 0x02 ) ) ; g_assert ( ahci != NULL ) ; ahci_fingerprint = qpci_config_readl ( ahci , PCI_VENDOR_ID ) ; switch ( ahci_fingerprint ) { case AHCI_INTEL_ICH9 : break ; default : g_assert_not_reached ( ) ; } if ( fingerprint ) { * fingerprint = ahci_fingerprint ; } return ahci ; }##::##1##::##3916
VLANClientState * qemu_new_vlan_client ( VLANState * vlan , IOReadHandler * fd_read , void * opaque ) { VLANClientState * vc , * * pvc ; vc = qemu_mallocz ( sizeof ( VLANClientState ) ) ; if ( ! vc ) { return NULL ; } vc -> fd_read = fd_read ; vc -> opaque = opaque ; vc -> vlan = vlan ; vc -> next = NULL ; pvc = & vlan -> first_client ; while ( * pvc != NULL ) { pvc = & ( * pvc ) -> next ; } * pvc = vc ; return vc ; }##::##1##::##11491
static void simple_varargs ( void ) { QObject * embedded_obj ; QObject * obj ; LiteralQObject decoded = QLIT_QLIST ( ( ( LiteralQObject [ ] ) { QLIT_QINT ( 1 ) , QLIT_QINT ( 2 ) , QLIT_QLIST ( ( ( LiteralQObject [ ] ) { QLIT_QINT ( 32 ) , QLIT_QINT ( 42 ) , { } } ) ) , { } } ) ) ; embedded_obj = qobject_from_json ( "[32, 42]" , NULL ) ; g_assert ( embedded_obj != NULL ) ; obj = qobject_from_jsonf ( "[%d, 2, %p]" , 1 , embedded_obj ) ; g_assert ( compare_litqobj_to_qobj ( & decoded , obj ) == 1 ) ; qobject_decref ( obj ) ; }##::##1##::##10782
static void monitor_qmp_event ( void * opaque , int event ) { QObject * data ; Monitor * mon = opaque ; switch ( event ) { case CHR_EVENT_OPENED : mon -> qmp . in_command_mode = false ; data = get_qmp_greeting ( ) ; monitor_json_emitter ( mon , data ) ; qobject_decref ( data ) ; mon_refcount ++ ; break ; case CHR_EVENT_CLOSED : json_message_parser_destroy ( & mon -> qmp . parser ) ; json_message_parser_init ( & mon -> qmp . parser , handle_qmp_command ) ; mon_refcount -- ; monitor_fdsets_cleanup ( ) ; break ; } }##::##1##::##1595
static av_cold void movie_uninit ( AVFilterContext * ctx ) { MovieContext * movie = ctx -> priv ; int i ; for ( i = 0 ; i < ctx -> nb_outputs ; i ++ ) { av_freep ( & ctx -> output_pads [ i ] . name ) ; if ( movie -> st [ i ] . st ) { avcodec_close ( movie -> st [ i ] . st -> codec ) ; } } av_freep ( & movie -> st ) ; av_freep ( & movie -> out_index ) ; av_frame_free ( & movie -> frame ) ; if ( movie -> format_ctx ) { avformat_close_input ( & movie -> format_ctx ) ; } }##::##1##::##10256
static int ram_save_host_page ( RAMState * rs , PageSearchStatus * pss , bool last_stage , ram_addr_t dirty_ram_abs ) { int tmppages , pages = 0 ; size_t pagesize = qemu_ram_pagesize ( pss -> block ) ; do { tmppages = ram_save_target_page ( rs , pss , last_stage , dirty_ram_abs ) ; if ( tmppages < 0 ) { return tmppages ; } pages += tmppages ; pss -> offset += TARGET_PAGE_SIZE ; dirty_ram_abs += TARGET_PAGE_SIZE ; } while ( pss -> offset & ( pagesize - 1 ) ) ; pss -> offset -= TARGET_PAGE_SIZE ; return pages ; }##::##1##::##966
static void pc_cpu_unplug_request_cb ( HotplugHandler * hotplug_dev , DeviceState * dev , Error * * errp ) { int idx = - 1 ; HotplugHandlerClass * hhc ; Error * local_err = NULL ; X86CPU * cpu = X86_CPU ( dev ) ; PCMachineState * pcms = PC_MACHINE ( hotplug_dev ) ; pc_find_cpu_slot ( MACHINE ( pcms ) , cpu -> apic_id , & idx ) ; assert ( idx != - 1 ) ; if ( idx == 0 ) { error_setg ( & local_err , "Boot CPU is unpluggable" ) ; hhc = HOTPLUG_HANDLER_GET_CLASS ( pcms -> acpi_dev ) ; hhc -> unplug_request ( HOTPLUG_HANDLER ( pcms -> acpi_dev ) , dev , & local_err ) ; if ( local_err ) { out : error_propagate ( errp , local_err ) ;##::##1##::##5151
void spapr_core_unplug ( HotplugHandler * hotplug_dev , DeviceState * dev , Error * * errp ) { sPAPRCPUCore * core = SPAPR_CPU_CORE ( OBJECT ( dev ) ) ; PowerPCCPU * cpu = POWERPC_CPU ( core -> threads ) ; int id = ppc_get_vcpu_dt_id ( cpu ) ; sPAPRDRConnector * drc = spapr_dr_connector_by_id ( SPAPR_DR_CONNECTOR_TYPE_CPU , id ) ; sPAPRDRConnectorClass * drck ; Error * local_err = NULL ; g_assert ( drc ) ; drck = SPAPR_DR_CONNECTOR_GET_CLASS ( drc ) ; drck -> detach ( drc , dev , spapr_core_release , NULL , & local_err ) ; if ( local_err ) { error_propagate ( errp , local_err ) ; return ; } spapr_hotplug_req_remove_by_index ( drc ) ; }##::##1##::##7742
static int qcow_write ( BlockDriverState * bs , int64_t sector_num , const uint8_t * buf , int nb_sectors ) { Coroutine * co ; AioContext * aio_context = bdrv_get_aio_context ( bs ) ; QcowWriteCo data = { . bs = bs , . sector_num = sector_num , . buf = buf , . nb_sectors = nb_sectors , . ret = - EINPROGRESS , } ; co = qemu_coroutine_create ( qcow_write_co_entry ) ; qemu_coroutine_enter ( co , & data ) ; while ( data . ret == - EINPROGRESS ) { aio_poll ( aio_context , true ) ; } return data . ret ; }##::##1##::##3241
static int qcow2_write ( BlockDriverState * bs , int64_t sector_num , const uint8_t * buf , int nb_sectors ) { Coroutine * co ; AioContext * aio_context = bdrv_get_aio_context ( bs ) ; Qcow2WriteCo data = { . bs = bs , . sector_num = sector_num , . buf = buf , . nb_sectors = nb_sectors , . ret = - EINPROGRESS , } ; co = qemu_coroutine_create ( qcow2_write_co_entry ) ; qemu_coroutine_enter ( co , & data ) ; while ( data . ret == - EINPROGRESS ) { aio_poll ( aio_context , true ) ; } return data . ret ; }##::##1##::##9275
static int coroutine_fn sd_co_flush_to_disk ( BlockDriverState * bs ) { BDRVSheepdogState * s = bs -> opaque ; SheepdogAIOCB * acb ; AIOReq * aio_req ; if ( s -> cache_flags != SD_FLAG_CMD_CACHE ) { return 0 ; } acb = sd_aio_setup ( bs , NULL , 0 , 0 ) ; acb -> aiocb_type = AIOCB_FLUSH_CACHE ; acb -> aio_done_func = sd_finish_aiocb ; aio_req = alloc_aio_req ( s , acb , vid_to_vdi_oid ( s -> inode . vdi_id ) , 0 , 0 , 0 , 0 , 0 ) ; QLIST_INSERT_HEAD ( & s -> inflight_aio_head , aio_req , aio_siblings ) ; add_aio_request ( s , aio_req , NULL , 0 , false , acb -> aiocb_type ) ; qemu_coroutine_yield ( ) ; return acb -> ret ; }##::##1##::##319
static void win32_rearm_timer ( struct qemu_alarm_timer * t , int64_t nearest_delta_ns ) { HANDLE hTimer = t -> timer ; int nearest_delta_ms ; BOOLEAN success ; nearest_delta_ms = ( nearest_delta_ns + 999999 ) / 1000000 ; if ( nearest_delta_ms < 1 ) { nearest_delta_ms = 1 ; } success = ChangeTimerQueueTimer ( NULL , hTimer , nearest_delta_ms , 3600000 ) ; if ( ! success ) { fprintf ( stderr , "Failed to rearm win32 alarm timer: %ld\n" , GetLastError ( ) ) ; exit ( - 1 ) ; } }##::##1##::##2695
static void memory_region_dispatch_write ( MemoryRegion * mr , hwaddr addr , uint64_t data , unsigned size ) { if ( ! memory_region_access_valid ( mr , addr , size , true ) ) { return ; } adjust_endianness ( mr , & data , size ) ; if ( ! mr -> ops -> write ) { mr -> ops -> old_mmio . write [ bitops_ffsl ( size ) ] ( mr -> opaque , addr , data ) ; return ; } access_with_adjusted_size ( addr , & data , size , mr -> ops -> impl . min_access_size , mr -> ops -> impl . max_access_size , memory_region_write_accessor , mr ) ; }##::##1##::##10827
static void move_audio ( vorbis_enc_context * venc , float * * audio , int * samples , int sf_size ) { AVFrame * cur = NULL ; int frame_size = 1 << ( venc -> log2_blocksize [ 1 ] - 1 ) ; int subframes = frame_size / sf_size ; for ( int sf = 0 ; sf < subframes ; sf ++ ) { cur = ff_bufqueue_get ( & venc -> bufqueue ) ; * samples += cur -> nb_samples ; for ( int ch = 0 ; ch < venc -> channels ; ch ++ ) { const float * input = ( float * ) cur -> extended_data [ ch ] ; const size_t len = cur -> nb_samples * sizeof ( float ) ; memcpy ( & audio [ ch ] [ sf * sf_size ] , input , len ) ; } av_frame_free ( & cur ) ; } }##::##1##::##9094
static void core_rtas_register_types ( void ) { spapr_rtas_register ( RTAS_DISPLAY_CHARACTER , "display-character" , rtas_display_character ) ; spapr_rtas_register ( RTAS_GET_TIME_OF_DAY , "get-time-of-day" , rtas_get_time_of_day ) ; spapr_rtas_register ( RTAS_SET_TIME_OF_DAY , "set-time-of-day" , rtas_set_time_of_day ) ; spapr_rtas_register ( RTAS_POWER_OFF , "power-off" , rtas_power_off ) ; spapr_rtas_register ( RTAS_SYSTEM_REBOOT , "system-reboot" , rtas_system_reboot ) ; spapr_rtas_register ( RTAS_QUERY_CPU_STOPPED_STATE , "query-cpu-stopped-state" , rtas_query_cpu_stopped_state ) ; spapr_rtas_register ( RTAS_START_CPU , "start-cpu" , rtas_start_cpu ) ; spapr_rtas_register ( RTAS_STOP_SELF , "stop-self" , rtas_stop_self ) ; spapr_rtas_register ( RTAS_IBM_GET_SYSTEM_PARAMETER , "ibm,get-system-parameter" , rtas_ibm_get_system_parameter ) ; spapr_rtas_register ( RTAS_IBM_SET_SYSTEM_PARAMETER , "ibm,set-system-parameter" , rtas_ibm_set_system_parameter ) ; }##::##1##::##1615
static inline void cvtyuvtoRGB ( SwsContext * c , vector signed short Y , vector signed short U , vector signed short V , vector signed short * R , vector signed short * G , vector signed short * B ) { vector signed short vx , ux , uvx ; Y = vec_mradds ( Y , c -> CY , c -> OY ) ; U = vec_sub ( U , ( vector signed short ) vec_splat ( ( vector signed short ) AVV ( 128 ) , 0 ) ) ; V = vec_sub ( V , ( vector signed short ) vec_splat ( ( vector signed short ) AVV ( 128 ) , 0 ) ) ; ux = vec_sl ( U , c -> CSHIFT ) ; * B = vec_mradds ( ux , c -> CBU , Y ) ; vx = vec_sl ( V , c -> CSHIFT ) ; * R = vec_mradds ( vx , c -> CRV , Y ) ; uvx = vec_mradds ( U , c -> CGU , Y ) ; * G = vec_mradds ( V , c -> CGV , uvx ) ; }##::##1##::##11777
HBitmap * hbitmap_alloc ( uint64_t size , int granularity ) { HBitmap * hb = g_malloc0 ( sizeof ( struct HBitmap ) ) ; unsigned i ; assert ( granularity >= 0 && granularity < 64 ) ; size = ( size + ( 1ULL << granularity ) - 1 ) >> granularity ; assert ( size <= ( ( uint64_t ) 1 << HBITMAP_LOG_MAX_SIZE ) ) ; hb -> size = size ; hb -> granularity = granularity ; for ( i = HBITMAP_LEVELS ; i -- > 0 ; ) { size = MAX ( ( size + BITS_PER_LONG - 1 ) >> BITS_PER_LEVEL , 1 ) ; hb -> levels [ i ] = g_malloc0 ( size * sizeof ( unsigned long ) ) ; } assert ( size == 1 ) ; hb -> levels [ 0 ] [ 0 ] |= 1UL << ( BITS_PER_LONG - 1 ) ; return hb ; }##::##1##::##8000
static int get_bits ( J2kDecoderContext * s , int n ) { int res = 0 ; if ( s -> buf_end - s -> buf < ( ( n - s -> bit_index ) >> 8 ) ) { return AVERROR ( EINVAL ) ; } while ( -- n >= 0 ) { res <<= 1 ; if ( s -> bit_index == 0 ) { s -> bit_index = 7 + ( * s -> buf != 0xff ) ; s -> buf ++ ; } s -> bit_index -- ; res |= ( * s -> buf >> s -> bit_index ) & 1 ; } return res ; }##::##1##::##9924
BdrvDirtyBitmap * bdrv_create_dirty_bitmap ( BlockDriverState * bs , int granularity , Error * * errp ) { int64_t bitmap_size ; BdrvDirtyBitmap * bitmap ; assert ( ( granularity & ( granularity - 1 ) ) == 0 ) ; granularity >>= BDRV_SECTOR_BITS ; assert ( granularity ) ; bitmap_size = bdrv_nb_sectors ( bs ) ; if ( bitmap_size < 0 ) { error_setg_errno ( errp , - bitmap_size , "could not get length of device" ) ; errno = - bitmap_size ; return NULL ; } bitmap = g_malloc0 ( sizeof ( BdrvDirtyBitmap ) ) ; bitmap -> bitmap = hbitmap_alloc ( bitmap_size , ffs ( granularity ) - 1 ) ; QLIST_INSERT_HEAD ( & bs -> dirty_bitmaps , bitmap , list ) ; return bitmap ; }##::##1##::##10239
void stream_start ( const char * job_id , BlockDriverState * bs , BlockDriverState * base , const char * backing_file_str , int64_t speed , BlockdevOnError on_error , BlockCompletionFunc * cb , void * opaque , Error * * errp ) { StreamBlockJob * s ; s = block_job_create ( job_id , & stream_job_driver , bs , speed , cb , opaque , errp ) ; if ( ! s ) { return ; } s -> base = base ; s -> backing_file_str = g_strdup ( backing_file_str ) ; s -> on_error = on_error ; s -> common . co = qemu_coroutine_create ( stream_run ) ; trace_stream_start ( bs , base , s , s -> common . co , opaque ) ; qemu_coroutine_enter ( s -> common . co , s ) ; }##::##1##::##8875
void vnc_jobs_consume_buffer ( VncState * vs ) { bool flush ; vnc_lock_output ( vs ) ; if ( vs -> jobs_buffer . offset ) { if ( vs -> ioc != NULL && buffer_empty ( & vs -> output ) ) { if ( vs -> ioc_tag ) { g_source_remove ( vs -> ioc_tag ) ; vs -> ioc_tag = qio_channel_add_watch ( vs -> ioc , G_IO_IN | G_IO_OUT , vnc_client_io , vs , NULL ) ; buffer_move ( & vs -> output , & vs -> jobs_buffer ) ; flush = vs -> ioc != NULL && vs -> abort != true ; vnc_unlock_output ( vs ) ; if ( flush ) { vnc_flush ( vs ) ;##::##1##::##4852
aio_write_done ( void * opaque , int ret ) { struct aio_ctx * ctx = opaque ; struct timeval t2 ; gettimeofday ( & t2 , NULL ) ; if ( ret < 0 ) { printf ( "aio_write failed: %s\n" , strerror ( - ret ) ) ; return ; } if ( ctx -> qflag ) { return ; } t2 = tsub ( t2 , ctx -> t1 ) ; print_report ( "wrote" , & t2 , ctx -> offset , ctx -> qiov . size , ctx -> qiov . size , 1 , ctx -> Cflag ) ; qemu_io_free ( ctx -> buf ) ; free ( ctx ) ; }##::##1##::##1044
static inline void gen_outs ( DisasContext * s , TCGMemOp ot ) { if ( s -> base . tb -> cflags & CF_USE_ICOUNT ) { gen_io_start ( ) ; } gen_string_movl_A0_ESI ( s ) ; gen_op_ld_v ( s , ot , cpu_T0 , cpu_A0 ) ; tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_regs [ R_EDX ] ) ; tcg_gen_andi_i32 ( cpu_tmp2_i32 , cpu_tmp2_i32 , 0xffff ) ; tcg_gen_trunc_tl_i32 ( cpu_tmp3_i32 , cpu_T0 ) ; gen_helper_out_func ( ot , cpu_tmp2_i32 , cpu_tmp3_i32 ) ; gen_op_movl_T0_Dshift ( ot ) ; gen_op_add_reg_T0 ( s -> aflag , R_ESI ) ; gen_bpt_io ( s , cpu_tmp2_i32 , ot ) ; if ( s -> base . tb -> cflags & CF_USE_ICOUNT ) { gen_io_end ( ) ; } }##::##1##::##4840
void ff_mov_close_hinting ( MOVTrack * track ) { AVFormatContext * rtp_ctx = track -> rtp_ctx ; uint8_t * ptr ; av_freep ( & track -> enc ) ; sample_queue_free ( & track -> sample_queue ) ; if ( ! rtp_ctx ) { return ; } if ( rtp_ctx -> pb ) { av_write_trailer ( rtp_ctx ) ; url_close_dyn_buf ( rtp_ctx -> pb , & ptr ) ; av_free ( ptr ) ; } av_metadata_free ( & rtp_ctx -> streams [ 0 ] -> metadata ) ; av_metadata_free ( & rtp_ctx -> metadata ) ; av_free ( rtp_ctx -> streams [ 0 ] ) ; av_freep ( & rtp_ctx ) ; }##::##1##::##389
static void gen_sub ( DisasContext * dc , TCGv dest , TCGv srca , TCGv srcb ) { TCGv res = tcg_temp_new ( ) ; TCGv sr_cy = tcg_temp_new ( ) ; TCGv sr_ov = tcg_temp_new ( ) ; tcg_gen_sub_tl ( res , srca , srcb ) ; tcg_gen_xor_tl ( sr_cy , srca , srcb ) ; tcg_gen_xor_tl ( sr_ov , res , srcb ) ; tcg_gen_and_tl ( sr_ov , sr_ov , sr_cy ) ; tcg_gen_setcond_tl ( TCG_COND_LTU , sr_cy , srca , srcb ) ; tcg_gen_mov_tl ( dest , res ) ; tcg_temp_free ( res ) ; tcg_gen_shri_tl ( sr_ov , sr_ov , TARGET_LONG_BITS - 1 ) ; tcg_gen_deposit_tl ( cpu_sr , cpu_sr , sr_cy , ctz32 ( SR_CY ) , 1 ) ; tcg_gen_deposit_tl ( cpu_sr , cpu_sr , sr_ov , ctz32 ( SR_OV ) , 1 ) ; gen_ove_cyov ( dc , sr_ov , sr_cy ) ; tcg_temp_free ( sr_ov ) ; tcg_temp_free ( sr_cy ) ; }##::##1##::##1365
static void host_x86_cpu_class_init ( ObjectClass * oc , void * data ) { DeviceClass * dc = DEVICE_CLASS ( oc ) ; X86CPUClass * xcc = X86_CPU_CLASS ( oc ) ; uint32_t eax = 0 , ebx = 0 , ecx = 0 , edx = 0 ; xcc -> kvm_required = true ; host_cpuid ( 0x0 , 0 , & eax , & ebx , & ecx , & edx ) ; x86_cpu_vendor_words2str ( host_cpudef . vendor , ebx , edx , ecx ) ; host_cpuid ( 0x1 , 0 , & eax , & ebx , & ecx , & edx ) ; host_cpudef . family = ( ( eax >> 8 ) & 0x0F ) + ( ( eax >> 20 ) & 0xFF ) ; host_cpudef . model = ( ( eax >> 4 ) & 0x0F ) | ( ( eax & 0xF0000 ) >> 12 ) ; host_cpudef . stepping = eax & 0x0F ; cpu_x86_fill_model_id ( host_cpudef . model_id ) ; xcc -> cpu_def = & host_cpudef ; host_cpudef . cache_info_passthrough = true ; dc -> props = host_x86_cpu_properties ; }##::##1##::##3448
static void v9fs_clunk ( void * opaque ) { int err ; int32_t fid ; size_t offset = 7 ; V9fsFidState * fidp ; V9fsPDU * pdu = opaque ; V9fsState * s = pdu -> s ; pdu_unmarshal ( pdu , offset , "d" , & fid ) ; fidp = clunk_fid ( s , fid ) ; if ( fidp == NULL ) { err = - ENOENT ; goto out_nofid ; } fidp -> ref ++ ; err = offset ; put_fid ( pdu , fidp ) ; out_nofid : complete_pdu ( s , pdu , err ) ; }##::##1##::##9671
void helper_stsw ( CPUPPCState * env , target_ulong addr , uint32_t nb , uint32_t reg ) { int sh ; for ( ; nb > 3 ; nb -= 4 ) { cpu_stl_data ( env , addr , env -> gpr [ reg ] ) ; reg = ( reg + 1 ) % 32 ; addr = addr_add ( env , addr , 4 ) ; } if ( unlikely ( nb > 0 ) ) { for ( sh = 24 ; nb > 0 ; nb -- , sh -= 8 ) { cpu_stb_data ( env , addr , ( env -> gpr [ reg ] >> sh ) & 0xFF ) ; addr = addr_add ( env , addr , 1 ) ; } } }##::##1##::##10401
void ff_thread_report_progress ( ThreadFrame * f , int n , int field ) { PerThreadContext * p ; atomic_int * progress = f -> progress ? ( atomic_int * ) f -> progress -> data : NULL ; if ( ! progress || atomic_load_explicit ( & progress [ field ] , memory_order_relaxed ) >= n ) { return ; } p = f -> owner [ field ] -> internal -> thread_ctx ; if ( f -> owner [ field ] -> debug & FF_DEBUG_THREADS ) av_log ( f -> owner [ field ] , AV_LOG_DEBUG , "%p finished %d field %d\n" , progress , n , field ) ; pthread_mutex_lock ( & p -> progress_mutex ) ; atomic_store_explicit ( & progress [ field ] , n , memory_order_release ) ; pthread_cond_broadcast ( & p -> progress_cond ) ; pthread_mutex_unlock ( & p -> progress_mutex ) ; }##::##1##::##1053
void net_tx_pkt_init ( struct NetTxPkt * * pkt , PCIDevice * pci_dev , uint32_t max_frags , bool has_virt_hdr ) { struct NetTxPkt * p = g_malloc0 ( sizeof * p ) ; p -> pci_dev = pci_dev ; p -> vec = g_malloc ( ( sizeof * p -> vec ) * ( max_frags + NET_TX_PKT_PL_START_FRAG ) ) ; p -> raw = g_malloc ( ( sizeof * p -> raw ) * max_frags ) ; p -> max_payload_frags = max_frags ; p -> max_raw_frags = max_frags ; p -> has_virt_hdr = has_virt_hdr ; p -> vec [ NET_TX_PKT_VHDR_FRAG ] . iov_base = & p -> virt_hdr ; p -> vec [ NET_TX_PKT_VHDR_FRAG ] . iov_len = p -> has_virt_hdr ? sizeof p -> virt_hdr : 0 ; p -> vec [ NET_TX_PKT_L2HDR_FRAG ] . iov_base = & p -> l2_hdr ; p -> vec [ NET_TX_PKT_L3HDR_FRAG ] . iov_base = & p -> l3_hdr ; * pkt = p ; }##::##1##::##755
static void process_frame ( AVFilterLink * inlink , AVFilterBufferRef * buf ) { AVFilterContext * ctx = inlink -> dst ; ConcatContext * cat = ctx -> priv ; unsigned in_no = FF_INLINK_IDX ( inlink ) ; if ( in_no < cat -> cur_idx ) { av_log ( ctx , AV_LOG_ERROR , "Frame after EOF on input %s\n" , ctx -> input_pads [ in_no ] . name ) ; avfilter_unref_buffer ( buf ) ; } if ( in_no >= cat -> cur_idx + ctx -> nb_outputs ) { ff_bufqueue_add ( ctx , & cat -> in [ in_no ] . queue , buf ) ; } else { push_frame ( ctx , in_no , buf ) ; } }##::##1##::##6973
static inline void RENAME ( bgr24ToUV ) ( uint8_t * dstU , uint8_t * dstV , const uint8_t * src1 , const uint8_t * src2 , int width , uint32_t * unused ) { # if COMPILE_TEMPLATE_MMX RENAME ( bgr24ToUV_mmx ) ( dstU , dstV , src1 , width , PIX_FMT_BGR24 ) ; # else int i ; for ( i = 0 ; i < width ; i ++ ) { int b = src1 [ 3 * i + 0 ] ; int g = src1 [ 3 * i + 1 ] ; int r = src1 [ 3 * i + 2 ] ; dstU [ i ] = ( RU * r + GU * g + BU * b + ( 257 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ; dstV [ i ] = ( RV * r + GV * g + BV * b + ( 257 << ( RGB2YUV_SHIFT - 1 ) ) ) >> RGB2YUV_SHIFT ; } # endif assert ( src1 == src2 ) ; }##::##1##::##2478
static av_cold int v4l2_encode_init ( AVCodecContext * avctx ) { V4L2m2mContext * s = avctx -> priv_data ; V4L2Context * capture = & s -> capture ; V4L2Context * output = & s -> output ; int ret ; output -> height = capture -> height = avctx -> height ; output -> width = capture -> width = avctx -> width ; output -> av_codec_id = AV_CODEC_ID_RAWVIDEO ; output -> av_pix_fmt = avctx -> pix_fmt ; capture -> av_codec_id = avctx -> codec_id ; capture -> av_pix_fmt = AV_PIX_FMT_NONE ; ret = ff_v4l2_m2m_codec_init ( avctx ) ; if ( ret ) { av_log ( avctx , AV_LOG_ERROR , "can't configure encoder\n" ) ; return ret ; } return v4l2_prepare_encoder ( s ) ; }##::##1##::##10117
void fork_end ( int child ) { mmap_fork_end ( child ) ; if ( child ) { CPUState * cpu , * next_cpu ; CPU_FOREACH_SAFE ( cpu , next_cpu ) { if ( cpu != thread_cpu ) { QTAILQ_REMOVE ( & cpus , cpu , node ) ; } } qemu_mutex_init ( & tb_ctx . tb_lock ) ; qemu_init_cpu_list ( ) ; gdbserver_fork ( thread_cpu ) ; } else { qemu_mutex_unlock ( & tb_ctx . tb_lock ) ; cpu_list_unlock ( ) ; } }##::##1##::##6348
static int dxva2_mpeg2_end_frame ( AVCodecContext * avctx ) { struct MpegEncContext * s = avctx -> priv_data ; struct dxva2_picture_context * ctx_pic = s -> current_picture_ptr -> hwaccel_picture_private ; int ret ; if ( ctx_pic -> slice_count <= 0 || ctx_pic -> bitstream_size <= 0 ) { return - 1 ; } ret = ff_dxva2_common_end_frame ( avctx , & s -> current_picture_ptr -> f , & ctx_pic -> pp , sizeof ( ctx_pic -> pp ) , & ctx_pic -> qm , sizeof ( ctx_pic -> qm ) , commit_bitstream_and_slice_buffer ) ; if ( ! ret ) { ff_mpeg_draw_horiz_band ( s , 0 , avctx -> height ) ; } return ret ; }##::##1##::##1259
static void rtc_periodic_timer ( void * opaque ) { RTCState * s = opaque ; rtc_timer_update ( s , s -> next_periodic_time ) ; # ifdef TARGET_I386 if ( ( s -> cmos_data [ RTC_REG_C ] & 0xc0 ) && rtc_td_hack ) { s -> irq_coalesced ++ ; return ; } # endif if ( s -> cmos_data [ RTC_REG_B ] & REG_B_PIE ) { s -> cmos_data [ RTC_REG_C ] |= 0xc0 ; rtc_irq_raise ( s -> irq ) ; } if ( s -> cmos_data [ RTC_REG_B ] & REG_B_SQWE ) { qemu_irq_raise ( s -> sqw_irq ) ; } }##::##1##::##3399
static coroutine_fn int hdev_co_write_zeroes ( BlockDriverState * bs , int64_t sector_num , int nb_sectors , BdrvRequestFlags flags ) { BDRVRawState * s = bs -> opaque ; int rc ; rc = fd_open ( bs ) ; if ( rc < 0 ) { return rc ; } if ( ! ( flags & BDRV_REQ_MAY_UNMAP ) ) { return - ENOTSUP ; } if ( ! s -> discard_zeroes ) { return - ENOTSUP ; } return paio_submit_co ( bs , s -> fd , sector_num , NULL , nb_sectors , QEMU_AIO_DISCARD | QEMU_AIO_BLKDEV ) ; }##::##1##::##4264
void avfilter_copy_buffer_ref_props ( AVFilterBufferRef * dst , AVFilterBufferRef * src ) { dst -> pts = src -> pts ; dst -> pos = src -> pos ; switch ( src -> type ) { case AVMEDIA_TYPE_VIDEO : { if ( dst -> video -> qp_table ) { av_freep ( & dst -> video -> qp_table ) ; } copy_video_props ( dst -> video , src -> video ) ; break ; } case AVMEDIA_TYPE_AUDIO : * dst -> audio = * src -> audio ; break ; default : break ; } }##::##1##::##9787
static void add_pixels_clamped_c ( const int16_t * block , uint8_t * av_restrict pixels , ptrdiff_t line_size ) { int i ; for ( i = 0 ; i < 8 ; i ++ ) { pixels [ 0 ] = av_clip_uint8 ( pixels [ 0 ] + block [ 0 ] ) ; pixels [ 1 ] = av_clip_uint8 ( pixels [ 1 ] + block [ 1 ] ) ; pixels [ 2 ] = av_clip_uint8 ( pixels [ 2 ] + block [ 2 ] ) ; pixels [ 3 ] = av_clip_uint8 ( pixels [ 3 ] + block [ 3 ] ) ; pixels [ 4 ] = av_clip_uint8 ( pixels [ 4 ] + block [ 4 ] ) ; pixels [ 5 ] = av_clip_uint8 ( pixels [ 5 ] + block [ 5 ] ) ; pixels [ 6 ] = av_clip_uint8 ( pixels [ 6 ] + block [ 6 ] ) ; pixels [ 7 ] = av_clip_uint8 ( pixels [ 7 ] + block [ 7 ] ) ; pixels += line_size ; block += 8 ; } }##::##1##::##2630
static av_cold int v4l2_decode_init ( AVCodecContext * avctx ) { V4L2m2mContext * s = avctx -> priv_data ; V4L2Context * capture = & s -> capture ; V4L2Context * output = & s -> output ; int ret ; output -> height = capture -> height = avctx -> coded_height ; output -> width = capture -> width = avctx -> coded_width ; output -> av_codec_id = avctx -> codec_id ; output -> av_pix_fmt = AV_PIX_FMT_NONE ; capture -> av_codec_id = AV_CODEC_ID_RAWVIDEO ; capture -> av_pix_fmt = avctx -> pix_fmt ; ret = ff_v4l2_m2m_codec_init ( avctx ) ; if ( ret ) { av_log ( avctx , AV_LOG_ERROR , "can't configure decoder\n" ) ; return ret ; } return v4l2_prepare_decoder ( s ) ; }##::##1##::##9280
void hbitmap_iter_init ( HBitmapIter * hbi , const HBitmap * hb , uint64_t first ) { unsigned i , bit ; uint64_t pos ; hbi -> hb = hb ; pos = first >> hb -> granularity ; hbi -> pos = pos >> BITS_PER_LEVEL ; hbi -> granularity = hb -> granularity ; for ( i = HBITMAP_LEVELS ; i -- > 0 ; ) { bit = pos & ( BITS_PER_LONG - 1 ) ; pos >>= BITS_PER_LEVEL ; hbi -> cur [ i ] = hb -> levels [ i ] [ pos ] & ~ ( ( 1UL << bit ) - 1 ) ; if ( i != HBITMAP_LEVELS - 1 ) { hbi -> cur [ i ] &= ~ ( 1UL << bit ) ; } } }##::##1##::##9937
static int of_dpa_cmd_flow_add ( OfDpa * of_dpa , uint64_t cookie , RockerTlv * * flow_tlvs ) { OfDpaFlow * flow = of_dpa_flow_find ( of_dpa , cookie ) ; int err = ROCKER_OK ; if ( flow ) { return - ROCKER_EEXIST ; } flow = of_dpa_flow_alloc ( cookie ) ; if ( ! flow ) { return - ROCKER_ENOMEM ; } err = of_dpa_cmd_flow_add_mod ( of_dpa , flow , flow_tlvs ) ; if ( err ) { g_free ( flow ) ; return err ; } return of_dpa_flow_add ( of_dpa , flow ) ; }##::##1##::##2667
static int virtio_blk_init_pci ( PCIDevice * pci_dev ) { VirtIOPCIProxy * proxy = DO_UPCAST ( VirtIOPCIProxy , pci_dev , pci_dev ) ; VirtIODevice * vdev ; if ( proxy -> class_code != PCI_CLASS_STORAGE_SCSI && proxy -> class_code != PCI_CLASS_STORAGE_OTHER ) { proxy -> class_code = PCI_CLASS_STORAGE_SCSI ; } if ( ! proxy -> block . bs ) { error_report ( "virtio-blk-pci: drive property not set" ) ; vdev = virtio_blk_init ( & pci_dev -> qdev , & proxy -> block ) ; vdev -> nvectors = proxy -> nvectors ; virtio_init_pci ( proxy , vdev , PCI_VENDOR_ID_REDHAT_QUMRANET , PCI_DEVICE_ID_VIRTIO_BLOCK , proxy -> class_code , 0x00 ) ; proxy -> nvectors = vdev -> nvectors ; return 0 ;##::##1##::##3753
static void spapr_dr_connector_class_init ( ObjectClass * k , void * data ) { DeviceClass * dk = DEVICE_CLASS ( k ) ; sPAPRDRConnectorClass * drck = SPAPR_DR_CONNECTOR_CLASS ( k ) ; dk -> reset = reset ; dk -> realize = realize ; dk -> unrealize = unrealize ; drck -> set_isolation_state = set_isolation_state ; drck -> set_indicator_state = set_indicator_state ; drck -> set_allocation_state = set_allocation_state ; drck -> get_index = get_index ; drck -> get_type = get_type ; drck -> get_name = get_name ; drck -> get_fdt = get_fdt ; drck -> set_configured = set_configured ; drck -> entity_sense = entity_sense ; drck -> attach = attach ; drck -> detach = detach ; drck -> release_pending = release_pending ; }##::##1##::##6636
static void qobject_input_check_struct ( Visitor * v , Error * * errp ) { QObjectInputVisitor * qiv = to_qiv ( v ) ; StackObject * tos = QSLIST_FIRST ( & qiv -> stack ) ; assert ( tos && ! tos -> entry ) ; if ( qiv -> strict ) { GHashTable * const top_ht = tos -> h ; if ( top_ht ) { GHashTableIter iter ; const char * key ; g_hash_table_iter_init ( & iter , top_ht ) ; if ( g_hash_table_iter_next ( & iter , ( void * * ) & key , NULL ) ) { error_setg ( errp , "Parameter '%s' is unexpected" , key ) ; } } } }##::##1##::##6089
static struct omap_prcm_s * omap_prcm_init ( struct omap_target_agent_s * ta , qemu_irq mpu_int , qemu_irq dsp_int , qemu_irq iva_int , struct omap_mpu_state_s * mpu ) { struct omap_prcm_s * s = ( struct omap_prcm_s * ) g_malloc0 ( sizeof ( struct omap_prcm_s ) ) ; s -> irq [ 0 ] = mpu_int ; s -> irq [ 1 ] = dsp_int ; s -> irq [ 2 ] = iva_int ; s -> mpu = mpu ; omap_prcm_coldreset ( s ) ; memory_region_init_io ( & s -> iomem0 , NULL , & omap_prcm_ops , s , "omap.pcrm0" , omap_l4_region_size ( ta , 0 ) ) ; memory_region_init_io ( & s -> iomem1 , NULL , & omap_prcm_ops , s , "omap.pcrm1" , omap_l4_region_size ( ta , 1 ) ) ; omap_l4_attach ( ta , 0 , & s -> iomem0 ) ; omap_l4_attach ( ta , 1 , & s -> iomem1 ) ; return s ; }##::##1##::##5252
static void ahci_test_identify ( AHCIQState * ahci ) { uint16_t buff [ 256 ] ; unsigned px ; int rc ; uint16_t sect_size ; const size_t buffsize = 512 ; g_assert ( ahci != NULL ) ; px = ahci_port_select ( ahci ) ; g_test_message ( "Selected port %u for test" , px ) ; ahci_port_clear ( ahci , px ) ; ahci_io ( ahci , px , CMD_IDENTIFY , & buff , buffsize ) ; string_bswap16 ( & buff [ 10 ] , 20 ) ; rc = memcmp ( & buff [ 10 ] , "testdisk            " , 20 ) ; g_assert_cmphex ( rc , == , 0 ) ; string_bswap16 ( & buff [ 23 ] , 8 ) ; rc = memcmp ( & buff [ 23 ] , "version " , 8 ) ; g_assert_cmphex ( rc , == , 0 ) ; }##::##1##::##1806
void visit_type_size ( Visitor * v , uint64_t * obj , const char * name , Error * * errp ) { int64_t value ; if ( ! error_is_set ( errp ) ) { if ( v -> type_size ) { v -> type_size ( v , obj , name , errp ) ; } else if ( v -> type_uint64 ) { v -> type_uint64 ( v , obj , name , errp ) ; } else { value = * obj ; v -> type_int ( v , & value , name , errp ) ; * obj = value ; } } }##::##1##::##2771
static double get_volume ( CompandContext * s , double in_lin ) { CompandSegment * cs ; double in_log , out_log ; int i ; if ( in_lin < s -> in_min_lin ) { return s -> out_min_lin ; } in_log = log ( in_lin ) ; for ( i = 1 ; ; i ++ ) if ( in_log <= s -> segments [ i + 1 ] . x ) { break ; } cs = & s -> segments [ i ] ; in_log -= cs -> x ; out_log = cs -> y + in_log * ( cs -> a * in_log + cs -> b ) ; return exp ( out_log ) ; }##::##1##::##9514
static void kvm_mce_broadcast_rest ( CPUState * env ) { CPUState * cenv ; int family , model , cpuver = env -> cpuid_version ; family = ( cpuver >> 8 ) & 0xf ; model = ( ( cpuver >> 12 ) & 0xf0 ) + ( ( cpuver >> 4 ) & 0xf ) ; if ( ( family == 6 && model >= 14 ) || family > 6 ) { for ( cenv = first_cpu ; cenv != NULL ; cenv = cenv -> next_cpu ) { if ( cenv == env ) { continue ; } kvm_inject_x86_mce ( cenv , 1 , MCI_STATUS_VAL | MCI_STATUS_UC , MCG_STATUS_MCIP | MCG_STATUS_RIPV , 0 , 0 , 1 ) ; } } }##::##1##::##11915
static int virtio_blk_handle_rw_error ( VirtIOBlockReq * req , int error , bool is_read ) { BlockErrorAction action = blk_get_error_action ( req -> dev -> blk , is_read , error ) ; VirtIOBlock * s = req -> dev ; if ( action == BLOCK_ERROR_ACTION_STOP ) { req -> next = s -> rq ; s -> rq = req ; } else if ( action == BLOCK_ERROR_ACTION_REPORT ) { virtio_blk_req_complete ( req , VIRTIO_BLK_S_IOERR ) ; block_acct_done ( blk_get_stats ( s -> blk ) , & req -> acct ) ; virtio_blk_free_request ( req ) ; } blk_error_action ( s -> blk , action , is_read , error ) ; return action != BLOCK_ERROR_ACTION_IGNORE ; }##::##1##::##9481
static CharDriverState * qemu_chr_open_tty ( QemuOpts * opts ) { const char * filename = qemu_opt_get ( opts , "path" ) ; CharDriverState * chr ; int fd ; TFR ( fd = open ( filename , O_RDWR | O_NONBLOCK ) ) ; if ( fd < 0 ) { return NULL ; } tty_serial_init ( fd , 115200 , 'N' , 8 , 1 ) ; chr = qemu_chr_open_fd ( fd , fd ) ; if ( ! chr ) { close ( fd ) ; return NULL ; } chr -> chr_ioctl = tty_serial_ioctl ; chr -> chr_close = qemu_chr_close_tty ; return chr ; }##::##1##::##11301
static void test_visitor_in_union_flat ( TestInputVisitorData * data , const void * unused ) { Visitor * v ; UserDefFlatUnion * tmp ; UserDefUnionBase * base ; v = visitor_input_test_init ( data , "{ 'enum1': 'value1', " "'integer': 41, " "'string': 'str', " "'boolean': true }" ) ; visit_type_UserDefFlatUnion ( v , NULL , & tmp , & error_abort ) ; g_assert_cmpint ( tmp -> enum1 , == , ENUM_ONE_VALUE1 ) ; g_assert_cmpstr ( tmp -> string , == , "str" ) ; g_assert_cmpint ( tmp -> integer , == , 41 ) ; g_assert_cmpint ( tmp -> u . value1 -> boolean , == , true ) ; base = qapi_UserDefFlatUnion_base ( tmp ) ; g_assert ( & base -> enum1 == & tmp -> enum1 ) ; qapi_free_UserDefFlatUnion ( tmp ) ; }##::##1##::##2722
static inline void RENAME ( yuv2yuvX ) ( SwsContext * c , const int16_t * lumFilter , const int16_t * * lumSrc , int lumFilterSize , const int16_t * chrFilter , const int16_t * * chrUSrc , const int16_t * * chrVSrc , int chrFilterSize , const int16_t * * alpSrc , uint8_t * dest , uint8_t * uDest , uint8_t * vDest , uint8_t * aDest , long dstW , long chrDstW ) { if ( uDest ) { YSCALEYUV2YV12X ( CHR_MMX_FILTER_OFFSET , uDest , chrDstW , 0 ) YSCALEYUV2YV12X ( CHR_MMX_FILTER_OFFSET , vDest , chrDstW + c -> uv_off , c -> uv_off ) } if ( CONFIG_SWSCALE_ALPHA && aDest ) { YSCALEYUV2YV12X ( ALP_MMX_FILTER_OFFSET , aDest , dstW , 0 ) } YSCALEYUV2YV12X ( LUM_MMX_FILTER_OFFSET , dest , dstW , 0 ) }##::##1##::##10701
static inline void RENAME ( yuv2yuvX_ar ) ( SwsContext * c , const int16_t * lumFilter , const int16_t * * lumSrc , int lumFilterSize , const int16_t * chrFilter , const int16_t * * chrUSrc , const int16_t * * chrVSrc , int chrFilterSize , const int16_t * * alpSrc , uint8_t * dest , uint8_t * uDest , uint8_t * vDest , uint8_t * aDest , long dstW , long chrDstW ) { if ( uDest ) { YSCALEYUV2YV12X_ACCURATE ( CHR_MMX_FILTER_OFFSET , uDest , chrDstW , 0 ) YSCALEYUV2YV12X_ACCURATE ( CHR_MMX_FILTER_OFFSET , vDest , chrDstW + c -> uv_off , c -> uv_off ) } if ( CONFIG_SWSCALE_ALPHA && aDest ) { YSCALEYUV2YV12X_ACCURATE ( ALP_MMX_FILTER_OFFSET , aDest , dstW , 0 ) } YSCALEYUV2YV12X_ACCURATE ( LUM_MMX_FILTER_OFFSET , dest , dstW , 0 ) }##::##1##::##8356
static void do_change_vnc ( const char * target ) { if ( strcmp ( target , "passwd" ) == 0 || strcmp ( target , "password" ) == 0 ) { char password [ 9 ] ; monitor_readline ( "Password: " , 1 , password , sizeof ( password ) - 1 ) ; password [ sizeof ( password ) - 1 ] = '\0' ; if ( vnc_display_password ( NULL , password ) < 0 ) { term_printf ( "could not set VNC server password\n" ) ; } } else { if ( vnc_display_open ( NULL , target ) < 0 ) { term_printf ( "could not start VNC server on %s\n" , target ) ; } } }##::##1##::##11507
void esp_init ( target_phys_addr_t espaddr , int it_shift , espdma_memory_read_write dma_memory_read , espdma_memory_read_write dma_memory_write , void * dma_opaque , qemu_irq irq , qemu_irq * reset ) { DeviceState * dev ; SysBusDevice * s ; ESPState * esp ; dev = qdev_create ( NULL , "esp" ) ; esp = DO_UPCAST ( ESPState , busdev . qdev , dev ) ; esp -> dma_memory_read = dma_memory_read ; esp -> dma_memory_write = dma_memory_write ; esp -> dma_opaque = dma_opaque ; esp -> it_shift = it_shift ; qdev_init ( dev ) ; s = sysbus_from_qdev ( dev ) ; sysbus_connect_irq ( s , 0 , irq ) ; sysbus_mmio_map ( s , 0 , espaddr ) ; * reset = qdev_get_gpio_in ( dev , 0 ) ; }##::##1##::##11364
static void mmubooke_create_initial_mapping ( CPUPPCState * env , target_ulong va , hwaddr pa ) { ppcemb_tlb_t * tlb = & env -> tlb . tlbe [ 0 ] ; tlb -> attr = 0 ; tlb -> prot = PAGE_VALID | ( ( PAGE_READ | PAGE_WRITE | PAGE_EXEC ) << 4 ) ; tlb -> size = 1 << 31 ; tlb -> EPN = va & TARGET_PAGE_MASK ; tlb -> RPN = pa & TARGET_PAGE_MASK ; tlb -> PID = 0 ; tlb = & env -> tlb . tlbe [ 1 ] ; tlb -> attr = 0 ; tlb -> prot = PAGE_VALID | ( ( PAGE_READ | PAGE_WRITE | PAGE_EXEC ) << 4 ) ; tlb -> size = 1 << 31 ; tlb -> EPN = 0x80000000 & TARGET_PAGE_MASK ; tlb -> RPN = 0x80000000 & TARGET_PAGE_MASK ; tlb -> PID = 0 ; }##::##1##::##5371
static void curses_setup ( void ) { int i , colour_default [ 8 ] = { COLOR_BLACK , COLOR_BLUE , COLOR_GREEN , COLOR_CYAN , COLOR_RED , COLOR_MAGENTA , COLOR_YELLOW , COLOR_WHITE , } ; initscr ( ) ; noecho ( ) ; intrflush ( stdscr , FALSE ) ; nodelay ( stdscr , TRUE ) ; nonl ( ) ; keypad ( stdscr , TRUE ) ; start_color ( ) ; raw ( ) ; scrollok ( stdscr , FALSE ) ; for ( i = 0 ; i < 64 ; i ++ ) { init_pair ( i , colour_default [ i & 7 ] , colour_default [ i >> 3 ] ) ; } }##::##1##::##12231
static int qemu_rdma_post_recv_control ( RDMAContext * rdma , int idx ) { struct ibv_recv_wr * bad_wr ; struct ibv_sge sge = { . addr = ( uint64_t ) ( rdma -> wr_data [ idx ] . control ) , . length = RDMA_CONTROL_MAX_BUFFER , . lkey = rdma -> wr_data [ idx ] . control_mr -> lkey , } ; struct ibv_recv_wr recv_wr = { . wr_id = RDMA_WRID_RECV_CONTROL + idx , . sg_list = & sge , . num_sge = 1 , } ; if ( ibv_post_recv ( rdma -> qp , & recv_wr , & bad_wr ) ) { return - 1 ; } return 0 ; }##::##1##::##7146
static void quorum_aio_finalize ( QuorumAIOCB * acb ) { BDRVQuorumState * s = acb -> common . bs -> opaque ; int i , ret = 0 ; if ( acb -> vote_ret ) { ret = acb -> vote_ret ; } acb -> common . cb ( acb -> common . opaque , ret ) ; if ( acb -> is_read ) { for ( i = 0 ; i < s -> num_children ; i ++ ) { qemu_vfree ( acb -> qcrs [ i ] . buf ) ; qemu_iovec_destroy ( & acb -> qcrs [ i ] . qiov ) ; } } g_free ( acb -> qcrs ) ; qemu_aio_release ( acb ) ; }##::##1##::##7265
static void coroutine_fn wait_for_overlapping_requests ( BlockDriverState * bs , int64_t sector_num , int nb_sectors ) { BdrvTrackedRequest * req ; int64_t cluster_sector_num ; int cluster_nb_sectors ; bool retry ;##::##1##::##1914
static int get_avc_nalsize ( H264Context * h , const uint8_t * buf , int buf_size , int * buf_index ) { int i , nalsize = 0 ; if ( * buf_index >= buf_size - h -> nal_length_size ) { return - 1 ; } for ( i = 0 ; i < h -> nal_length_size ; i ++ ) { nalsize = ( nalsize << 8 ) | buf [ ( * buf_index ) ++ ] ; } if ( nalsize <= 0 || nalsize > buf_size - * buf_index ) { av_log ( h -> avctx , AV_LOG_ERROR , "AVC: nal size %d\n" , nalsize ) ; return - 1 ; } return nalsize ; }##::##1##::##7415
static inline void RENAME ( rgb32ToUV ) ( uint8_t * dstU , uint8_t * dstV , uint8_t * src1 , uint8_t * src2 , int width ) { int i ; assert ( src1 == src2 ) ; for ( i = 0 ; i < width ; i ++ ) { const int a = ( ( uint32_t * ) src1 ) [ 2 * i + 0 ] ; const int e = ( ( uint32_t * ) src1 ) [ 2 * i + 1 ] ; const int l = ( a & 0xFF00FF ) + ( e & 0xFF00FF ) ; const int h = ( a & 0x00FF00 ) + ( e & 0x00FF00 ) ; const int r = l & 0x3FF ; const int g = h >> 8 ; const int b = l >> 16 ; dstU [ i ] = ( ( RU * r + GU * g + BU * b ) >> ( RGB2YUV_SHIFT + 1 ) ) + 128 ; dstV [ i ] = ( ( RV * r + GV * g + BV * b ) >> ( RGB2YUV_SHIFT + 1 ) ) + 128 ; } }##::##1##::##7361
static inline void RENAME ( bgr32ToUV ) ( uint8_t * dstU , uint8_t * dstV , uint8_t * src1 , uint8_t * src2 , int width ) { int i ; assert ( src1 == src2 ) ; for ( i = 0 ; i < width ; i ++ ) { const int a = ( ( uint32_t * ) src1 ) [ 2 * i + 0 ] ; const int e = ( ( uint32_t * ) src1 ) [ 2 * i + 1 ] ; const int l = ( a & 0xFF00FF ) + ( e & 0xFF00FF ) ; const int h = ( a & 0x00FF00 ) + ( e & 0x00FF00 ) ; const int b = l & 0x3FF ; const int g = h >> 8 ; const int r = l >> 16 ; dstU [ i ] = ( ( RU * r + GU * g + BU * b ) >> ( RGB2YUV_SHIFT + 1 ) ) + 128 ; dstV [ i ] = ( ( RV * r + GV * g + BV * b ) >> ( RGB2YUV_SHIFT + 1 ) ) + 128 ; } }##::##1##::##8191
static int qemu_rdma_write_flush ( QEMUFile * f , RDMAContext * rdma ) { int ret ; if ( ! rdma -> current_length ) { return 0 ; } ret = qemu_rdma_write_one ( f , rdma , rdma -> current_index , rdma -> current_addr , rdma -> current_length ) ; if ( ret < 0 ) { return ret ; } if ( ret == 0 ) { rdma -> nb_sent ++ ; DDDPRINTF ( "sent total: %d\n" , rdma -> nb_sent ) ; } rdma -> current_length = 0 ; rdma -> current_addr = 0 ; return 0 ; }##::##1##::##2772
static void secondary_do_checkpoint ( BDRVReplicationState * s , Error * * errp ) { Error * local_err = NULL ; int ret ; if ( ! s -> secondary_disk -> bs -> job ) { error_setg ( errp , "Backup job was cancelled unexpectedly" ) ; backup_do_checkpoint ( s -> secondary_disk -> bs -> job , & local_err ) ; if ( local_err ) { error_propagate ( errp , local_err ) ; ret = s -> active_disk -> bs -> drv -> bdrv_make_empty ( s -> active_disk -> bs ) ; if ( ret < 0 ) { error_setg ( errp , "Cannot make active disk empty" ) ; ret = s -> hidden_disk -> bs -> drv -> bdrv_make_empty ( s -> hidden_disk -> bs ) ; if ( ret < 0 ) { error_setg ( errp , "Cannot make hidden disk empty" ) ;##::##1##::##7940
static void close_slave ( TeeSlave * tee_slave ) { AVFormatContext * avf ; unsigned i ; avf = tee_slave -> avf ; for ( i = 0 ; i < avf -> nb_streams ; ++ i ) { AVBitStreamFilterContext * bsf_next , * bsf = tee_slave -> bsfs [ i ] ; while ( bsf ) { bsf_next = bsf -> next ; av_bitstream_filter_close ( bsf ) ; bsf = bsf_next ; } } av_freep ( & tee_slave -> stream_map ) ; av_freep ( & tee_slave -> bsfs ) ; ff_format_io_close ( avf , & avf -> pb ) ; avformat_free_context ( avf ) ; tee_slave -> avf = NULL ; }##::##1##::##4187
static int bdrv_wr_badreq_bytes ( BlockDriverState * bs , int64_t offset , int count ) { int64_t size = bs -> total_sectors << SECTOR_BITS ; if ( count < 0 || offset < 0 ) { return 1 ; } if ( offset > size - count ) { if ( bs -> autogrow ) { bs -> total_sectors = ( offset + count + SECTOR_SIZE - 1 ) >> SECTOR_BITS ; } else { return 1 ; } } return 0 ; }##::##1##::##5655
static void pci_bus_init ( PCIBus * bus , DeviceState * parent , const char * name , MemoryRegion * address_space_mem , MemoryRegion * address_space_io , uint8_t devfn_min ) { assert ( PCI_FUNC ( devfn_min ) == 0 ) ; bus -> devfn_min = devfn_min ; bus -> address_space_mem = address_space_mem ; bus -> address_space_io = address_space_io ; memory_region_init_io ( & bus -> master_abort_mem , OBJECT ( bus ) , & master_abort_mem_ops , bus , "pci-master-abort" , memory_region_size ( bus -> address_space_mem ) ) ; memory_region_add_subregion_overlap ( bus -> address_space_mem , 0 , & bus -> master_abort_mem , MASTER_ABORT_MEM_PRIORITY ) ; QLIST_INIT ( & bus -> child ) ; pci_host_bus_register ( bus , parent ) ; vmstate_register ( NULL , - 1 , & vmstate_pcibus , bus ) ; }##::##1##::##7269
static void report_unavailable_features ( FeatureWord w , uint32_t mask ) { FeatureWordInfo * f = & feature_word_info [ w ] ; int i ; for ( i = 0 ; i < 32 ; ++ i ) { if ( 1 << i & mask ) { const char * reg = get_register_name_32 ( f -> cpuid_reg ) ; assert ( reg ) ; fprintf ( stderr , "warning: %s doesn't support requested feature: " "CPUID.%02XH:%s%s%s [bit %d]\n" , kvm_enabled ( ) ? "host" : "TCG" , f -> cpuid_eax , reg , f -> feat_names [ i ] ? "." : "" , f -> feat_names [ i ] ? f -> feat_names [ i ] : "" , i ) ; } } }##::##1##::##4572
rfc3986_parse_port ( URI * uri , const char * * str ) { const char * cur = * str ; if ( ISA_DIGIT ( cur ) ) { if ( uri != NULL ) { uri -> port = 0 ; } while ( ISA_DIGIT ( cur ) ) { if ( uri != NULL ) { uri -> port = uri -> port * 10 + ( * cur - '0' ) ; } cur ++ ; } * str = cur ; return ( 0 ) ; } return ( 1 ) ; }##::##1##::##7758
av_cold void ff_vp9dsp_init ( VP9DSPContext * dsp , int bpp ) { if ( bpp == 8 ) { ff_vp9dsp_init_8 ( dsp ) ; } else if ( bpp == 10 ) { ff_vp9dsp_init_10 ( dsp ) ; } else { av_assert0 ( bpp == 12 ) ; ff_vp9dsp_init_12 ( dsp ) ; } if ( ARCH_X86 ) { ff_vp9dsp_init_x86 ( dsp , bpp ) ; } if ( ARCH_MIPS ) { ff_vp9dsp_init_mips ( dsp , bpp ) ; } }##::##1##::##5817
static int decode0 ( GetByteContext * gb , RangeCoder * rc , unsigned cumFreq , unsigned freq , unsigned total_freq ) { int t ; if ( total_freq == 0 ) { return AVERROR_INVALIDDATA ; } t = rc -> range * ( uint64_t ) cumFreq / total_freq ; rc -> code1 += t + 1 ; rc -> range = rc -> range * ( uint64_t ) ( freq + cumFreq ) / total_freq - ( t + 1 ) ; while ( rc -> range < TOP && bytestream2_get_bytes_left ( gb ) > 0 ) { unsigned byte = bytestream2_get_byte ( gb ) ; rc -> code = ( rc -> code << 8 ) | byte ; rc -> code1 <<= 8 ; rc -> range <<= 8 ; } return 0 ; }##::##1##::##8970
static void digic_uart_write ( void * opaque , hwaddr addr , uint64_t value , unsigned size ) { DigicUartState * s = opaque ; unsigned char ch = value ; addr >>= 2 ; switch ( addr ) { case R_TX : if ( s -> chr ) { qemu_chr_fe_write_all ( s -> chr , & ch , 1 ) ; } break ; case R_ST : break ; default : qemu_log_mask ( LOG_UNIMP , "digic-uart: write access to unknown register 0x" TARGET_FMT_plx , addr << 2 ) ; } }##::##1##::##8730
static target_ulong get_psr ( void ) { helper_compute_psr ( ) ; # if ! defined ( TARGET_SPARC64 ) return env -> version | ( env -> psr & PSR_ICC ) | ( env -> psref ? PSR_EF : 0 ) | ( env -> psrpil << 8 ) | ( env -> psrs ? PSR_S : 0 ) | ( env -> psrps ? PSR_PS : 0 ) | ( env -> psret ? PSR_ET : 0 ) | env -> cwp ; # else return env -> version | ( env -> psr & PSR_ICC ) | ( env -> psref ? PSR_EF : 0 ) | ( env -> psrpil << 8 ) | ( env -> psrs ? PSR_S : 0 ) | ( env -> psrps ? PSR_PS : 0 ) | env -> cwp ; # endif }##::##1##::##4827
static void rxfilter_notify ( NetClientState * nc ) { QObject * event_data ; VirtIONet * n = qemu_get_nic_opaque ( nc ) ; if ( nc -> rxfilter_notify_enabled ) { if ( n -> netclient_name ) { event_data = qobject_from_jsonf ( "{ 'name': %s, 'path': %s }" , n -> netclient_name , object_get_canonical_path ( OBJECT ( n -> qdev ) ) ) ; } else { event_data = qobject_from_jsonf ( "{ 'path': %s }" , object_get_canonical_path ( OBJECT ( n -> qdev ) ) ) ; } monitor_protocol_event ( QEVENT_NIC_RX_FILTER_CHANGED , event_data ) ; qobject_decref ( event_data ) ; nc -> rxfilter_notify_enabled = 0 ; } }##::##1##::##8044
static CharDriverState * qemu_chr_open_stdio ( QemuOpts * opts ) { CharDriverState * chr ; if ( stdio_nb_clients >= STDIO_MAX_CLIENTS ) { if ( stdio_nb_clients == 0 ) { old_fd0_flags = fcntl ( 0 , F_GETFL ) ; tcgetattr ( 0 , & oldtty ) ; fcntl ( 0 , F_SETFL , O_NONBLOCK ) ; atexit ( term_exit ) ; chr = qemu_chr_open_fd ( 0 , 1 ) ; chr -> chr_close = qemu_chr_close_stdio ; chr -> chr_set_echo = qemu_chr_set_echo_stdio ; qemu_set_fd_handler2 ( 0 , stdio_read_poll , stdio_read , NULL , chr ) ; stdio_nb_clients ++ ; stdio_allow_signal = qemu_opt_get_bool ( opts , "signal" , display_type != DT_NOGRAPHIC ) ; qemu_chr_fe_set_echo ( chr , false ) ; return chr ;##::##1##::##4854
static void pc_dimm_unplug ( HotplugHandler * hotplug_dev , DeviceState * dev , Error * * errp ) { PCMachineState * pcms = PC_MACHINE ( hotplug_dev ) ; PCDIMMDevice * dimm = PC_DIMM ( dev ) ; PCDIMMDeviceClass * ddc = PC_DIMM_GET_CLASS ( dimm ) ; MemoryRegion * mr = ddc -> get_memory_region ( dimm ) ; HotplugHandlerClass * hhc ; Error * local_err = NULL ; hhc = HOTPLUG_HANDLER_GET_CLASS ( pcms -> acpi_dev ) ; hhc -> unplug ( HOTPLUG_HANDLER ( pcms -> acpi_dev ) , dev , & local_err ) ; if ( local_err ) { goto out ; } pc_dimm_memory_unplug ( dev , & pcms -> hotplug_memory , mr ) ; object_unparent ( OBJECT ( dev ) ) ; out : error_propagate ( errp , local_err ) ; }##::##1##::##11117
static int colo_packet_compare_udp ( Packet * spkt , Packet * ppkt ) { int ret ; int network_header_length = ppkt -> ip -> ip_hl * 4 ; trace_colo_compare_main ( "compare udp" ) ; ret = colo_packet_compare_common ( ppkt , spkt , network_header_length + ETH_HLEN ) ; if ( ret ) { trace_colo_compare_udp_miscompare ( "primary pkt size" , ppkt -> size ) ; trace_colo_compare_udp_miscompare ( "Secondary pkt size" , spkt -> size ) ; if ( trace_event_get_state ( TRACE_COLO_COMPARE_MISCOMPARE ) ) { qemu_hexdump ( ( char * ) ppkt -> data , stderr , "colo-compare pri pkt" , ppkt -> size ) ; qemu_hexdump ( ( char * ) spkt -> data , stderr , "colo-compare sec pkt" , spkt -> size ) ; } } return ret ; }##::##1##::##4409
static void rtas_ibm_read_pci_config ( sPAPREnvironment * spapr , uint32_t token , uint32_t nargs , target_ulong args , uint32_t nret , target_ulong rets ) { uint32_t val , size , addr ; uint64_t buid = ( ( uint64_t ) rtas_ld ( args , 1 ) << 32 ) | rtas_ld ( args , 2 ) ; PCIDevice * dev = find_dev ( spapr , buid , rtas_ld ( args , 0 ) ) ; if ( ! dev ) { rtas_st ( rets , 0 , - 1 ) ; return ; } size = rtas_ld ( args , 3 ) ; addr = rtas_pci_cfgaddr ( rtas_ld ( args , 0 ) ) ; val = pci_default_read_config ( dev , addr , size ) ; rtas_st ( rets , 0 , 0 ) ; rtas_st ( rets , 1 , val ) ; }##::##1##::##4547
int qcrypto_hash_bytesv ( QCryptoHashAlgorithm alg , const struct iovec * iov , size_t niov , uint8_t * * result , size_t * resultlen , Error * * errp ) { # ifdef CONFIG_AF_ALG int ret ; ret = qcrypto_hash_afalg_driver . hash_bytesv ( alg , iov , niov , result , resultlen , errp ) ; if ( ret == 0 ) { return ret ; } error_free ( * errp ) ; # endif return qcrypto_hash_lib_driver . hash_bytesv ( alg , iov , niov , result , resultlen , errp ) ; }##::##1##::##8241
DISAS_INSN ( shift_reg ) { TCGv reg ; TCGv shift ; reg = DREG ( insn , 0 ) ; shift = DREG ( insn , 9 ) ; if ( insn & 0x100 ) { gen_helper_shl_cc ( reg , cpu_env , reg , shift ) ; } else { if ( insn & 8 ) { gen_helper_shr_cc ( reg , cpu_env , reg , shift ) ; } else { gen_helper_sar_cc ( reg , cpu_env , reg , shift ) ; } } set_cc_op ( s , CC_OP_FLAGS ) ; }##::##1##::##8268
static inline void gen_store ( DisasContext * s , int opsize , TCGv addr , TCGv val ) { int index = IS_USER ( s ) ; s -> is_mem = 1 ; switch ( opsize ) { case OS_BYTE : tcg_gen_qemu_st8 ( val , addr , index ) ; break ; case OS_WORD : tcg_gen_qemu_st16 ( val , addr , index ) ; break ; case OS_LONG : case OS_SINGLE : tcg_gen_qemu_st32 ( val , addr , index ) ; break ; default : qemu_assert ( 0 , "bad store size" ) ; } gen_throws_exception = gen_last_qop ; }##::##1##::##9854
static inline void do_rfi ( CPUPPCState * env , target_ulong nip , target_ulong msr ) { CPUState * cs = CPU ( ppc_env_get_cpu ( env ) ) ; msr &= ~ ( 1ULL << MSR_POW ) ; # if defined ( TARGET_PPC64 ) if ( ! msr_is_64bit ( env , msr ) ) { nip = ( uint32_t ) nip ; } # else nip = ( uint32_t ) nip ; # endif env -> nip = nip & ~ ( ( target_ulong ) 0x00000003 ) ; hreg_store_msr ( env , msr , 1 ) ; # if defined ( DEBUG_OP ) cpu_dump_rfi ( env -> nip , env -> msr ) ; # endif cs -> interrupt_request |= CPU_INTERRUPT_EXITTB ; check_tlb_flush ( env ) ; }##::##1##::##9049
bool st_set_trace_file ( const char * file ) { st_set_trace_file_enabled ( false ) ; free ( trace_file_name ) ; if ( ! file ) { if ( asprintf ( & trace_file_name , CONFIG_TRACE_FILE , getpid ( ) ) < 0 ) { trace_file_name = NULL ; return false ; } } else { if ( asprintf ( & trace_file_name , "%s" , file ) < 0 ) { trace_file_name = NULL ; return false ; } } st_set_trace_file_enabled ( true ) ; return true ; }##::##1##::##8374
static int ass_decode_frame ( AVCodecContext * avctx , void * data , int * got_sub_ptr , AVPacket * avpkt ) { const char * ptr = avpkt -> data ; int len , size = avpkt -> size ; while ( size > 0 ) { ASSDialog * dialog = ff_ass_split_dialog ( avctx -> priv_data , ptr , 0 , NULL ) ; int duration = dialog -> end - dialog -> start ; len = ff_ass_add_rect ( data , ptr , 0 , duration , 1 ) ; if ( len < 0 ) { return len ; } ptr += len ; size -= len ; } * got_sub_ptr = avpkt -> size > 0 ; return avpkt -> size ; }##::##1##::##7844
static void rtas_ibm_write_pci_config ( sPAPREnvironment * spapr , uint32_t token , uint32_t nargs , target_ulong args , uint32_t nret , target_ulong rets ) { uint32_t val , size , addr ; uint64_t buid = ( ( uint64_t ) rtas_ld ( args , 1 ) << 32 ) | rtas_ld ( args , 2 ) ; PCIDevice * dev = find_dev ( spapr , buid , rtas_ld ( args , 0 ) ) ; if ( ! dev ) { rtas_st ( rets , 0 , - 1 ) ; return ; } val = rtas_ld ( args , 4 ) ; size = rtas_ld ( args , 3 ) ; addr = rtas_pci_cfgaddr ( rtas_ld ( args , 0 ) ) ; pci_default_write_config ( dev , addr , val , size ) ; rtas_st ( rets , 0 , 0 ) ; }##::##1##::##8265
QObject * qmp_dispatch ( QObject * request ) { Error * err = NULL ; QObject * ret ; QDict * rsp ; ret = do_qmp_dispatch ( request , & err ) ; rsp = qdict_new ( ) ; if ( err ) { qdict_put_obj ( rsp , "error" , error_get_qobject ( err ) ) ; error_free ( err ) ; } else if ( ret ) { qdict_put_obj ( rsp , "return" , ret ) ; } else { QDECREF ( rsp ) ; return NULL ; } return QOBJECT ( rsp ) ; }##::##1##::##12294
int scsi_convert_sense ( uint8_t * in_buf , int in_len , uint8_t * buf , int len , bool fixed ) { SCSISense sense ; bool fixed_in ; fixed_in = ( in_buf [ 0 ] & 2 ) == 0 ; if ( in_len && fixed == fixed_in ) { memcpy ( buf , in_buf , MIN ( len , in_len ) ) ; return MIN ( len , in_len ) ; } if ( in_len == 0 ) { sense = SENSE_CODE ( NO_SENSE ) ; } else { sense = scsi_parse_sense_buf ( in_buf , in_len ) ; } return scsi_build_sense_buf ( buf , len , sense , fixed ) ; }##::##1##::##11918
static int check_bind ( struct sockaddr * sa , socklen_t salen , bool * has_proto ) { int fd ; fd = socket ( sa -> sa_family , SOCK_STREAM , 0 ) ; if ( fd < 0 ) { return - 1 ; } if ( bind ( fd , sa , salen ) < 0 ) { close ( fd ) ; if ( errno == EADDRNOTAVAIL ) { * has_proto = false ; return 0 ; } return - 1 ; } close ( fd ) ; * has_proto = true ; return 0 ; }##::##1##::##6526
void scsi_req_unref ( SCSIRequest * req ) { assert ( req -> refcount > 0 ) ; if ( -- req -> refcount == 0 ) { BusState * qbus = req -> dev -> qdev . parent_bus ; SCSIBus * bus = DO_UPCAST ( SCSIBus , qbus , qbus ) ; if ( bus -> info -> free_request && req -> hba_private ) { bus -> info -> free_request ( bus , req -> hba_private ) ; } if ( req -> ops -> free_req ) { req -> ops -> free_req ( req ) ; } object_unref ( OBJECT ( req -> dev ) ) ; object_unref ( OBJECT ( qbus -> parent ) ) ; g_free ( req ) ; } }##::##1##::##2565
size_t qemu_mempath_getpagesize ( const char * mem_path ) { # ifdef CONFIG_LINUX struct statfs fs ; int ret ; do { ret = statfs ( mem_path , & fs ) ; } while ( ret != 0 && errno == EINTR ) ; if ( ret != 0 ) { fprintf ( stderr , "Couldn't statfs() memory path: %s\n" , strerror ( errno ) ) ; exit ( 1 ) ; } if ( fs . f_type == HUGETLBFS_MAGIC ) { return fs . f_bsize ; } return getpagesize ( ) ; }##::##1##::##9914
static void vnc_dpy_update ( DisplayChangeListener * dcl , int x , int y , int w , int h ) { VncDisplay * vd = container_of ( dcl , VncDisplay , dcl ) ; struct VncSurface * s = & vd -> guest ; int width = surface_width ( vd -> ds ) ; int height = surface_height ( vd -> ds ) ; w += ( x % VNC_DIRTY_PIXELS_PER_BIT ) ; x -= ( x % VNC_DIRTY_PIXELS_PER_BIT ) ; x = MIN ( x , width ) ; y = MIN ( y , height ) ; w = MIN ( x + w , width ) - x ; h = MIN ( y + h , height ) ; for ( ; y < h ; y ++ ) { bitmap_set ( s -> dirty [ y ] , x / VNC_DIRTY_PIXELS_PER_BIT , DIV_ROUND_UP ( w , VNC_DIRTY_PIXELS_PER_BIT ) ) ; } }##::##1##::##11299
static av_cold int cinepak_encode_end ( AVCodecContext * avctx ) { CinepakEncContext * s = avctx -> priv_data ; int x ; av_free ( s -> codebook_input ) ; av_free ( s -> codebook_closest ) ; av_free ( s -> strip_buf ) ; av_free ( s -> frame_buf ) ; av_free ( s -> mb ) ; # ifdef CINEPAKENC_DEBUG av_free ( s -> best_mb ) ; # endif for ( x = 0 ; x < 3 ; x ++ ) { av_free ( s -> pict_bufs [ x ] ) ; } av_log ( avctx , AV_LOG_INFO , "strip coding stats: %i V1 mode, %i V4 mode, %i MC mode (%i V1 encs, %i V4 encs, %i skips)\n" , s -> num_v1_mode , s -> num_v4_mode , s -> num_mc_mode , s -> num_v1_encs , s -> num_v4_encs , s -> num_skips ) ; return 0 ; }##::##1##::##5798
void mulu64 ( uint64_t * phigh , uint64_t * plow , uint64_t a , uint64_t b ) { # if defined ( __x86_64__ ) __asm__ ( "mul %0\n\t" : "=d" ( * phigh ) , "=a" ( * plow ) : "a" ( a ) , "0" ( b ) ) ; # else uint64_t ph , pm1 , pm2 , pl ; pl = ( uint64_t ) ( ( uint32_t ) a ) * ( uint64_t ) ( ( uint32_t ) b ) ; pm1 = ( a >> 32 ) * ( uint32_t ) b ; pm2 = ( uint32_t ) a * ( b >> 32 ) ; ph = ( a >> 32 ) * ( b >> 32 ) ; ph += pm1 >> 32 ; pm1 = ( uint64_t ) ( ( uint32_t ) pm1 ) + pm2 + ( pl >> 32 ) ; * phigh = ph + ( pm1 >> 32 ) ; * plow = ( pm1 << 32 ) + ( uint32_t ) pl ; # endif }##::##1##::##316
int av_packet_add_side_data ( AVPacket * pkt , enum AVPacketSideDataType type , uint8_t * data , size_t size ) { int elems = pkt -> side_data_elems ; if ( ( unsigned ) elems + 1 > INT_MAX / sizeof ( * pkt -> side_data ) ) { return AVERROR ( ERANGE ) ; } pkt -> side_data = av_realloc ( pkt -> side_data , ( elems + 1 ) * sizeof ( * pkt -> side_data ) ) ; if ( ! pkt -> side_data ) { return AVERROR ( ENOMEM ) ; } pkt -> side_data [ elems ] . data = data ; pkt -> side_data [ elems ] . size = size ; pkt -> side_data [ elems ] . type = type ; pkt -> side_data_elems ++ ; return 0 ; }##::##1##::##8063
void usb_ehci_realize ( EHCIState * s , DeviceState * dev , Error * * errp ) { int i ; if ( s -> portnr > NB_PORTS ) { error_setg ( errp , "Too many ports! Max. port number is %d." , NB_PORTS ) ; usb_bus_new ( & s -> bus , sizeof ( s -> bus ) , s -> companion_enable ? & ehci_bus_ops_companion : & ehci_bus_ops_standalone , dev ) ; for ( i = 0 ; i < s -> portnr ; i ++ ) { usb_register_port ( & s -> bus , & s -> ports [ i ] , s , i , & ehci_port_ops , USB_SPEED_MASK_HIGH ) ; s -> ports [ i ] . dev = 0 ; s -> frame_timer = timer_new_ns ( QEMU_CLOCK_VIRTUAL , ehci_work_timer , s ) ; s -> async_bh = qemu_bh_new ( ehci_work_bh , s ) ; s -> device = dev ; s -> vmstate = qemu_add_vm_change_state_handler ( usb_ehci_vm_state_change , s ) ;##::##1##::##104
unsigned long virtio_load_direct ( ulong rec_list1 , ulong rec_list2 , ulong subchan_id , void * load_addr ) { u8 status ; int sec = rec_list1 ; int sec_num = ( ( rec_list2 >> 32 ) & 0xffff ) + 1 ; int sec_len = rec_list2 >> 48 ; ulong addr = ( ulong ) load_addr ; if ( sec_len != virtio_get_block_size ( ) ) { return - 1 ; } sclp_print ( "." ) ; status = virtio_read_many ( sec , ( void * ) addr , sec_num ) ; if ( status ) { virtio_panic ( "I/O Error" ) ; } addr += sec_num * virtio_get_block_size ( ) ; return addr ; }##::##1##::##242
static void clear_commits ( BDRVVVFATState * s ) { int i ; DLOG ( fprintf ( stderr , "clear_commits (%d commits)\n" , s -> commits . next ) ) ; for ( i = 0 ; i < s -> commits . next ; i ++ ) { commit_t * commit = array_get ( & ( s -> commits ) , i ) ; assert ( commit -> path || commit -> action == ACTION_WRITEOUT ) ; if ( commit -> action != ACTION_WRITEOUT ) { assert ( commit -> path ) ; free ( commit -> path ) ; } else { assert ( commit -> path == NULL ) ; } } s -> commits . next = 0 ; }##::##1##::##3017
static void qed_read_l2_table_cb ( void * opaque , int ret ) { QEDReadL2TableCB * read_l2_table_cb = opaque ; QEDRequest * request = read_l2_table_cb -> request ; BDRVQEDState * s = read_l2_table_cb -> s ; CachedL2Table * l2_table = request -> l2_table ; if ( ret ) { qed_unref_l2_cache_entry ( l2_table ) ; request -> l2_table = NULL ; } else { l2_table -> offset = read_l2_table_cb -> l2_offset ; qed_commit_l2_cache_entry ( & s -> l2_cache , l2_table ) ; request -> l2_table = qed_find_l2_cache_entry ( & s -> l2_cache , l2_table -> offset ) ; assert ( request -> l2_table != NULL ) ; } gencb_complete ( & read_l2_table_cb -> gencb , ret ) ; }##::##1##::##10471
static BlockAIOCB * hdev_aio_ioctl ( BlockDriverState * bs , unsigned long int req , void * buf , BlockCompletionFunc * cb , void * opaque ) { BDRVRawState * s = bs -> opaque ; RawPosixAIOData * acb ; ThreadPool * pool ; if ( fd_open ( bs ) < 0 ) { return NULL ; } acb = g_new ( RawPosixAIOData , 1 ) ; acb -> bs = bs ; acb -> aio_type = QEMU_AIO_IOCTL ; acb -> aio_fildes = s -> fd ; acb -> aio_offset = 0 ; acb -> aio_ioctl_buf = buf ; acb -> aio_ioctl_cmd = req ; pool = aio_get_thread_pool ( bdrv_get_aio_context ( bs ) ) ; return thread_pool_submit_aio ( pool , aio_worker , acb , cb , opaque ) ;##::##1##::##10809
static void init_parse_context ( OptionParseContext * octx , const OptionGroupDef * groups , int nb_groups ) { static const OptionGroupDef global_group = { "global" } ; int i ; memset ( octx , 0 , sizeof ( * octx ) ) ; octx -> nb_groups = nb_groups ; octx -> groups = av_mallocz ( sizeof ( * octx -> groups ) * octx -> nb_groups ) ; if ( ! octx -> groups ) { exit ( 1 ) ; } for ( i = 0 ; i < octx -> nb_groups ; i ++ ) { octx -> groups [ i ] . group_def = & groups [ i ] ; } octx -> global_opts . group_def = & global_group ; octx -> global_opts . arg = "" ; init_opts ( ) ; }##::##1##::##11694
void ff_frame_thread_encoder_free ( AVCodecContext * avctx ) { int i ; ThreadContext * c = avctx -> internal -> frame_thread_encoder ; pthread_mutex_lock ( & c -> task_fifo_mutex ) ; c -> exit = 1 ; pthread_cond_broadcast ( & c -> task_fifo_cond ) ; pthread_mutex_unlock ( & c -> task_fifo_mutex ) ; for ( i = 0 ; i < avctx -> thread_count ; i ++ ) { pthread_join ( c -> worker [ i ] , NULL ) ; } pthread_mutex_destroy ( & c -> task_fifo_mutex ) ; pthread_mutex_destroy ( & c -> finished_task_mutex ) ; pthread_mutex_destroy ( & c -> buffer_mutex ) ; pthread_cond_destroy ( & c -> task_fifo_cond ) ; pthread_cond_destroy ( & c -> finished_task_cond ) ; av_fifo_freep ( & c -> task_fifo ) ; av_freep ( & avctx -> internal -> frame_thread_encoder ) ; }##::##1##::##7352
static CharDriverState * qemu_chr_open_mux ( CharDriverState * drv ) { CharDriverState * chr ; MuxDriver * d ; chr = qemu_chr_alloc ( ) ; d = g_malloc0 ( sizeof ( MuxDriver ) ) ; chr -> opaque = d ; d -> drv = drv ; d -> focus = - 1 ; chr -> chr_write = mux_chr_write ; chr -> chr_update_read_handler = mux_chr_update_read_handler ; chr -> chr_accept_input = mux_chr_accept_input ; chr -> chr_set_fe_open = NULL ; if ( drv -> chr_add_watch ) { chr -> chr_add_watch = mux_chr_add_watch ; } chr -> explicit_be_open = muxes_realized ? 0 : 1 ; chr -> is_mux = 1 ; return chr ; }##::##1##::##9355
static void test_tco_second_timeout_none ( void ) { TestData td ; const uint16_t ticks = TCO_SECS_TO_TICKS ( 256 ) ; QDict * ad ; td . args = "-watchdog-action none" ; td . noreboot = false ; test_init ( & td ) ; stop_tco ( & td ) ; clear_tco_status ( & td ) ; reset_on_second_timeout ( true ) ; set_tco_timeout ( & td , ticks ) ; load_tco ( & td ) ; start_tco ( & td ) ; clock_step ( ticks * TCO_TICK_NSEC * 2 ) ; ad = get_watchdog_action ( ) ; g_assert ( ! strcmp ( qdict_get_str ( ad , "action" ) , "none" ) ) ; QDECREF ( ad ) ; stop_tco ( & td ) ; qtest_end ( ) ; }##::##1##::##10953
static void loadvm_postcopy_handle_run_bh ( void * opaque ) { Error * local_err = NULL ; MigrationIncomingState * mis = opaque ; cpu_synchronize_all_post_init ( ) ; qemu_announce_self ( ) ; bdrv_invalidate_cache_all ( & local_err ) ; if ( local_err ) { error_report_err ( local_err ) ; } trace_loadvm_postcopy_handle_run_cpu_sync ( ) ; cpu_synchronize_all_post_init ( ) ; trace_loadvm_postcopy_handle_run_vmstart ( ) ; if ( autostart ) { vm_start ( ) ; } else { runstate_set ( RUN_STATE_PAUSED ) ; } qemu_bh_delete ( mis -> bh ) ; }##::##1##::##807
iscsi_unmap_cb ( struct iscsi_context * iscsi , int status , void * command_data , void * opaque ) { IscsiAIOCB * acb = opaque ; if ( acb -> canceled != 0 ) { qemu_aio_release ( acb ) ; scsi_free_scsi_task ( acb -> task ) ; acb -> task = NULL ; return ; } acb -> status = 0 ; if ( status < 0 ) { error_report ( "Failed to unmap data on iSCSI lun. %s" , iscsi_get_error ( iscsi ) ) ; acb -> status = - EIO ; } iscsi_schedule_bh ( acb ) ; scsi_free_scsi_task ( acb -> task ) ; acb -> task = NULL ; }##::##1##::##11662
iscsi_synccache10_cb ( struct iscsi_context * iscsi , int status , void * command_data , void * opaque ) { IscsiAIOCB * acb = opaque ; if ( acb -> canceled != 0 ) { qemu_aio_release ( acb ) ; scsi_free_scsi_task ( acb -> task ) ; acb -> task = NULL ; return ; } acb -> status = 0 ; if ( status < 0 ) { error_report ( "Failed to sync10 data on iSCSI lun. %s" , iscsi_get_error ( iscsi ) ) ; acb -> status = - EIO ; } iscsi_schedule_bh ( acb ) ; scsi_free_scsi_task ( acb -> task ) ; acb -> task = NULL ; }##::##1##::##3250
static CharDriverState * qemu_chr_open_stdio ( ChardevStdio * opts ) { CharDriverState * chr ; if ( is_daemonized ( ) ) { error_report ( "cannot use stdio with -daemonize" ) ; return NULL ; } old_fd0_flags = fcntl ( 0 , F_GETFL ) ; tcgetattr ( 0 , & oldtty ) ; qemu_set_nonblock ( 0 ) ; atexit ( term_exit ) ; chr = qemu_chr_open_fd ( 0 , 1 ) ; chr -> chr_close = qemu_chr_close_stdio ; chr -> chr_set_echo = qemu_chr_set_echo_stdio ; if ( opts -> has_signal ) { stdio_allow_signal = opts -> signal ; } qemu_chr_fe_set_echo ( chr , false ) ; return chr ; }##::##1##::##1488
void tlb_reset_dirty ( CPUState * cpu , ram_addr_t start1 , ram_addr_t length ) { CPUArchState * env ; int mmu_idx ; assert_cpu_is_self ( cpu ) ; env = cpu -> env_ptr ; for ( mmu_idx = 0 ; mmu_idx < NB_MMU_MODES ; mmu_idx ++ ) { unsigned int i ; for ( i = 0 ; i < CPU_TLB_SIZE ; i ++ ) { tlb_reset_dirty_range ( & env -> tlb_table [ mmu_idx ] [ i ] , start1 , length ) ; } for ( i = 0 ; i < CPU_VTLB_SIZE ; i ++ ) { tlb_reset_dirty_range ( & env -> tlb_v_table [ mmu_idx ] [ i ] , start1 , length ) ; } } }##::##1##::##2711
static int bad_mode_switch ( CPUARMState * env , int mode ) { switch ( mode ) { case ARM_CPU_MODE_USR : case ARM_CPU_MODE_SYS : case ARM_CPU_MODE_SVC : case ARM_CPU_MODE_ABT : case ARM_CPU_MODE_UND : case ARM_CPU_MODE_IRQ : case ARM_CPU_MODE_FIQ : return 0 ; case ARM_CPU_MODE_HYP : return ! arm_feature ( env , ARM_FEATURE_EL2 ) || arm_current_el ( env ) < 2 || arm_is_secure ( env ) ; case ARM_CPU_MODE_MON : return ! arm_is_secure ( env ) ; default : return 1 ; } }##::##1##::##11318
grlib_apbuart_writel ( void * opaque , target_phys_addr_t addr , uint32_t value ) { UART * uart = opaque ; unsigned char c = 0 ; addr &= 0xff ; switch ( addr ) { case DATA_OFFSET : c = value & 0xFF ; qemu_chr_write ( uart -> chr , & c , 1 ) ; return ; case STATUS_OFFSET : return ; case CONTROL_OFFSET : return ; case SCALER_OFFSET : return ; default : break ; } trace_grlib_apbuart_unknown_register ( "write" , addr ) ; }##::##1##::##11861
static void s390_cpu_class_init ( ObjectClass * oc , void * data ) { S390CPUClass * scc = S390_CPU_CLASS ( oc ) ; CPUClass * cc = CPU_CLASS ( scc ) ; DeviceClass * dc = DEVICE_CLASS ( oc ) ; scc -> parent_realize = dc -> realize ; dc -> realize = s390_cpu_realizefn ; scc -> parent_reset = cc -> reset ; cc -> reset = s390_cpu_reset ; cc -> do_interrupt = s390_cpu_do_interrupt ; cc -> dump_state = s390_cpu_dump_state ; cc -> set_pc = s390_cpu_set_pc ; cc -> gdb_read_register = s390_cpu_gdb_read_register ; cc -> gdb_write_register = s390_cpu_gdb_write_register ; # ifndef CONFIG_USER_ONLY cc -> get_phys_page_debug = s390_cpu_get_phys_page_debug ; # endif dc -> vmsd = & vmstate_s390_cpu ; cc -> gdb_num_core_regs = S390_NUM_REGS ; }##::##1##::##8683
static void nvme_rw_cb ( void * opaque , int ret ) { NvmeRequest * req = opaque ; NvmeSQueue * sq = req -> sq ; NvmeCtrl * n = sq -> ctrl ; NvmeCQueue * cq = n -> cq [ sq -> cqid ] ; block_acct_done ( blk_get_stats ( n -> conf . blk ) , & req -> acct ) ; if ( ! ret ) { req -> status = NVME_SUCCESS ; } else { req -> status = NVME_INTERNAL_DEV_ERROR ; } if ( req -> has_sg ) { qemu_sglist_destroy ( & req -> qsg ) ; } nvme_enqueue_req_completion ( cq , req ) ; }##::##1##::##4681
CharDriverState * qemu_chr_open ( const char * label , const char * filename , void ( * init ) ( struct CharDriverState * s ) ) { const char * p ; CharDriverState * chr ; QemuOpts * opts ; if ( strstart ( filename , "chardev:" , & p ) ) { return qemu_chr_find ( p ) ; } opts = qemu_chr_parse_compat ( label , filename ) ; if ( ! opts ) { return NULL ; } chr = qemu_chr_open_opts ( opts , init ) ; if ( chr && qemu_opt_get_bool ( opts , "mux" , 0 ) ) { monitor_init ( chr , MONITOR_USE_READLINE ) ; } return chr ; }##::##1##::##6274
void error_setg_win32 ( Error * * errp , int win32_err , const char * fmt , ... ) { va_list ap ; char * msg1 , * msg2 ; if ( errp == NULL ) { return ; } va_start ( ap , fmt ) ; error_setv ( errp , ERROR_CLASS_GENERIC_ERROR , fmt , ap ) ; va_end ( ap ) ; if ( win32_err != 0 ) { msg1 = ( * errp ) -> msg ; msg2 = g_win32_error_message ( win32_err ) ; ( * errp ) -> msg = g_strdup_printf ( "%s: %s (error: %x)" , msg1 , msg2 , ( unsigned ) win32_err ) ; g_free ( msg2 ) ; g_free ( msg1 ) ; } }##::##1##::##5165
target_ulong helper_udiv ( target_ulong a , target_ulong b ) { uint64_t x0 ; uint32_t x1 ; x0 = ( a & 0xffffffff ) | ( ( int64_t ) ( env -> y ) << 32 ) ; x1 = ( b & 0xffffffff ) ; if ( x1 == 0 ) { raise_exception ( TT_DIV_ZERO ) ; } x0 = x0 / x1 ; if ( x0 > 0xffffffff ) { env -> cc_src2 = 1 ; return 0xffffffff ; } else { env -> cc_src2 = 0 ; return x0 ; } }##::##1##::##7582
void dsputil_init_armv4l ( DSPContext * c , AVCodecContext * avctx ) { const int idct_algo = avctx -> idct_algo ; ff_put_pixels_clamped = c -> put_pixels_clamped ; ff_add_pixels_clamped = c -> add_pixels_clamped ; if ( idct_algo == FF_IDCT_ARM ) { if ( idct_algo == FF_IDCT_AUTO || idct_algo == FF_IDCT_ARM ) { c -> idct_put = j_rev_dct_ARM_put ; c -> idct_add = j_rev_dct_ARM_add ; c -> idct = j_rev_dct_ARM ; c -> idct_permutation_type = FF_LIBMPEG2_IDCT_PERM ; } else if ( idct_algo == FF_IDCT_SIMPLEARM ) { c -> idct_put = simple_idct_ARM_put ; c -> idct_add = simple_idct_ARM_add ; c -> idct = simple_idct_ARM ; } }##::##1##::##3318
static int64_t coroutine_fn bdrv_co_get_block_status_above ( BlockDriverState * bs , BlockDriverState * base , int64_t sector_num , int nb_sectors , int * pnum , BlockDriverState * * file ) { BlockDriverState * p ; int64_t ret = 0 ; assert ( bs != base ) ; for ( p = bs ; p != base ; p = backing_bs ( p ) ) { ret = bdrv_co_get_block_status ( p , sector_num , nb_sectors , pnum , file ) ; if ( ret < 0 || ret & BDRV_BLOCK_ALLOCATED ) { break ; } nb_sectors = MIN ( nb_sectors , * pnum ) ; } return ret ; }##::##1##::##4683
static CharDriverState * qmp_chardev_open_file ( ChardevFile * file , Error * * errp ) { int flags , in = - 1 , out = - 1 ; flags = O_WRONLY | O_TRUNC | O_CREAT | O_BINARY ; out = qmp_chardev_open_file_source ( file -> out , flags , errp ) ; if ( error_is_set ( errp ) ) { return NULL ; } if ( file -> has_in ) { flags = O_RDONLY ; in = qmp_chardev_open_file_source ( file -> in , flags , errp ) ; if ( error_is_set ( errp ) ) { qemu_close ( out ) ; return NULL ; } } return qemu_chr_open_fd ( in , out ) ; }##::##1##::##7250
static int protocol_client_vencrypt_init ( VncState * vs , uint8_t * data , size_t len ) { if ( data [ 0 ] != 0 || data [ 1 ] != 2 ) { VNC_DEBUG ( "Unsupported VeNCrypt protocol %d.%d\n" , ( int ) data [ 0 ] , ( int ) data [ 1 ] ) ; vnc_write_u8 ( vs , 1 ) ; vnc_flush ( vs ) ; vnc_client_error ( vs ) ; } else { VNC_DEBUG ( "Sending allowed auth %d\n" , vs -> subauth ) ; vnc_write_u8 ( vs , 0 ) ; vnc_write_u8 ( vs , 1 ) ; vnc_write_u32 ( vs , vs -> subauth ) ; vnc_flush ( vs ) ; vnc_read_when ( vs , protocol_client_vencrypt_auth , 4 ) ; } return 0 ; }##::##1##::##9994
static void hScale16To15_c ( SwsContext * c , int16_t * dst , int dstW , const uint8_t * _src , const int16_t * filter , const int16_t * filterPos , int filterSize ) { int i ; const uint16_t * src = ( const uint16_t * ) _src ; int sh = av_pix_fmt_descriptors [ c -> srcFormat ] . comp [ 0 ] . depth_minus1 ; for ( i = 0 ; i < dstW ; i ++ ) { int j ; int srcPos = filterPos [ i ] ; int val = 0 ; for ( j = 0 ; j < filterSize ; j ++ ) { val += src [ srcPos + j ] * filter [ filterSize * i + j ] ; } dst [ i ] = FFMIN ( val >> sh , ( 1 << 15 ) - 1 ) ; } }##::##1##::##2067
void * grow_array ( void * array , int elem_size , int * size , int new_size ) { if ( new_size >= INT_MAX / elem_size ) { av_log ( NULL , AV_LOG_ERROR , "Array too big.\n" ) ; exit ( 1 ) ; } if ( * size < new_size ) { uint8_t * tmp = av_realloc ( array , new_size * elem_size ) ; if ( ! tmp ) { av_log ( NULL , AV_LOG_ERROR , "Could not alloc buffer.\n" ) ; exit ( 1 ) ; } memset ( tmp + * size * elem_size , 0 , ( new_size - * size ) * elem_size ) ; * size = new_size ; return tmp ; } return array ; }##::##1##::##2199
static void test_keyval_visit_alternate ( void ) { Error * err = NULL ; Visitor * v ; QDict * qdict ; AltNumStr * ans ; AltNumInt * ani ; qdict = keyval_parse ( "a=1,b=2" , NULL , & error_abort ) ; v = qobject_input_visitor_new_keyval ( QOBJECT ( qdict ) ) ; QDECREF ( qdict ) ; visit_start_struct ( v , NULL , NULL , 0 , & error_abort ) ; visit_type_AltNumStr ( v , "a" , & ans , & error_abort ) ; g_assert_cmpint ( ans -> type , == , QTYPE_QSTRING ) ; g_assert_cmpstr ( ans -> u . s , == , "1" ) ; qapi_free_AltNumStr ( ans ) ; visit_type_AltNumInt ( v , "a" , & ani , & err ) ; error_free_or_abort ( & err ) ; visit_end_struct ( v , NULL ) ; visit_free ( v ) ; }##::##1##::##11236
int v9fs_co_st_gen ( V9fsPDU * pdu , V9fsPath * path , mode_t st_mode , V9fsStatDotl * v9stat ) { int err = 0 ; V9fsState * s = pdu -> s ; if ( v9fs_request_cancelled ( pdu ) ) { return - EINTR ; if ( s -> ctx . exops . get_st_gen ) { v9fs_path_read_lock ( s ) ; v9fs_co_run_in_worker ( { err = s -> ctx . exops . get_st_gen ( & s -> ctx , path , st_mode , & v9stat -> st_gen ) ; if ( err < 0 ) { err = - errno ; } ) ; v9fs_path_unlock ( s ) ; return err ;##::##1##::##5854
static void perf_cost ( void ) { const unsigned long maxcycles = 40000000 ; unsigned long i = 0 ; double duration ; unsigned long ops ; Coroutine * co ; g_test_timer_start ( ) ; while ( i ++ < maxcycles ) { co = qemu_coroutine_create ( perf_cost_func ) ; qemu_coroutine_enter ( co , & i ) ; qemu_coroutine_enter ( co , NULL ) ; } duration = g_test_timer_elapsed ( ) ; ops = ( long ) ( maxcycles / ( duration * 1000 ) ) ; g_test_message ( "Run operation %lu iterations %f s, %luK operations/s, " "%luns per coroutine" , maxcycles , duration , ops , ( unsigned long ) ( 1000000000 * duration ) / maxcycles ) ; }##::##1##::##489
static int read_packet ( AVFormatContext * s , AVPacket * pkt ) { FilmstripDemuxContext * film = s -> priv_data ; AVStream * st = s -> streams [ 0 ] ; if ( s -> pb -> eof_reached ) { return AVERROR ( EIO ) ; } pkt -> dts = avio_tell ( s -> pb ) / ( st -> codec -> width * ( st -> codec -> height + film -> leading ) * 4 ) ; pkt -> size = av_get_packet ( s -> pb , pkt , st -> codec -> width * st -> codec -> height * 4 ) ; avio_skip ( s -> pb , st -> codec -> width * film -> leading * 4 ) ; if ( pkt -> size < 0 ) { return pkt -> size ; } pkt -> flags |= AV_PKT_FLAG_KEY ; return 0 ; }##::##1##::##9679
static void serial_tx_done ( void * opaque ) { SerialState * s = opaque ; if ( s -> tx_burst < 0 ) { uint16_t divider ; if ( s -> divider ) { divider = s -> divider ; } else { divider = 1 ; } s -> tx_burst = THROTTLE_TX_INTERVAL * 1000 / ( 1000000 * 10 / ( s -> baudbase / divider ) ) ; } s -> thr_ipending = 1 ; s -> lsr |= UART_LSR_THRE ; s -> lsr |= UART_LSR_TEMT ; serial_update_irq ( s ) ; }##::##1##::##7669
static int vnc_auth_sasl_check_ssf ( VncState * vs ) { const void * val ; int err , ssf ; if ( ! vs -> sasl . wantSSF ) { return 1 ; } err = sasl_getprop ( vs -> sasl . conn , SASL_SSF , & val ) ; if ( err != SASL_OK ) { return 0 ; } ssf = * ( const int * ) val ; VNC_DEBUG ( "negotiated an SSF of %d\n" , ssf ) ; if ( ssf < 56 ) { return 0 ; } vs -> sasl . runSSF = 1 ; return 1 ; }##::##1##::##8213
