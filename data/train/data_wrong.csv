s##::##label##::##id
static unsigned int dec_subu_r ( DisasContext * dc ) { TCGv t0 ; int size = memsize_z ( dc ) ; DIS ( fprintf ( logfile , "subu.%c $r%u, $r%u\n" , memsize_char ( size ) , dc -> op1 , dc -> op2 ) ) ; cris_cc_mask ( dc , CC_MASK_NZVC ) ; t0 = tcg_temp_new ( TCG_TYPE_TL ) ; t_gen_zext ( t0 , cpu_R [ dc -> op1 ] , size ) ; cris_alu ( dc , CC_OP_SUB , cpu_R [ dc -> op2 ] , cpu_R [ dc -> op2 ] , t0 , 4 ) ; tcg_temp_free ( t0 ) ; return 2 ; }##::##0##::##917
static bool rtas_event_log_contains ( uint32_t event_mask ) { sPAPREventLogEntry * entry = NULL ; if ( ( event_mask & EVENT_MASK_EPOW ) == 0 ) { return false ; } QTAILQ_FOREACH ( entry , & spapr -> pending_events , next ) { if ( entry -> log_type == RTAS_LOG_TYPE_EPOW || entry -> log_type == RTAS_LOG_TYPE_HOTPLUG ) { return true ; } } return false ; }##::##0##::##12241
static void vfio_put_group ( VFIOGroup * group ) { if ( ! QLIST_EMPTY ( & group -> device_list ) ) { return ; } vfio_kvm_device_del_group ( group ) ; vfio_disconnect_container ( group ) ; QLIST_REMOVE ( group , next ) ; trace_vfio_put_group ( group -> fd ) ; close ( group -> fd ) ; g_free ( group ) ; if ( QLIST_EMPTY ( & group_list ) ) { qemu_unregister_reset ( vfio_pci_reset_handler , NULL ) ; } }##::##0##::##1716
void destroy_bdrvs ( dev_match_fn * match_fn , void * arg ) { DriveInfo * dinfo ; struct BlockDriverState * bs ; TAILQ_FOREACH ( dinfo , & drives , next ) { bs = dinfo -> bdrv ; if ( bs ) { if ( bs -> private && match_fn ( bs -> private , arg ) ) { drive_uninit ( bs ) ; bdrv_delete ( bs ) ; } } } }##::##0##::##4484
void cpu_single_step ( CPUState * cpu , int enabled ) { # if defined ( TARGET_HAS_ICE ) if ( cpu -> singlestep_enabled != enabled ) { cpu -> singlestep_enabled = enabled ; if ( kvm_enabled ( ) ) { kvm_update_guest_debug ( cpu , 0 ) ; } else { CPUArchState * env = cpu -> env_ptr ; tb_flush ( env ) ; } } # endif }##::##0##::##5826
static int gif_encode_frame ( AVCodecContext * avctx , unsigned char * outbuf , int buf_size , void * data ) { GIFContext * s = avctx -> priv_data ; AVFrame * pict = data ; AVFrame * const p = ( AVFrame * ) & s -> picture ; uint8_t * outbuf_ptr = outbuf ; * p = * pict ; p -> pict_type = FF_I_TYPE ; p -> key_frame = 1 ; gif_image_write_header ( & outbuf_ptr , avctx -> width , avctx -> height , - 1 , ( uint32_t * ) pict -> data [ 1 ] ) ; gif_image_write_image ( & outbuf_ptr , 0 , 0 , avctx -> width , avctx -> height , pict -> data [ 0 ] , pict -> linesize [ 0 ] , PIX_FMT_PAL8 ) ; return outbuf_ptr - outbuf ; }##::##0##::##1849
target_ulong helper_rdhwr_cc ( CPUMIPSState * env ) { if ( ( env -> hflags & MIPS_HFLAG_CP0 ) || ( env -> CP0_HWREna & ( 1 << 2 ) ) ) { # ifdef CONFIG_USER_ONLY return env -> CP0_Count ; # else return ( int32_t ) cpu_mips_get_count ( env ) ; # endif } else { do_raise_exception ( env , EXCP_RI , GETPC ( ) ) ; } return 0 ; }##::##0##::##6352
void qdev_unplug ( DeviceState * dev , Error * * errp ) { DeviceClass * dc = DEVICE_GET_CLASS ( dev ) ; if ( ! dev -> parent_bus -> allow_hotplug ) { error_set ( errp , QERR_BUS_NO_HOTPLUG , dev -> parent_bus -> name ) ; return ; } assert ( dc -> unplug != NULL ) ; qdev_hot_removed = true ; if ( dc -> unplug ( dev ) < 0 ) { error_set ( errp , QERR_UNDEFINED_ERROR ) ; return ; } }##::##0##::##10435
static int floppy_open ( BlockDriverState * bs , const char * filename , int flags ) { BDRVRawState * s = bs -> opaque ; int ret ; posix_aio_init ( ) ; s -> type = FTYPE_FD ; ret = raw_open_common ( bs , filename , flags , O_NONBLOCK ) ; if ( ret ) { return ret ; } close ( s -> fd ) ; s -> fd = - 1 ; s -> fd_media_changed = 1 ; return 0 ; }##::##0##::##14645
void spapr_dt_events ( void * fdt , uint32_t check_exception_irq ) { int event_sources , epow_events ; uint32_t irq_ranges [ ] = { cpu_to_be32 ( check_exception_irq ) , cpu_to_be32 ( 1 ) } ; uint32_t interrupts [ ] = { cpu_to_be32 ( check_exception_irq ) , 0 } ; _FDT ( event_sources = fdt_add_subnode ( fdt , 0 , "event-sources" ) ) ; _FDT ( fdt_setprop ( fdt , event_sources , "interrupt-controller" , NULL , 0 ) ) ; _FDT ( fdt_setprop_cell ( fdt , event_sources , "#interrupt-cells" , 2 ) ) ; _FDT ( fdt_setprop ( fdt , event_sources , "interrupt-ranges" , irq_ranges , sizeof ( irq_ranges ) ) ) ; _FDT ( epow_events = fdt_add_subnode ( fdt , event_sources , "epow-events" ) ) ; _FDT ( fdt_setprop ( fdt , epow_events , "interrupts" , interrupts , sizeof ( interrupts ) ) ) ; }##::##0##::##8564
static void s390_init_cpus ( MachineState * machine ) { MachineClass * mc = MACHINE_GET_CLASS ( machine ) ; int i ; if ( tcg_enabled ( ) && max_cpus > 1 ) { error_report ( "Number of SMP CPUs requested (%d) exceeds max CPUs " "supported by TCG (1) on s390x" , max_cpus ) ; exit ( 1 ) ; } mc -> possible_cpu_arch_ids ( machine ) ; for ( i = 0 ; i < smp_cpus ; i ++ ) { s390x_new_cpu ( machine -> cpu_type , i , & error_fatal ) ; } }##::##0##::##5370
static int rwpipe_read_ppm_header ( rwpipe * rw , int * width , int * height ) { char line [ 3 ] ; FILE * in = rwpipe_reader ( rw ) ; int max ; fgets ( line , 3 , in ) ; if ( ! strncmp ( line , "P6" , 2 ) ) { * width = rwpipe_read_number ( rw ) ; * height = rwpipe_read_number ( rw ) ; max = rwpipe_read_number ( rw ) ; return max != 255 || * width <= 0 || * height <= 0 ; } return 1 ; }##::##0##::##8866
setup_sigcontext ( struct target_sigcontext * sc , CPUM68KState * env , abi_ulong mask ) { int err = 0 ; __put_user ( mask , & sc -> sc_mask ) ; __put_user ( env -> aregs [ 7 ] , & sc -> sc_usp ) ; __put_user ( env -> dregs [ 0 ] , & sc -> sc_d0 ) ; __put_user ( env -> dregs [ 1 ] , & sc -> sc_d1 ) ; __put_user ( env -> aregs [ 0 ] , & sc -> sc_a0 ) ; __put_user ( env -> aregs [ 1 ] , & sc -> sc_a1 ) ; __put_user ( env -> sr , & sc -> sc_sr ) ; __put_user ( env -> pc , & sc -> sc_pc ) ; return err ; }##::##0##::##1600
static void dmg_close ( BlockDriverState * bs ) { BDRVDMGState * s = bs -> opaque ; close ( s -> fd ) ; if ( s -> n_chunks > 0 ) { free ( s -> types ) ; free ( s -> offsets ) ; free ( s -> lengths ) ; free ( s -> sectors ) ; free ( s -> sectorcounts ) ; } free ( s -> compressed_chunk ) ; free ( s -> uncompressed_chunk ) ; inflateEnd ( & s -> zstream ) ; }##::##0##::##7430
static int find_optimal_param ( uint32_t sum , int n ) { int k , k_opt ; uint32_t nbits [ MAX_RICE_PARAM + 1 ] ; k_opt = 0 ; nbits [ 0 ] = UINT32_MAX ; for ( k = 0 ; k <= MAX_RICE_PARAM ; k ++ ) { nbits [ k ] = rice_encode_count ( sum , n , k ) ; if ( nbits [ k ] < nbits [ k_opt ] ) { k_opt = k ; } } return k_opt ; }##::##0##::##10858
static void ivshmem_check_memdev_is_busy ( Object * obj , const char * name , Object * val , Error * * errp ) { MemoryRegion * mr ; mr = host_memory_backend_get_memory ( MEMORY_BACKEND ( val ) , & error_abort ) ; if ( memory_region_is_mapped ( mr ) ) { char * path = object_get_canonical_path_component ( val ) ; error_setg ( errp , "can't use already busy memdev: %s" , path ) ; g_free ( path ) ; } else { qdev_prop_allow_set_link_before_realize ( obj , name , val , errp ) ; } }##::##0##::##6671
static void json_emit_element ( QJSON * json , const char * name ) { if ( json -> omit_comma ) { json -> omit_comma = false ; } else { qstring_append ( json -> str , ", " ) ; } if ( name ) { qstring_append ( json -> str , "\"" ) ; qstring_append ( json -> str , name ) ; qstring_append ( json -> str , "\" : " ) ; } }##::##0##::##6235
static int cpu_x86_fill_model_id ( char * str ) { uint32_t eax , ebx , ecx , edx ; int i ; for ( i = 0 ; i < 3 ; i ++ ) { host_cpuid ( 0x80000002 + i , 0 , & eax , & ebx , & ecx , & edx ) ; memcpy ( str + i * 16 + 0 , & eax , 4 ) ; memcpy ( str + i * 16 + 4 , & ebx , 4 ) ; memcpy ( str + i * 16 + 8 , & ecx , 4 ) ; memcpy ( str + i * 16 + 12 , & edx , 4 ) ; } return 0 ; }##::##0##::##5504
static void hash32_bat_size ( CPUPPCState * env , target_ulong * blp , int * validp , target_ulong batu , target_ulong batl ) { target_ulong bl ; int valid ; bl = ( batu & BATU32_BL ) << 15 ; valid = 0 ; if ( ( ( msr_pr == 0 ) && ( batu & BATU32_VS ) ) || ( ( msr_pr != 0 ) && ( batu & BATU32_VP ) ) ) { valid = 1 ; } * blp = bl ; * validp = valid ; }##::##0##::##7539
static void colo_compare_finalize ( Object * obj ) { CompareState * s = COLO_COMPARE ( obj ) ; qemu_chr_fe_deinit ( & s -> chr_pri_in , false ) ; qemu_chr_fe_deinit ( & s -> chr_sec_in , false ) ; qemu_chr_fe_deinit ( & s -> chr_out , false ) ; g_main_loop_quit ( s -> compare_loop ) ; qemu_thread_join ( & s -> thread ) ; g_queue_foreach ( & s -> conn_list , colo_flush_packets , s ) ; g_queue_clear ( & s -> conn_list ) ; g_hash_table_destroy ( s -> connection_track_table ) ; g_free ( s -> pri_indev ) ; g_free ( s -> sec_indev ) ; g_free ( s -> outdev ) ; }##::##0##::##7453
static char * time_value_string ( char * buf , int buf_size , int64_t val , const AVRational * time_base ) { if ( val == AV_NOPTS_VALUE ) { snprintf ( buf , buf_size , "N/A" ) ; } else { double d = val * av_q2d ( * time_base ) ; value_string ( buf , buf_size , ( struct unit_value ) { . val . d = d , . unit = unit_second_str } ) ; } return buf ; }##::##0##::##6508
void machine_register_compat_props ( MachineState * machine ) { MachineClass * mc = MACHINE_GET_CLASS ( machine ) ; int i ; GlobalProperty * p ; if ( ! mc -> compat_props ) { return ; } for ( i = 0 ; i < mc -> compat_props -> len ; i ++ ) { p = g_array_index ( mc -> compat_props , GlobalProperty * , i ) ; p -> errp = & error_abort ; qdev_prop_register_global ( p ) ; } }##::##0##::##893
static void h264_free_extradata ( PayloadContext * data ) { # ifdef DEBUG int ii ; for ( ii = 0 ; ii < 32 ; ii ++ ) { if ( data -> packet_types_received [ ii ] ) av_log ( NULL , AV_LOG_DEBUG , "Received %d packets of type %d\n" , data -> packet_types_received [ ii ] , ii ) ; } # endif assert ( data ) ; assert ( data -> cookie == MAGIC_COOKIE ) ; data -> cookie = DEAD_COOKIE ; av_free ( data ) ; }##::##0##::##11373
static void jpeg_prepare_row ( VncState * vs , uint8_t * dst , int x , int y , int count ) { if ( vs -> tight_pixel24 ) { jpeg_prepare_row24 ( vs , dst , x , y , count ) ; } else if ( ds_get_bytes_per_pixel ( vs -> ds ) == 4 ) { jpeg_prepare_row32 ( vs , dst , x , y , count ) ; } else { jpeg_prepare_row16 ( vs , dst , x , y , count ) ; } }##::##0##::##5391
void ff_af_queue_log_state ( AudioFrameQueue * afq ) { AudioFrame * f ; av_log ( afq -> avctx , AV_LOG_DEBUG , "remaining delay   = %d\n" , afq -> remaining_delay ) ; av_log ( afq -> avctx , AV_LOG_DEBUG , "remaining samples = %d\n" , afq -> remaining_samples ) ; av_log ( afq -> avctx , AV_LOG_DEBUG , "frames:\n" ) ; f = afq -> frame_queue ; while ( f ) { av_log ( afq -> avctx , AV_LOG_DEBUG , "  [ pts=%9" PRId64 " duration=%d ]\n" , f -> pts , f -> duration ) ; f = f -> next ; } }##::##0##::##13053
static uint32_t slavio_led_mem_reads ( void * opaque , target_phys_addr_t addr ) { MiscState * s = opaque ; uint32_t ret = 0 , saddr ; saddr = addr & LED_MAXADDR ; switch ( saddr ) { case 0 : ret = s -> leds ; break ; default : break ; } MISC_DPRINTF ( "Read diagnostic LED reg 0x" TARGET_FMT_plx " = %x\n" , addr , ret ) ; return ret ; }##::##0##::##2773
uint64_t helper_cmpbge ( uint64_t op1 , uint64_t op2 ) { uint8_t opa , opb , res ; int i ; res = 0 ; for ( i = 0 ; i < 8 ; i ++ ) { opa = op1 >> ( i * 8 ) ; opb = op2 >> ( i * 8 ) ; if ( opa >= opb ) { res |= 1 << i ; } } return res ; }##::##0##::##11870
static void dma_complete ( DMAAIOCB * dbs , int ret ) { trace_dma_complete ( dbs , ret , dbs -> common . cb ) ; dma_bdrv_unmap ( dbs ) ; if ( dbs -> common . cb ) { dbs -> common . cb ( dbs -> common . opaque , ret ) ; } qemu_iovec_destroy ( & dbs -> iov ) ; if ( dbs -> bh ) { qemu_bh_delete ( dbs -> bh ) ; dbs -> bh = NULL ; } qemu_aio_unref ( dbs ) ; }##::##0##::##4121
static void tcg_out_bpcc ( TCGContext * s , int scond , int flags , int label ) { TCGLabel * l = & s -> labels [ label ] ; int off19 ; if ( l -> has_value ) { off19 = INSN_OFF19 ( tcg_pcrel_diff ( s , l -> u . value_ptr ) ) ; } else { off19 = * s -> code_ptr & INSN_OFF19 ( - 1 ) ; tcg_out_reloc ( s , s -> code_ptr , R_SPARC_WDISP19 , label , 0 ) ; } tcg_out_bpcc0 ( s , scond , flags , off19 ) ; }##::##0##::##8603
softusb_write ( void * opaque , target_phys_addr_t addr , uint64_t value , unsigned size ) { MilkymistSoftUsbState * s = opaque ; trace_milkymist_softusb_memory_write ( addr , value ) ; addr >>= 2 ; switch ( addr ) { case R_CTRL : s -> regs [ addr ] = value ; break ; default : error_report ( "milkymist_softusb: write access to unknown register 0x" TARGET_FMT_plx , addr << 2 ) ; break ; } }##::##0##::##11430
static int test_vector_fmul_window ( AVFloatDSPContext * fdsp , AVFloatDSPContext * cdsp , const float * v1 , const float * v2 , const float * v3 ) { LOCAL_ALIGNED ( 32 , float , cdst , [ LEN ] ) ; LOCAL_ALIGNED ( 32 , float , odst , [ LEN ] ) ; int ret ; cdsp -> vector_fmul_window ( cdst , v1 , v2 , v3 , LEN / 2 ) ; fdsp -> vector_fmul_window ( odst , v1 , v2 , v3 , LEN / 2 ) ; if ( ret = compare_floats ( cdst , odst , LEN , ARBITRARY_FMUL_WINDOW_CONST ) ) { av_log ( NULL , AV_LOG_ERROR , "vector_fmul_window failed\n" ) ; } return ret ; }##::##0##::##2834
static void do_commit ( Monitor * mon , const QDict * qdict ) { int all_devices ; DriveInfo * dinfo ; const char * device = qdict_get_str ( qdict , "device" ) ; all_devices = ! strcmp ( device , "all" ) ; TAILQ_FOREACH ( dinfo , & drives , next ) { if ( ! all_devices ) if ( strcmp ( bdrv_get_device_name ( dinfo -> bdrv ) , device ) ) { continue ; } bdrv_commit ( dinfo -> bdrv ) ; } }##::##0##::##5824
static int put_v ( ByteIOContext * bc , uint64_t val ) { int i ; if ( bytes_left ( bc ) < 1 ) { return - 1 ; } val &= 0x7FFFFFFFFFFFFFFFULL ; i = get_length ( val ) ; for ( i -= 7 ; i > 0 ; i -= 7 ) { put_byte ( bc , 0x80 | ( val >> i ) ) ; } put_byte ( bc , val & 0x7f ) ; return 0 ; }##::##0##::##861
static bool tcg_out_opc_jmp ( TCGContext * s , MIPSInsn opc , void * target ) { uintptr_t dest = ( uintptr_t ) target ; uintptr_t from = ( uintptr_t ) s -> code_ptr + 4 ; int32_t inst ; if ( ( from ^ dest ) & - ( 1 << 28 ) ) { return false ; } assert ( ( dest & 3 ) == 0 ) ; inst = opc ; inst |= ( dest >> 2 ) & 0x3ffffff ; tcg_out32 ( s , inst ) ; return true ; }##::##0##::##4537
static void test_after_failed_device_add ( void ) { QDict * response ; QDict * error ; qtest_start ( "-drive if=none,id=drive0" ) ; response = qmp ( "{'execute': 'device_add'," " 'arguments': {" "   'driver': 'virtio-blk-pci'," "   'drive': 'drive0'" "}}" ) ; g_assert ( response ) ; error = qdict_get_qdict ( response , "error" ) ; g_assert_cmpstr ( qdict_get_try_str ( error , "class" ) , == , "GenericError" ) ; QDECREF ( response ) ; drive_del ( ) ; drive_add ( ) ; qtest_end ( ) ; }##::##0##::##12130
void ff_vp3_idct_altivec ( DCTELEM block [ 64 ] ) { IDCT_START IDCT_1D ( NOP , NOP ) TRANSPOSE8 ( b0 , b1 , b2 , b3 , b4 , b5 , b6 , b7 ) ; IDCT_1D ( ADD8 , SHIFT4 ) vec_st ( b0 , 0x00 , block ) ; vec_st ( b1 , 0x10 , block ) ; vec_st ( b2 , 0x20 , block ) ; vec_st ( b3 , 0x30 , block ) ; vec_st ( b4 , 0x40 , block ) ; vec_st ( b5 , 0x50 , block ) ; vec_st ( b6 , 0x60 , block ) ; vec_st ( b7 , 0x70 , block ) ; }##::##0##::##447
static void init_event_facility ( Object * obj ) { SCLPEventFacility * event_facility = EVENT_FACILITY ( obj ) ; DeviceState * sdev = DEVICE ( obj ) ; qbus_create_inplace ( & event_facility -> sbus , sizeof ( event_facility -> sbus ) , TYPE_SCLP_EVENTS_BUS , sdev , NULL ) ; object_initialize ( & event_facility -> quiesce_event , sizeof ( SCLPEvent ) , TYPE_SCLP_QUIESCE ) ; qdev_set_parent_bus ( DEVICE ( & event_facility -> quiesce_event ) , & event_facility -> sbus . qbus ) ; object_initialize ( & event_facility -> cpu_hotplug_event , sizeof ( SCLPEvent ) , TYPE_SCLP_CPU_HOTPLUG ) ; qdev_set_parent_bus ( DEVICE ( & event_facility -> cpu_hotplug_event ) , & event_facility -> sbus . qbus ) ; }##::##0##::##9287
static int spapr_check_htab_fd ( sPAPRMachineState * spapr ) { int rc = 0 ; if ( spapr -> htab_fd_stale ) { close ( spapr -> htab_fd ) ; spapr -> htab_fd = kvmppc_get_htab_fd ( false ) ; if ( spapr -> htab_fd < 0 ) { error_report ( "Unable to open fd for reading hash table from KVM: " "%s" , strerror ( errno ) ) ; rc = - 1 ; } spapr -> htab_fd_stale = false ; } return rc ; }##::##0##::##7831
static void pc_dimm_check_memdev_is_busy ( const Object * obj , const char * name , Object * val , Error * * errp ) { Error * local_err = NULL ; if ( host_memory_backend_is_mapped ( MEMORY_BACKEND ( val ) ) ) { char * path = object_get_canonical_path_component ( val ) ; error_setg ( & local_err , "can't use already busy memdev: %s" , path ) ; g_free ( path ) ; } else { qdev_prop_allow_set_link_before_realize ( obj , name , val , & local_err ) ; } error_propagate ( errp , local_err ) ; }##::##0##::##7026
void bios_linker_loader_alloc ( GArray * linker , const char * file , uint32_t alloc_align , bool alloc_fseg ) { BiosLinkerLoaderEntry entry ; memset ( & entry , 0 , sizeof entry ) ; strncpy ( entry . alloc . file , file , sizeof entry . alloc . file - 1 ) ; entry . command = cpu_to_le32 ( BIOS_LINKER_LOADER_COMMAND_ALLOCATE ) ; entry . alloc . align = cpu_to_le32 ( alloc_align ) ; entry . alloc . zone = cpu_to_le32 ( alloc_fseg ? BIOS_LINKER_LOADER_ALLOC_ZONE_FSEG : BIOS_LINKER_LOADER_ALLOC_ZONE_HIGH ) ; g_array_prepend_val ( linker , entry ) ; }##::##0##::##4378
static int send_solid_rect ( VncState * vs ) { size_t bytes ; vnc_write_u8 ( vs , VNC_TIGHT_FILL << 4 ) ; if ( vs -> tight_pixel24 ) { tight_pack24 ( vs , vs -> tight . buffer , 1 , & vs -> tight . offset ) ; bytes = 3 ; } else { bytes = vs -> clientds . pf . bytes_per_pixel ; } vnc_write ( vs , vs -> tight . buffer , bytes ) ; return 1 ; }##::##0##::##10473
static inline void gen_op_evsrwu ( TCGv_i32 ret , TCGv_i32 arg1 , TCGv_i32 arg2 ) { TCGv_i32 t0 ; int l1 , l2 ; l1 = gen_new_label ( ) ; l2 = gen_new_label ( ) ; t0 = tcg_temp_local_new_i32 ( ) ; tcg_gen_andi_i32 ( t0 , arg2 , 0x3F ) ; tcg_gen_brcondi_i32 ( TCG_COND_GE , t0 , 32 , l1 ) ; tcg_gen_shr_i32 ( ret , arg1 , t0 ) ; tcg_gen_br ( l2 ) ; gen_set_label ( l1 ) ; tcg_gen_movi_i32 ( ret , 0 ) ; gen_set_label ( l2 ) ; tcg_temp_free_i32 ( t0 ) ; }##::##0##::##13449
static inline void gen_op_evsrws ( TCGv_i32 ret , TCGv_i32 arg1 , TCGv_i32 arg2 ) { TCGv_i32 t0 ; int l1 , l2 ; l1 = gen_new_label ( ) ; l2 = gen_new_label ( ) ; t0 = tcg_temp_local_new_i32 ( ) ; tcg_gen_andi_i32 ( t0 , arg2 , 0x3F ) ; tcg_gen_brcondi_i32 ( TCG_COND_GE , t0 , 32 , l1 ) ; tcg_gen_sar_i32 ( ret , arg1 , t0 ) ; tcg_gen_br ( l2 ) ; gen_set_label ( l1 ) ; tcg_gen_movi_i32 ( ret , 0 ) ; gen_set_label ( l2 ) ; tcg_temp_free_i32 ( t0 ) ; }##::##0##::##6294
void qemu_spice_create_primary_surface ( SimpleSpiceDisplay * ssd , uint32_t id , QXLDevSurfaceCreate * surface , qxl_async_io async ) { if ( async != QXL_SYNC ) { # if SPICE_INTERFACE_QXL_MINOR >= 1 spice_qxl_create_primary_surface_async ( & ssd -> qxl , id , surface , 0 ) ; # else abort ( ) ; # endif } else { ssd -> worker -> create_primary_surface ( ssd -> worker , id , surface ) ; } }##::##0##::##796
uint64_t helper_cmpbge ( uint64_t op1 , uint64_t op2 ) { uint8_t opa , opb , res ; int i ; res = 0 ; for ( i = 0 ; i < 7 ; i ++ ) { opa = op1 >> ( i * 8 ) ; opb = op2 >> ( i * 8 ) ; if ( opa >= opb ) { res |= 1 << i ; } } return res ; }##::##0##::##9302
static int local_chmod ( FsContext * fs_ctx , V9fsPath * fs_path , FsCred * credp ) { char buffer [ PATH_MAX ] ; char * path = fs_path -> data ; if ( fs_ctx -> fs_sm == SM_MAPPED ) { return local_set_xattr ( rpath ( fs_ctx , path , buffer ) , credp ) ; } else if ( ( fs_ctx -> fs_sm == SM_PASSTHROUGH ) || ( fs_ctx -> fs_sm == SM_NONE ) ) { return chmod ( rpath ( fs_ctx , path , buffer ) , credp -> fc_mode ) ; } return - 1 ; }##::##0##::##14052
static int do_write_compressed ( BlockBackend * blk , char * buf , int64_t offset , int64_t count , int64_t * total ) { int ret ; if ( count >> 9 > INT_MAX ) { return - ERANGE ; } ret = blk_write_compressed ( blk , offset >> 9 , ( uint8_t * ) buf , count >> 9 ) ; if ( ret < 0 ) { return ret ; } * total = count ; return 1 ; }##::##0##::##12930
static void get_seg ( SegmentCache * lhs , const struct kvm_segment * rhs ) { lhs -> selector = rhs -> selector ; lhs -> base = rhs -> base ; lhs -> limit = rhs -> limit ; lhs -> flags = ( rhs -> type << DESC_TYPE_SHIFT ) | ( rhs -> present * DESC_P_MASK ) | ( rhs -> dpl << DESC_DPL_SHIFT ) | ( rhs -> db << DESC_B_SHIFT ) | ( rhs -> s * DESC_S_MASK ) | ( rhs -> l << DESC_L_SHIFT ) | ( rhs -> g * DESC_G_MASK ) | ( rhs -> avl * DESC_AVL_MASK ) ; }##::##0##::##13840
static struct omap_rtc_s * omap_rtc_init ( MemoryRegion * system_memory , target_phys_addr_t base , qemu_irq * irq , omap_clk clk ) { struct omap_rtc_s * s = ( struct omap_rtc_s * ) g_malloc0 ( sizeof ( struct omap_rtc_s ) ) ; s -> irq = irq [ 0 ] ; s -> alarm = irq [ 1 ] ; s -> clk = qemu_new_timer_ms ( rt_clock , omap_rtc_tick , s ) ; omap_rtc_reset ( s ) ; memory_region_init_io ( & s -> iomem , & omap_rtc_ops , s , "omap-rtc" , 0x800 ) ; memory_region_add_subregion ( system_memory , base , & s -> iomem ) ; return s ; }##::##0##::##4216
iscsi_unmap_cb ( struct iscsi_context * iscsi , int status , void * command_data , void * opaque ) { IscsiAIOCB * acb = opaque ; if ( acb -> canceled != 0 ) { return ; } acb -> status = 0 ; if ( status < 0 ) { error_report ( "Failed to unmap data on iSCSI lun. %s" , iscsi_get_error ( iscsi ) ) ; acb -> status = - EIO ; } iscsi_schedule_bh ( acb ) ; }##::##0##::##4271
static void allocate_buffers ( FLACContext * s ) { int i ; assert ( s -> max_blocksize ) ; if ( s -> max_framesize == 0 && s -> max_blocksize ) { s -> max_framesize = ( s -> channels * s -> bps * s -> max_blocksize + 7 ) / 8 ; } for ( i = 0 ; i < s -> channels ; i ++ ) { s -> decoded [ i ] = av_realloc ( s -> decoded [ i ] , sizeof ( int32_t ) * s -> max_blocksize ) ; } s -> bitstream = av_fast_realloc ( s -> bitstream , & s -> allocated_bitstream_size , s -> max_framesize ) ; }##::##0##::##8525
static int filter_samples ( AVFilterLink * inlink , AVFilterBufferRef * samplesref ) { AVFilterContext * ctx = inlink -> dst ; int i , ret = 0 ; for ( i = 0 ; i < ctx -> nb_outputs ; i ++ ) { ret = ff_filter_samples ( inlink -> dst -> outputs [ i ] , avfilter_ref_buffer ( samplesref , ~ AV_PERM_WRITE ) ) ; if ( ret < 0 ) { break ; } } avfilter_unref_buffer ( samplesref ) ; return ret ; }##::##0##::##560
void virtio_queue_set_host_notifier_fd_handler ( VirtQueue * vq , bool assign , bool set_handler ) { if ( assign && set_handler ) { event_notifier_set_handler ( & vq -> host_notifier , true , virtio_queue_host_notifier_read ) ; } else { event_notifier_set_handler ( & vq -> host_notifier , true , NULL ) ; } if ( ! assign ) { virtio_queue_host_notifier_read ( & vq -> host_notifier ) ; } }##::##0##::##586
int bdrv_snapshot_delete ( BlockDriverState * bs , const char * snapshot_id ) { BlockDriver * drv = bs -> drv ; if ( ! drv ) { return - ENOMEDIUM ; } if ( drv -> bdrv_snapshot_delete ) { return drv -> bdrv_snapshot_delete ( bs , snapshot_id ) ; } if ( bs -> file ) { return bdrv_snapshot_delete ( bs -> file , snapshot_id ) ; } return - ENOTSUP ; }##::##0##::##7268
static uint32_t s390_pci_generate_fid ( Error * * errp ) { uint32_t fid = 0 ; while ( fid <= ZPCI_MAX_FID ) { if ( ! s390_pci_find_dev_by_fid ( fid ) ) { return fid ; } if ( fid == ZPCI_MAX_FID ) { break ; } fid ++ ; } error_setg ( errp , "no free fid could be found" ) ; return 0 ; }##::##0##::##13063
static void pci_change_irq_level ( PCIDevice * pci_dev , int irq_num , int change ) { PCIBus * bus ; for ( ; ; ) { bus = pci_dev -> bus ; irq_num = bus -> map_irq ( pci_dev , irq_num ) ; if ( bus -> set_irq ) { break ; } pci_dev = bus -> parent_dev ; } bus -> irq_count [ irq_num ] += change ; bus -> set_irq ( bus -> irq_opaque , irq_num , bus -> irq_count [ irq_num ] != 0 ) ; }##::##0##::##4373
void omap_mpuio_key ( struct omap_mpuio_s * s , int row , int col , int down ) { if ( row >= 5 || row < 0 ) { hw_error ( "%s: No key %i-%i\n" , __FUNCTION__ , col , row ) ; } if ( down ) { s -> buttons [ row ] |= 1 << col ; } else { s -> buttons [ row ] &= ~ ( 1 << col ) ; } omap_mpuio_kbd_update ( s ) ; }##::##0##::##3802
int nbd_client_co_pdiscard ( BlockDriverState * bs , int64_t offset , int bytes ) { NBDClientSession * client = nbd_get_client_session ( bs ) ; NBDRequest request = { . type = NBD_CMD_TRIM , . from = offset , . len = bytes , } ; assert ( ! ( client -> info . flags & NBD_FLAG_READ_ONLY ) ) ; if ( ! ( client -> info . flags & NBD_FLAG_SEND_TRIM ) ) { return 0 ; } return nbd_co_request ( bs , & request , NULL ) ; }##::##0##::##7498
int kvm_irqchip_update_msi_route ( KVMState * s , int virq , MSIMessage msg ) { struct kvm_irq_routing_entry kroute ; if ( ! kvm_irqchip_in_kernel ( ) ) { return - ENOSYS ; } kroute . gsi = virq ; kroute . type = KVM_IRQ_ROUTING_MSI ; kroute . flags = 0 ; kroute . u . msi . address_lo = ( uint32_t ) msg . address ; kroute . u . msi . address_hi = msg . address >> 32 ; kroute . u . msi . data = msg . data ; return kvm_update_routing_entry ( s , & kroute ) ; }##::##0##::##14279
static int graph_config_formats ( AVFilterGraph * graph , AVClass * log_ctx ) { int ret ; if ( ( ret = query_formats ( graph , log_ctx ) ) < 0 ) { return ret ; } reduce_formats ( graph ) ; swap_sample_fmts ( graph ) ; swap_samplerates ( graph ) ; swap_channel_layouts ( graph ) ; if ( ( ret = pick_formats ( graph ) ) < 0 ) { return ret ; } return 0 ; }##::##0##::##3742
static av_cold void init_mv_table ( MVTable * tab ) { int i , x , y ; tab -> table_mv_index = av_malloc ( sizeof ( uint16_t ) * 4096 ) ; for ( i = 0 ; i < 4096 ; i ++ ) { tab -> table_mv_index [ i ] = tab -> n ; } for ( i = 0 ; i < tab -> n ; i ++ ) { x = tab -> table_mvx [ i ] ; y = tab -> table_mvy [ i ] ; tab -> table_mv_index [ ( x << 6 ) | y ] = i ; } }##::##0##::##721
clk_setup_cb cpu_ppc_tb_init ( CPUState * env , uint32_t freq ) { ppc_tb_t * tb_env ; tb_env = qemu_mallocz ( sizeof ( ppc_tb_t ) ) ; if ( tb_env == NULL ) { return NULL ; } env -> tb_env = tb_env ; tb_env -> decr_timer = qemu_new_timer ( vm_clock , & cpu_ppc_decr_cb , env ) ; # if defined ( TARGET_PPC64H ) tb_env -> hdecr_timer = qemu_new_timer ( vm_clock , & cpu_ppc_hdecr_cb , env ) ; # endif cpu_ppc_set_tb_clk ( env , freq ) ; return & cpu_ppc_set_tb_clk ; }##::##0##::##13942
static int check_strtox_error ( const char * p , char * endptr , const char * * next , int err ) { if ( err == 0 && endptr == p ) { err = EINVAL ; } if ( ! next && * endptr ) { return - EINVAL ; } if ( next ) { * next = endptr ; } return - err ; }##::##0##::##14798
static int check_strtox_error ( const char * nptr , char * ep , const char * * endptr , int libc_errno ) { if ( libc_errno == 0 && ep == nptr ) { libc_errno = EINVAL ; } if ( ! endptr && * ep ) { return - EINVAL ; } if ( endptr ) { * endptr = ep ; } return - libc_errno ; }##::##0##::##8212
static void term_down_char ( void ) { if ( term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == - 1 ) { return ; } if ( term_history [ ++ term_hist_entry ] != NULL ) { pstrcpy ( term_cmd_buf , sizeof ( term_cmd_buf ) , term_history [ term_hist_entry ] ) ; } else { term_hist_entry = - 1 ; } term_cmd_buf_index = term_cmd_buf_size = strlen ( term_cmd_buf ) ; }##::##0##::##13068
uint32_t net_checksum_add ( int len , uint8_t * buf ) { uint32_t sum = 0 ; int i ; for ( i = 0 ; i < len ; i ++ ) { if ( i & 1 ) { sum += ( uint32_t ) buf [ i ] ; } else { sum += ( uint32_t ) buf [ i ] << 8 ; } } return sum ; }##::##0##::##2434
int kvmppc_remove_spapr_tce ( void * table , int fd , uint32_t window_size ) { long len ; if ( fd < 0 ) { return - 1 ; } len = ( window_size / SPAPR_TCE_PAGE_SIZE ) * sizeof ( sPAPRTCE ) ; if ( ( munmap ( table , len ) < 0 ) || ( close ( fd ) < 0 ) ) { fprintf ( stderr , "KVM: Unexpected error removing TCE table: %s" , strerror ( errno ) ) ; } return 0 ; }##::##0##::##11923
static uint64_t subpage_ram_read ( void * opaque , target_phys_addr_t addr , unsigned size ) { ram_addr_t raddr = addr ; void * ptr = qemu_get_ram_ptr ( raddr ) ; switch ( size ) { case 1 : return ldub_p ( ptr ) ; case 2 : return lduw_p ( ptr ) ; case 4 : return ldl_p ( ptr ) ; default : abort ( ) ; } }##::##0##::##3574
static int xen_platform_initfn ( PCIDevice * dev ) { PCIXenPlatformState * d = DO_UPCAST ( PCIXenPlatformState , pci_dev , dev ) ; uint8_t * pci_conf ; pci_conf = d -> pci_dev . config ; pci_set_word ( pci_conf + PCI_COMMAND , PCI_COMMAND_IO | PCI_COMMAND_MEMORY ) ; pci_config_set_prog_interface ( pci_conf , 0 ) ; pci_conf [ PCI_INTERRUPT_PIN ] = 1 ; pci_register_bar ( & d -> pci_dev , 0 , 0x100 , PCI_BASE_ADDRESS_SPACE_IO , platform_ioport_map ) ; pci_register_bar ( & d -> pci_dev , 1 , 0x1000000 , PCI_BASE_ADDRESS_MEM_PREFETCH , platform_mmio_map ) ; platform_fixed_ioport_init ( d ) ; return 0 ; }##::##0##::##8427
float64 int32_to_float64 ( int32 a STATUS_PARAM ) { flag zSign ; uint32 absA ; int8 shiftCount ; bits64 zSig ; if ( a == 0 ) { return 0 ; } zSign = ( a < 0 ) ; absA = zSign ? - a : a ; shiftCount = countLeadingZeros32 ( absA ) + 21 ; zSig = absA ; return packFloat64 ( zSign , 0x432 - shiftCount , zSig << shiftCount ) ; }##::##0##::##12285
static TCGv_i32 gen_get_asi ( DisasContext * dc , int insn ) { int asi ; if ( IS_IMM ) { # ifdef TARGET_SPARC64 asi = dc -> asi ; # else gen_exception ( dc , TT_ILL_INSN ) ; asi = 0 ; # endif } else { asi = GET_FIELD ( insn , 19 , 26 ) ; } return tcg_const_i32 ( asi ) ; }##::##0##::##9899
void qemu_spice_display_init ( DisplayState * ds ) { assert ( sdpy . ds == NULL ) ; sdpy . ds = ds ; sdpy . bufsize = ( 16 * 1024 * 1024 ) ; sdpy . buf = qemu_malloc ( sdpy . bufsize ) ; pthread_mutex_init ( & sdpy . lock , NULL ) ; register_displaychangelistener ( ds , & display_listener ) ; sdpy . qxl . base . sif = & dpy_interface . base ; qemu_spice_add_interface ( & sdpy . qxl . base ) ; assert ( sdpy . worker ) ; qemu_add_vm_change_state_handler ( qemu_spice_vm_change_state_handler , & sdpy ) ; qemu_spice_create_host_memslot ( & sdpy ) ; qemu_spice_create_host_primary ( & sdpy ) ; }##::##0##::##14191
static void nvdimm_dsm_label_size ( NVDIMMDevice * nvdimm , hwaddr dsm_mem_addr ) { NvdimmFuncGetLabelSizeOut label_size_out = { . len = cpu_to_le32 ( sizeof ( label_size_out ) ) , } ; uint32_t label_size , mxfer ; label_size = nvdimm -> label_size ; mxfer = nvdimm_get_max_xfer_label_size ( ) ; nvdimm_debug ( "label_size %#x, max_xfer %#x.\n" , label_size , mxfer ) ; label_size_out . func_ret_status = cpu_to_le32 ( 0 ) ; label_size_out . label_size = cpu_to_le32 ( label_size ) ; label_size_out . max_xfer = cpu_to_le32 ( mxfer ) ; cpu_physical_memory_write ( dsm_mem_addr , & label_size_out , sizeof ( label_size_out ) ) ; }##::##0##::##9329
static int smacker_probe ( AVProbeData * p ) { if ( p -> buf_size < 4 ) { return 0 ; } if ( p -> buf [ 0 ] == 'S' && p -> buf [ 1 ] == 'M' && p -> buf [ 2 ] == 'K' && ( p -> buf [ 3 ] == '2' || p -> buf [ 3 ] == '4' ) ) { return AVPROBE_SCORE_MAX ; } else { return 0 ; } }##::##0##::##13298
static void curl_multi_timeout_do ( void * arg ) { # ifdef NEED_CURL_TIMER_CALLBACK BDRVCURLState * s = ( BDRVCURLState * ) arg ; int running ; if ( ! s -> multi ) { return ; } aio_context_acquire ( s -> aio_context ) ; curl_multi_socket_action ( s -> multi , CURL_SOCKET_TIMEOUT , 0 , & running ) ; curl_multi_check_completion ( s ) ; aio_context_release ( s -> aio_context ) ; # else abort ( ) ; # endif }##::##0##::##8598
static void s390_pcihost_init_as ( S390pciState * s ) { int i ; S390PCIBusDevice * pbdev ; for ( i = 0 ; i < PCI_SLOT_MAX ; i ++ ) { pbdev = & s -> pbdev [ i ] ; memory_region_init ( & pbdev -> mr , OBJECT ( s ) , "iommu-root-s390" , UINT64_MAX ) ; address_space_init ( & pbdev -> as , & pbdev -> mr , "iommu-pci" ) ; } memory_region_init_io ( & s -> msix_notify_mr , OBJECT ( s ) , & s390_msi_ctrl_ops , s , "msix-s390" , UINT64_MAX ) ; address_space_init ( & s -> msix_notify_as , & s -> msix_notify_mr , "msix-pci" ) ; }##::##0##::##2914
static uint64_t get_v ( ByteIOContext * bc ) { uint64_t val = 0 ; for ( ; bytes_left ( bc ) > 0 ; ) { int tmp = get_byte ( bc ) ; if ( tmp & 0x80 ) { val = ( val << 7 ) + tmp - 0x80 ; } else { return ( val << 7 ) + tmp ; } } return - 1 ; }##::##0##::##5986
void qemu_aio_flush ( void ) { AioHandler * node ; int ret ; do { ret = 0 ; qemu_aio_wait ( ) ; QLIST_FOREACH ( node , & aio_handlers , node ) { if ( node -> io_flush ) { ret |= node -> io_flush ( node -> opaque ) ; } } } while ( qemu_bh_poll ( ) || ret > 0 ) ; }##::##0##::##10757
static void add_bytes_l2_c ( uint8_t * dst , uint8_t * src1 , uint8_t * src2 , int w ) { long i ; for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { long a = * ( long * ) ( src1 + i ) ; long b = * ( long * ) ( src2 + i ) ; * ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ) ; } for ( ; i < w ; i ++ ) { dst [ i ] = src1 [ i ] + src2 [ i ] ; } }##::##0##::##9426
static int piix4_initfn ( PCIDevice * d ) { uint8_t * pci_conf ; isa_bus_new ( & d -> qdev ) ; register_savevm ( "PIIX4" , 0 , 2 , piix_save , piix_load , d ) ; pci_conf = d -> config ; pci_config_set_vendor_id ( pci_conf , PCI_VENDOR_ID_INTEL ) ; pci_config_set_device_id ( pci_conf , PCI_DEVICE_ID_INTEL_82371AB_0 ) ; pci_config_set_class ( pci_conf , PCI_CLASS_BRIDGE_ISA ) ; pci_conf [ PCI_HEADER_TYPE ] = PCI_HEADER_TYPE_NORMAL | PCI_HEADER_TYPE_MULTI_FUNCTION ; piix4_dev = d ; piix4_reset ( d ) ; qemu_register_reset ( piix4_reset , d ) ; return 0 ; }##::##0##::##11629
static void e1000_pre_save ( void * opaque ) { E1000State * s = opaque ; NetClientState * nc = qemu_get_queue ( s -> nic ) ; if ( s -> mit_timer_on ) { e1000_mit_timer ( s ) ; } if ( nc -> link_down && s -> compat_flags & E1000_FLAG_AUTONEG && s -> phy_reg [ PHY_CTRL ] & MII_CR_AUTO_NEG_EN && s -> phy_reg [ PHY_CTRL ] & MII_CR_RESTART_AUTO_NEG ) { s -> phy_reg [ PHY_STATUS ] |= MII_SR_AUTONEG_COMPLETE ; } }##::##0##::##7213
void ff_cavs_init_top_lines ( AVSContext * h ) { h -> top_qp = av_malloc ( h -> mb_width ) ; h -> top_mv [ 0 ] = av_malloc ( ( h -> mb_width * 2 + 1 ) * sizeof ( cavs_vector ) ) ; h -> top_mv [ 1 ] = av_malloc ( ( h -> mb_width * 2 + 1 ) * sizeof ( cavs_vector ) ) ; h -> top_pred_Y = av_malloc ( h -> mb_width * 2 * sizeof ( * h -> top_pred_Y ) ) ; h -> top_border_y = av_malloc ( ( h -> mb_width + 1 ) * 16 ) ; h -> top_border_u = av_malloc ( h -> mb_width * 10 ) ; h -> top_border_v = av_malloc ( h -> mb_width * 10 ) ; h -> col_mv = av_malloc ( h -> mb_width * h -> mb_height * 4 * sizeof ( cavs_vector ) ) ; h -> col_type_base = av_malloc ( h -> mb_width * h -> mb_height ) ; h -> block = av_mallocz ( 64 * sizeof ( DCTELEM ) ) ; }##::##0##::##5682
static ssize_t nbd_send_reply ( int csock , struct nbd_reply * reply ) { uint8_t buf [ 4 + 4 + 8 ] ; cpu_to_be32w ( ( uint32_t * ) buf , NBD_REPLY_MAGIC ) ; cpu_to_be32w ( ( uint32_t * ) ( buf + 4 ) , reply -> error ) ; cpu_to_be64w ( ( uint64_t * ) ( buf + 8 ) , reply -> handle ) ; TRACE ( "Sending response to client" ) ; if ( write_sync ( csock , buf , sizeof ( buf ) ) != sizeof ( buf ) ) { LOG ( "writing to socket failed" ) ; errno = EINVAL ; return - 1 ; } return 0 ; }##::##0##::##3140
static void sclp_execute ( SCCB * sccb , uint64_t code ) { S390SCLPDevice * sdev = get_event_facility ( ) ; switch ( code & SCLP_CMD_CODE_MASK ) { case SCLP_CMDW_READ_SCP_INFO : case SCLP_CMDW_READ_SCP_INFO_FORCED : read_SCP_info ( sccb ) ; break ; case SCLP_CMDW_READ_CPU_INFO : sclp_read_cpu_info ( sccb ) ; break ; default : sdev -> sclp_command_handler ( sdev -> ef , sccb , code ) ; break ; } }##::##0##::##7346
static void check_mct ( uint8_t * ref0 , uint8_t * ref1 , uint8_t * ref2 , uint8_t * new0 , uint8_t * new1 , uint8_t * new2 ) { declare_func ( void , void * src0 , void * src1 , void * src2 , int csize ) ; randomize_buffers ( ) ; call_ref ( ref0 , ref1 , ref2 , BUF_SIZE / sizeof ( int32_t ) ) ; call_new ( new0 , new1 , new2 , BUF_SIZE / sizeof ( int32_t ) ) ; if ( memcmp ( ref0 , new0 , BUF_SIZE ) || memcmp ( ref1 , new1 , BUF_SIZE ) || memcmp ( ref2 , new2 , BUF_SIZE ) ) { fail ( ) ; } bench_new ( new0 , new1 , new2 , BUF_SIZE / sizeof ( int32_t ) ) ; }##::##0##::##4417
static void update ( NUTContext * nut , int stream_index , int64_t frame_start , int frame_type , int frame_code , int key_frame , int size , int64_t pts ) { StreamContext * stream = & nut -> stream [ stream_index ] ; stream -> last_key_frame = key_frame ; nut -> last_frame_start [ frame_type ] = frame_start ; update_lru ( stream -> lru_pts_delta , pts - stream -> last_pts , 3 ) ; update_lru ( stream -> lru_size , size , 2 ) ; stream -> last_pts = pts ; if ( nut -> frame_code [ frame_code ] . flags & FLAG_PTS && nut -> frame_code [ frame_code ] . flags & FLAG_FULL_PTS ) { stream -> last_full_pts = pts ; } }##::##0##::##12161
void ff_vp3_v_loop_filter_c ( uint8_t * first_pixel , int stride , int * bounding_values ) { unsigned char * end ; int filter_value ; const int nstride = - stride ; for ( end = first_pixel + 8 ; first_pixel < end ; first_pixel ++ ) { filter_value = ( first_pixel [ 2 * nstride ] - first_pixel [ stride ] ) + 3 * ( first_pixel [ 0 ] - first_pixel [ nstride ] ) ; filter_value = bounding_values [ ( filter_value + 4 ) >> 3 ] ; first_pixel [ nstride ] = av_clip_uint8 ( first_pixel [ nstride ] + filter_value ) ; first_pixel [ 0 ] = av_clip_uint8 ( first_pixel [ 0 ] - filter_value ) ; } }##::##0##::##369
static void coroutine_fn bdrv_rw_co_entry ( void * opaque ) { RwCo * rwco = opaque ; if ( ! rwco -> is_write ) { rwco -> ret = bdrv_co_do_preadv ( rwco -> bs , rwco -> offset , rwco -> qiov -> size , rwco -> qiov , rwco -> flags ) ; } else { rwco -> ret = bdrv_co_do_pwritev ( rwco -> bs , rwco -> offset , rwco -> qiov -> size , rwco -> qiov , rwco -> flags ) ; } }##::##0##::##13330
static void aarch64_any_initfn ( Object * obj ) { ARMCPU * cpu = ARM_CPU ( obj ) ; set_feature ( & cpu -> env , ARM_FEATURE_V8 ) ; set_feature ( & cpu -> env , ARM_FEATURE_VFP4 ) ; set_feature ( & cpu -> env , ARM_FEATURE_NEON ) ; set_feature ( & cpu -> env , ARM_FEATURE_AARCH64 ) ; set_feature ( & cpu -> env , ARM_FEATURE_V8_AES ) ; set_feature ( & cpu -> env , ARM_FEATURE_V8_SHA1 ) ; set_feature ( & cpu -> env , ARM_FEATURE_V8_SHA256 ) ; set_feature ( & cpu -> env , ARM_FEATURE_V8_PMULL ) ; set_feature ( & cpu -> env , ARM_FEATURE_CRC ) ; cpu -> ctr = 0x80030003 ; cpu -> dcz_blocksize = 7 ; }##::##0##::##12603
static void gen_spr_power8_book4 ( CPUPPCState * env ) { # if ! defined ( CONFIG_USER_ONLY ) spr_register_kvm ( env , SPR_ACOP , "ACOP" , SPR_NOACCESS , SPR_NOACCESS , & spr_read_generic , & spr_write_generic , KVM_REG_PPC_ACOP , 0 ) ; spr_register_kvm ( env , SPR_BOOKS_PID , "PID" , SPR_NOACCESS , SPR_NOACCESS , & spr_read_generic , & spr_write_generic , KVM_REG_PPC_PID , 0 ) ; spr_register_kvm ( env , SPR_WORT , "WORT" , SPR_NOACCESS , SPR_NOACCESS , & spr_read_generic , & spr_write_generic , KVM_REG_PPC_WORT , 0 ) ; # endif }##::##0##::##122
static int ssi_sd_init ( SSISlave * d ) { DeviceState * dev = DEVICE ( d ) ; ssi_sd_state * s = FROM_SSI_SLAVE ( ssi_sd_state , d ) ; DriveInfo * dinfo ; s -> mode = SSI_SD_CMD ; dinfo = drive_get_next ( IF_SD ) ; s -> sd = sd_init ( dinfo ? blk_bs ( blk_by_legacy_dinfo ( dinfo ) ) : NULL , true ) ; if ( s -> sd == NULL ) { return - 1 ; } register_savevm ( dev , "ssi_sd" , - 1 , 1 , ssi_sd_save , ssi_sd_load , s ) ; return 0 ; }##::##0##::##4384
static void apic_reset_common ( DeviceState * dev ) { APICCommonState * s = APIC_COMMON ( dev ) ; APICCommonClass * info = APIC_COMMON_GET_CLASS ( s ) ; bool bsp ; bsp = cpu_is_bsp ( s -> cpu ) ; s -> apicbase = APIC_DEFAULT_ADDRESS | ( bsp ? MSR_IA32_APICBASE_BSP : 0 ) | MSR_IA32_APICBASE_ENABLE ; s -> vapic_paddr = 0 ; info -> vapic_base_update ( s ) ; apic_init_reset ( dev ) ; if ( bsp ) { s -> lvt [ APIC_LVT_LINT0 ] = 0x700 ; } }##::##0##::##14484
int ff_h264_get_profile ( SPS * sps ) { int profile = sps -> profile_idc ; switch ( sps -> profile_idc ) { case FF_PROFILE_H264_BASELINE : profile |= ( sps -> constraint_set_flags & 1 << 1 ) ? FF_PROFILE_H264_CONSTRAINED : 0 ; break ; case FF_PROFILE_H264_HIGH_10 : case FF_PROFILE_H264_HIGH_422 : case FF_PROFILE_H264_HIGH_444_PREDICTIVE : profile |= ( sps -> constraint_set_flags & 1 << 3 ) ? FF_PROFILE_H264_INTRA : 0 ; break ; } return profile ; }##::##0##::##269
static void serial_init_core ( SerialState * s ) { if ( ! s -> chr ) { fprintf ( stderr , "Can't create serial device, empty char device\n" ) ; exit ( 1 ) ; } s -> modem_status_poll = qemu_new_timer ( vm_clock , ( QEMUTimerCB * ) serial_update_msl , s ) ; s -> fifo_timeout_timer = qemu_new_timer ( vm_clock , ( QEMUTimerCB * ) fifo_timeout_int , s ) ; s -> transmit_timer = qemu_new_timer ( vm_clock , ( QEMUTimerCB * ) serial_xmit , s ) ; qemu_register_reset ( serial_reset , s ) ; serial_reset ( s ) ; qemu_chr_add_handlers ( s -> chr , serial_can_receive1 , serial_receive1 , serial_event , s ) ; }##::##0##::##1189
static int delta_decode ( int8_t * dst , const uint8_t * src , int src_size , int8_t val , const int8_t * table ) { int n = src_size ; int8_t * dst0 = dst ; while ( n -- ) { uint8_t d = * src ++ ; val = av_clip ( val + table [ d & 0x0f ] , - 127 , 128 ) ; * dst ++ = val ; val = av_clip ( val + table [ d >> 4 ] , - 127 , 128 ) ; * dst ++ = val ; } return dst - dst0 ; }##::##0##::##11231
static inline void patch_reloc ( tcg_insn_unit * code_ptr , int type , intptr_t value , intptr_t addend ) { assert ( addend == 0 ) ; switch ( type ) { case R_AARCH64_JUMP26 : case R_AARCH64_CALL26 : reloc_pc26 ( code_ptr , ( tcg_insn_unit * ) value ) ; break ; case R_AARCH64_CONDBR19 : reloc_pc19 ( code_ptr , ( tcg_insn_unit * ) value ) ; break ; default : tcg_abort ( ) ; } }##::##0##::##5326
static void help ( int exitcode ) { const char * options_help = # define QEMU_OPTIONS_GENERATE_HELP # include "qemu-options-wrapper.h" ; version ( ) ; printf ( "usage: %s [options] [disk_image]\n" "\n" "'disk_image' is a raw hard disk image for IDE hard disk 0\n" "\n" "%s\n" "During emulation, the following keys are useful:\n" "ctrl-alt-f      toggle full screen\n" "ctrl-alt-n      switch to virtual console 'n'\n" "ctrl-alt        toggle mouse and keyboard grab\n" "\n" "When using -nographic, press 'ctrl-a h' to get some help.\n" , error_get_progname ( ) , options_help ) ; exit ( exitcode ) ; }##::##0##::##10626
static int pc_rec_cmp ( const void * p1 , const void * p2 ) { PCRecord * r1 = * ( PCRecord * * ) p1 ; PCRecord * r2 = * ( PCRecord * * ) p2 ; if ( r1 -> count < r2 -> count ) { return 1 ; } else if ( r1 -> count == r2 -> count ) { return 0 ; } else { return - 1 ; } }##::##0##::##3182
int ff_framesync_dualinput_get_writable ( FFFrameSync * fs , AVFrame * * f0 , AVFrame * * f1 ) { int ret ; ret = ff_framesync_dualinput_get ( fs , f0 , f1 ) ; if ( ret < 0 ) { return ret ; } ret = ff_inlink_make_frame_writable ( fs -> parent -> inputs [ 0 ] , f0 ) ; if ( ret < 0 ) { av_frame_free ( f0 ) ; av_frame_free ( f1 ) ; return ret ; } return 0 ; }##::##0##::##3829
